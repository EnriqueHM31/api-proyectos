[
    {
        "code": 100,
        "status": "Continue",
        "category": "Informational",
        "description": "El código 100 Continue es una respuesta provisional que indica que el cliente debe continuar con su solicitud o ignorar esta respuesta si la solicitud ya ha sido completada. Este código se utiliza principalmente en escenarios donde el cliente necesita enviar un cuerpo de solicitud grande y quiere verificar primero si el servidor está dispuesto a aceptarlo antes de enviar todos los datos. El cliente envía los encabezados de la solicitud con un encabezado 'Expect: 100-continue', y el servidor responde con 100 Continue si está listo para recibir el cuerpo de la solicitud. Esto es especialmente útil para optimizar el ancho de banda y evitar enviar grandes cantidades de datos que podrían ser rechazados por el servidor. Por ejemplo, si un cliente intenta subir un archivo de 500MB, puede primero enviar los encabezados para verificar la autenticación y validación antes de transmitir todo el archivo. Si el servidor responde con 100 Continue, el cliente procede a enviar el cuerpo completo. Si el servidor responde con un código de error (como 401 Unauthorized), el cliente puede abortar la transmisión sin haber desperdiciado ancho de banda enviando el archivo completo.",
        "useCases": [
            "Upload de archivos grandes donde se necesita validación previa",
            "APIs que requieren verificación de autenticación antes de procesar cuerpos de solicitud pesados",
            "Optimización de ancho de banda en conexiones lentas",
            "Sistemas de streaming donde se necesita confirmación del servidor antes de enviar datos"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo grande",
                "request": "POST /upload HTTP/1.1\nHost: example.com\nExpect: 100-continue\nContent-Length: 524288000\nContent-Type: application/octet-stream",
                "response": "HTTP/1.1 100 Continue",
                "explanation": "El servidor acepta recibir el archivo, el cliente procede a enviar los 500MB"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611664/404_2_l0oyj5.png",
                "alt": "Imagen que representa el nombre del código 100 Continue"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618710/1-removebg-preview_tkp4yz.png",
                "alt": "Imagen del código 100 Continue"
            }
        ]
    },
    {
        "code": 101,
        "status": "Switching Protocols",
        "category": "Informational",
        "description": "El código 101 Switching Protocols indica que el servidor está cambiando de protocolo según lo solicitado por el cliente a través del encabezado 'Upgrade'. Este mecanismo permite que una conexión establecida inicialmente con HTTP evolucione a un protocolo diferente, como WebSocket, HTTP/2, o cualquier otro protocolo compatible. El servidor envía este código para confirmar que acepta cambiar al protocolo solicitado en el encabezado Upgrade de la solicitud del cliente. Después de enviar esta respuesta, el servidor abandona el protocolo HTTP/1.1 y comienza a comunicarse usando el nuevo protocolo especificado. Este código es fundamental para la implementación de WebSockets, que permite comunicación bidireccional en tiempo real sobre una única conexión TCP. El proceso típico involucra una solicitud HTTP inicial que solicita el upgrade, el servidor responde con 101, y a partir de ese momento la conexión opera bajo el nuevo protocolo. Esto es especialmente valioso en aplicaciones que requieren comunicación en tiempo real, como chats, juegos multijugador, dashboards en vivo, o aplicaciones colaborativas. Es importante notar que no todos los proxies o intermediarios soportan este mecanismo, por lo que la implementación debe considerar compatibilidad.",
        "useCases": [
            "Establecimiento de conexiones WebSocket para comunicación bidireccional en tiempo real",
            "Upgrade de HTTP/1.1 a HTTP/2 para mejorar el rendimiento",
            "Implementación de Server-Sent Events (SSE) en algunos casos",
            "Protocolos personalizados que necesitan una conexión HTTP inicial"
        ],
        "examples": [
            {
                "scenario": "Upgrade a WebSocket",
                "request": "GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13",
                "response": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
                "explanation": "El servidor acepta el upgrade a WebSocket y la conexión ahora usa el protocolo WebSocket"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597106/1_ltkyhn.png",
                "alt": "Imagen que representa el nombre del código 101 Switching Protocols"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618707/2-removebg-preview_jjwrov.png",
                "alt": "Imagen del código 101 Switching Protocols"
            }
        ]
    },
    {
        "code": 102,
        "status": "Processing",
        "category": "Informational",
        "description": "El código 102 Processing es una respuesta provisional que indica que el servidor ha recibido y está procesando la solicitud, pero aún no tiene una respuesta disponible. Este código se utiliza principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para prevenir que el cliente agote el tiempo de espera en operaciones que requieren mucho tiempo de procesamiento. Cuando un servidor WebDAV recibe una solicitud que puede tomar tiempo significativo para completarse (como copiar una gran estructura de directorios, realizar operaciones complejas en múltiples recursos, o procesar transformaciones de archivos grandes), envía este código intermedio para mantener la conexión activa y asegurar al cliente que la solicitud no se ha perdido o estancado. El cliente, al recibir este código, puede resetear su temporizador de timeout y continuar esperando. Es particularmente útil en operaciones como PROPFIND sobre grandes colecciones de recursos, operaciones COPY o MOVE masivas, o cualquier operación que involucre procesamiento extensivo en el servidor. A diferencia de 100 Continue que es sobre el envío de datos, 102 Processing es sobre la ejecución de la operación solicitada.",
        "useCases": [
            "Operaciones WebDAV que toman tiempo significativo (PROPFIND, COPY, MOVE)",
            "Procesamiento de grandes estructuras de archivos en sistemas de gestión de contenido",
            "Operaciones batch sobre múltiples recursos",
            "Transformaciones o conversiones de archivos que requieren tiempo de procesamiento extenso"
        ],
        "examples": [
            {
                "scenario": "Copia masiva de directorios en WebDAV",
                "request": "COPY /documents/folder1/ HTTP/1.1\nHost: webdav.example.com\nDestination: /documents/folder2/\nDepth: infinity",
                "response": "HTTP/1.1 102 Processing",
                "explanation": "El servidor informa que está copiando los archivos recursivamente y el cliente debe seguir esperando"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2518 (WebDAV)",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611761/2_je4oyl.png",
                "alt": "Imagen que representa el nombre del código 102 Processing"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618704/3-removebg-preview_cj1fzy.png",
                "alt": "Imagen del código 102 Processing"
            }
        ]
    },
    {
        "code": 103,
        "status": "Early Hints",
        "category": "Informational",
        "description": "El código 103 Early Hints es una respuesta informativa relativamente nueva que permite al servidor enviar encabezados HTTP preliminares antes de que la respuesta final esté lista. Su propósito principal es mejorar el rendimiento de carga de páginas web al permitir que el navegador comience a pre-cargar recursos críticos mientras el servidor aún está preparando la respuesta completa. Esto es especialmente valioso cuando el servidor necesita tiempo para generar contenido dinámico pero ya sabe qué recursos adicionales (CSS, JavaScript, fuentes, imágenes) serán necesarios. El servidor puede enviar encabezados Link con rel=preload o rel=preconnect, permitiendo que el navegador inicie la descarga de estos recursos en paralelo mientras espera la respuesta HTML principal. Por ejemplo, si un servidor de aplicación necesita consultar una base de datos para generar una página pero ya sabe que necesitará ciertos archivos CSS y JavaScript, puede enviar 103 Early Hints inmediatamente con referencias a esos recursos. Esto reduce significativamente el tiempo de carga percibido y mejora métricas como First Contentful Paint (FCP) y Largest Contentful Paint (LCP). Es particularmente efectivo en sitios con tiempos de procesamiento del servidor variables o consultas de base de datos complejas.",
        "useCases": [
            "Precarga de recursos estáticos (CSS, JS, fuentes) mientras se genera contenido dinámico",
            "Establecimiento anticipado de conexiones a dominios de terceros (CDNs, APIs)",
            "Optimización del rendimiento web y mejora de Core Web Vitals",
            "Reducción del tiempo de carga en aplicaciones con procesamiento del servidor intensivo"
        ],
        "examples": [
            {
                "scenario": "Precarga de recursos críticos",
                "request": "GET /dashboard HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 103 Early Hints\nLink: </styles/critical.css>; rel=preload; as=style\nLink: </scripts/app.js>; rel=preload; as=script\nLink: <https://cdn.example.com>; rel=preconnect\n\n[... el servidor continúa procesando ...]\n\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>...",
                "explanation": "El navegador recibe instrucciones para precargar CSS y JS mientras el servidor genera el HTML del dashboard"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 8297",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597108/3_av4aj8.png",
                "alt": "Imagen que representa el nombre del código 103 Early Hints  "
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618702/4-removebg-preview_gkrmuw.png",
                "alt": "Imagen del código 103 Early Hints"
            }
        ]
    },
    {
        "code": 200,
        "status": "OK",
        "category": "Success",
        "description": "El código 200 OK es la respuesta de éxito estándar y más común en HTTP. Indica que la solicitud ha sido procesada exitosamente y el servidor está devolviendo el resultado solicitado. El significado específico de 'éxito' varía según el método HTTP utilizado: para GET significa que el recurso ha sido recuperado y se transmite en el cuerpo del mensaje; para POST indica que el recurso que describe el resultado de la acción se transmite en el cuerpo del mensaje; para PUT o PATCH significa que el recurso ha sido modificado exitosamente; para DELETE indica que el recurso ha sido eliminado. Este código es el caballo de batalla de las APIs REST y aplicaciones web. La respuesta 200 típicamente incluye el cuerpo del mensaje con el contenido solicitado (HTML, JSON, XML, archivos binarios, etc.) junto con encabezados relevantes como Content-Type, Content-Length, Cache-Control, ETag, entre otros. Es importante notar que 200 no siempre es la respuesta más semántica - por ejemplo, una creación exitosa debería usar 201 Created, y una eliminación exitosa sin contenido debería usar 204 No Content. El uso apropiado de códigos de estado hace que las APIs sean más expresivas y fáciles de consumir.",
        "useCases": [
            "Recuperación exitosa de recursos (GET requests)",
            "Respuestas exitosas de búsquedas o consultas",
            "Actualizaciones parciales exitosas (PATCH)",
            "Cualquier operación exitosa que devuelve contenido en el cuerpo",
            "Respuestas de APIs que devuelven datos JSON o XML"
        ],
        "examples": [
            {
                "scenario": "GET request a una API REST",
                "request": "GET /api/users/123 HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 145\nCache-Control: max-age=3600\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}",
                "explanation": "El servidor devuelve exitosamente los datos del usuario solicitado en formato JSON"
            },
            {
                "scenario": "POST request que procesa datos",
                "request": "POST /api/search HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"query\": \"javascript tutorials\"}",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"results\": [\n    {\"title\": \"JS Basics\", \"url\": \"https://example.com/js-basics\"},\n    {\"title\": \"Advanced JS\", \"url\": \"https://example.com/advanced-js\"}\n  ],\n  \"count\": 2\n}",
                "explanation": "La búsqueda se procesó exitosamente y devuelve los resultados"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613634/1_bikeld.png",
                "alt": "Imagen que representa el nombre del código 200 OK"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619787/5-removebg-preview_wc1wto.png",
                "alt": "Imagen del código 200 OK"
            }
        ]
    },
    {
        "code": 201,
        "status": "Created",
        "category": "Success",
        "description": "El código 201 Created indica que la solicitud ha sido exitosa y ha resultado en la creación de uno o más recursos nuevos. Este código es semánticamente más apropiado que 200 OK cuando se crea un nuevo recurso, típicamente en respuesta a solicitudes POST o PUT. La respuesta 201 debe incluir un encabezado Location que contenga la URI del recurso recién creado, permitiendo al cliente acceder directamente al nuevo recurso sin necesidad de búsquedas adicionales. Opcionalmente, el cuerpo de la respuesta puede contener una representación del recurso creado o una descripción del estado de la creación. Este código es fundamental en APIs RESTful bien diseñadas, donde la creación de recursos es una operación común. Por ejemplo, cuando se crea un nuevo usuario, una nueva publicación de blog, un nuevo pedido de compra, o cualquier entidad en el sistema, 201 es la respuesta apropiada. La inclusión del encabezado Location es crucial porque permite a los clientes saber inmediatamente dónde encontrar el recurso recién creado, especialmente útil cuando el servidor genera IDs automáticamente. Algunas implementaciones también incluyen el recurso completo en el cuerpo de la respuesta para evitar que el cliente tenga que hacer una solicitud GET adicional.",
        "useCases": [
            "Creación de nuevos usuarios en un sistema",
            "Publicación de nuevos contenidos (artículos, posts, comentarios)",
            "Creación de pedidos o transacciones",
            "Registro de nuevas entidades en bases de datos mediante APIs",
            "Upload de archivos o recursos que generan nuevas entradas"
        ],
        "examples": [
            {
                "scenario": "Creación de un nuevo usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/users/456\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"created_at\": \"2024-01-16T14:22:00Z\",\n  \"profile_url\": \"/api/users/456\"\n}",
                "explanation": "El usuario fue creado exitosamente, el servidor asignó el ID 456 y devuelve la ubicación del nuevo recurso"
            },
            {
                "scenario": "Creación de un post en blog",
                "request": "POST /api/posts HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token123\n\n{\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"content\": \"HTTP status codes are...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/posts/789\nContent-Type: application/json\n\n{\n  \"id\": 789,\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"slug\": \"introduction-to-http-status-codes\",\n  \"author_id\": 123,\n  \"created_at\": \"2024-01-16T14:25:00Z\",\n  \"status\": \"published\"\n}",
                "explanation": "El post fue creado y publicado, incluyendo metadatos generados por el servidor como slug y timestamps"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613643/2_hapb2d.png",
                "alt": "Imagen que representa el nombre del código 201 Created"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619783/6-removebg-preview_ytp56u.png",
                "alt": "Imagen del codigo 201 Created"
            }
        ]
    },
    {
        "code": 202,
        "status": "Accepted",
        "category": "Success",
        "description": "El código 202 Accepted indica que la solicitud ha sido aceptada para procesamiento, pero el procesamiento aún no se ha completado. Este código es especialmente útil para operaciones asíncronas donde el servidor acepta la solicitud pero la procesará más tarde, en segundo plano. La respuesta 202 es no-comprometida, lo que significa que el servidor acepta la solicitud pero no garantiza que será procesada exitosamente - el procesamiento real podría fallar posteriormente. Este código es ideal para operaciones de larga duración como procesamiento de archivos grandes, conversiones de video, operaciones batch, envío de emails masivos, generación de reportes complejos, o cualquier tarea que no puede completarse inmediatamente dentro del tiempo de respuesta HTTP típico. La respuesta debería incluir información sobre el estado del procesamiento y cómo el cliente puede verificar el progreso, típicamente mediante un encabezado Location que apunta a un recurso de estado o mediante un cuerpo de respuesta que incluye un ID de tarea que puede ser consultado posteriormente. Muchas APIs modernas usan este patrón para operaciones pesadas, proporcionando endpoints separados para verificar el estado de las tareas en progreso.",
        "useCases": [
            "Procesamiento asíncrono de archivos (conversión de video, compresión de imágenes)",
            "Operaciones batch que toman tiempo significativo",
            "Envío de emails masivos o notificaciones",
            "Generación de reportes complejos o exports de datos",
            "Operaciones que requieren aprobación manual posterior",
            "Tareas en cola que serán procesadas por workers en background"
        ],
        "examples": [
            {
                "scenario": "Upload y procesamiento de video",
                "request": "POST /api/videos HTTP/1.1\nHost: media.example.com\nContent-Type: multipart/form-data\n\n[video file data]",
                "response": "HTTP/1.1 202 Accepted\nLocation: /api/jobs/video-process-999\nContent-Type: application/json\n\n{\n  \"job_id\": \"video-process-999\",\n  \"status\": \"queued\",\n  \"message\": \"Video upload accepted. Processing will begin shortly.\",\n  \"status_url\": \"/api/jobs/video-process-999\",\n  \"estimated_completion\": \"2024-01-16T15:30:00Z\"\n}",
                "explanation": "El video fue recibido y está en cola para procesamiento. El cliente puede verificar el estado usando la URL proporcionada"
            },
            {
                "scenario": "Generación de reporte complejo",
                "request": "POST /api/reports/generate HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\n\n{\n  \"type\": \"annual_sales\",\n  \"year\": 2024,\n  \"format\": \"pdf\",\n  \"include_charts\": true\n}",
                "response": "HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n  \"task_id\": \"report-gen-12345\",\n  \"status\": \"processing\",\n  \"progress_url\": \"/api/tasks/report-gen-12345/status\",\n  \"webhook_url\": null,\n  \"message\": \"Report generation started. You will be notified when complete.\"\n}",
                "explanation": "El servidor acepta la solicitud de generación de reporte y la procesa en background"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.3",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613646/3_clmvyi.png",
                "alt": "Imagen que representa el nombre del código 202 Accepted"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619780/7-removebg-preview_mh2ybs.png",
                "alt": "Imagen del código 202 Accepted"
            }
        ]
    },
    {
        "code": 203,
        "status": "Non-Authoritative Information",
        "category": "Success",
        "description": "El código 203 Non-Authoritative Information indica que la solicitud fue exitosa pero la información incluida en la respuesta proviene de una copia local o de terceros, no del servidor origen original. Este código es utilizado principalmente por proxies HTTP o cachés que modifican o transforman la respuesta del servidor origen. Aunque la respuesta es exitosa (similar a 200 OK), el código 203 advierte al cliente que los metadatos (encabezados) pueden haber sido modificados por un intermediario y pueden no ser exactamente los mismos que el servidor origen habría proporcionado. El cuerpo de la entidad puede ser idéntico al de una respuesta 200, pero los encabezados podrían ser diferentes. Este código es poco común en la práctica moderna pero es útil en escenarios donde proxies realizan transformaciones, como conversión de formatos de imagen, compresión adicional, añadir encabezados de seguridad, o modificar metadatos. Por ejemplo, un proxy de optimización podría comprimir imágenes antes de enviarlas al cliente y usar 203 para indicar que aunque el contenido es válido, ha sido procesado. También puede ser usado en escenarios de mirror servers o CDNs que sirven contenido desde múltiples ubicaciones y quieren indicar que la respuesta no viene directamente del servidor origen.",
        "useCases": [
            "Respuestas servidas por proxies que modifican metadatos",
            "CDNs o mirrors que sirven contenido almacenado en caché con encabezados modificados",
            "Proxies de transformación que optimizan contenido (compresión de imágenes, minificación)",
            "Sistemas de caché que añaden encabezados adicionales a las respuestas",
            "Servicios de agregación que combinan datos de múltiples fuentes"
        ],
        "examples": [
            {
                "scenario": "Proxy que modifica encabezados de imagen",
                "request": "GET /images/photo.jpg HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: image/jpeg\nContent-Length: 45000\nX-Proxy-Optimized: true\nX-Original-Size: 120000\nVia: 1.1 proxy.example.com\n\n[compressed image data]",
                "explanation": "Un proxy interceptó la imagen, la comprimió, y modificó los encabezados para reflejar el nuevo tamaño"
            },
            {
                "scenario": "CDN sirviendo contenido con metadatos adicionales",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: application/json\nX-Cache: HIT\nX-CDN-Server: edge-server-42\nAge: 3600\n\n{\"data\": \"cached content\"}",
                "explanation": "El CDN sirve contenido en caché y añade encabezados propios que no venían del servidor origen"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.4",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613641/4_jesleh.png",
                "alt": "Imagen que representa el nombre del código 203 Non-Authoritative Information"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619769/8-removebg-preview_cd7hdi.png",
                "alt": "Imagen del código 203 Non-Authoritative Information"
            }
        ]
    },
    {
        "code": 204,
        "status": "No Content",
        "category": "Success",
        "description": "El código 204 No Content indica que el servidor ha procesado exitosamente la solicitud pero no devuelve ningún contenido en el cuerpo de la respuesta. Este código es semánticamente diferente de 200 OK en que explícitamente comunica que no hay contenido para devolver, lo cual es la intención, no un error. La respuesta 204 no debe contener un cuerpo de mensaje - el mensaje termina después de los encabezados. Este código es extremadamente útil en APIs REST para operaciones que modifican el estado del servidor pero no necesitan devolver datos al cliente, como eliminaciones exitosas, actualizaciones donde el cliente ya tiene todos los datos necesarios, o acciones que simplemente cambian el estado sin generar nueva información. Es también común en solicitudes PUT o PATCH donde el cliente envía la representación completa del recurso y no necesita que el servidor la devuelva. El código 204 ahorra ancho de banda al no enviar cuerpos de respuesta innecesarios y hace que las APIs sean más eficientes. En aplicaciones web, una respuesta 204 típicamente no causa que el navegador actualice la página actual, lo cual es útil para operaciones AJAX que modifican datos en el servidor sin necesitar recargar la interfaz.",
        "useCases": [
            "Eliminación exitosa de recursos (DELETE requests)",
            "Actualizaciones que no requieren devolver el recurso modificado",
            "Operaciones de guardado automático donde no se necesita confirmación con datos",
            "Acciones que cambian estado del servidor sin generar nueva información",
            "Heartbeats o keep-alive requests",
            "Operaciones batch donde solo importa el éxito, no los detalles"
        ],
        "examples": [
            {
                "scenario": "Eliminación de un recurso",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token123",
                "response": "HTTP/1.1 204 No Content\nDate: Tue, 16 Jan 2024 15:00:00 GMT",
                "explanation": "El usuario fue eliminado exitosamente, no hay contenido adicional que devolver"
            },
            {
                "scenario": "Actualización de preferencias de usuario",
                "request": "PUT /api/users/123/preferences HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"theme\": \"dark\",\n  \"language\": \"es\",\n  \"notifications\": true\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "Las preferencias fueron actualizadas exitosamente, el cliente ya tiene los datos que envió"
            },
            {
                "scenario": "Guardado automático de documento",
                "request": "PATCH /api/documents/456/autosave HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\n\n{\n  \"content\": \"Updated document content...\",\n  \"last_modified\": \"2024-01-16T15:05:00Z\"\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "El documento fue guardado automáticamente sin necesidad de respuesta con contenido"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.5",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613653/5_efixbc.png",
                "alt": "Imagen que representa el nombre del código 204 No Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619773/9-removebg-preview_wavvrt.png",
                "alt": "Imagen del código 204 No Content"
            }
        ]
    },
    {
        "code": 205,
        "status": "Reset Content",
        "category": "Success",
        "description": "El código 205 Reset Content indica que el servidor ha procesado exitosamente la solicitud y está instruyendo al agente de usuario (típicamente un navegador) a resetear la vista del documento que causó la solicitud a su estado original. A diferencia de 204 No Content, que simplemente no devuelve contenido, 205 específicamente solicita que el cliente reinicie la interfaz de usuario. Este código es particularmente útil en aplicaciones de formularios web donde, después de enviar datos exitosamente, se desea limpiar el formulario para permitir al usuario ingresar nuevos datos sin necesidad de recargar la página completa. Por ejemplo, en un formulario de entrada de datos repetitiva (como ingreso de inventario, registro de múltiples transacciones, o captura de datos en serie), después de cada envío exitoso, el servidor puede responder con 205 para resetear el formulario automáticamente. Al igual que 204, la respuesta 205 no debe contener un cuerpo de mensaje. La diferencia clave es la semántica: 204 dice 'éxito, sin más información', mientras que 205 dice 'éxito, y por favor resetea tu interfaz'. En la práctica moderna, este código es poco utilizado ya que muchas aplicaciones manejan el reseteo de formularios directamente en el cliente con JavaScript, pero sigue siendo válido y útil para aplicaciones tradicionales basadas en formularios HTML.",
        "useCases": [
            "Formularios de entrada de datos repetitiva donde se quiere limpiar campos después del envío",
            "Aplicaciones de encuestas o cuestionarios que permiten múltiples respuestas",
            "Sistemas de captura de datos en serie (inventario, transacciones, registros)",
            "Formularios de búsqueda donde se quiere limpiar los criterios después de ejecutar la búsqueda",
            "Interfaces de administración con formularios que se usan repetidamente"
        ],
        "examples": [
            {
                "scenario": "Formulario de entrada de inventario",
                "request": "POST /inventory/add HTTP/1.1\nHost: warehouse.example.com\nContent-Type: application/x-www-form-urlencoded\n\nproduct_id=ABC123&quantity=50&location=warehouse-a",
                "response": "HTTP/1.1 205 Reset Content\nDate: Tue, 16 Jan 2024 15:10:00 GMT",
                "explanation": "El item fue agregado al inventario y el navegador debe limpiar el formulario para la siguiente entrada"
            },
            {
                "scenario": "Formulario de comentarios/feedback",
                "request": "POST /feedback/submit HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n  \"rating\": 5,\n  \"comment\": \"Excellent service!\",\n  \"category\": \"support\"\n}",
                "response": "HTTP/1.1 205 Reset Content",
                "explanation": "El feedback fue registrado y el formulario debe resetearse para permitir otro envío"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.6",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613651/6_blwgmz.png",
                "alt": "Imagen que representa el nombre del código 205 Reset Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619776/10-removebg-preview_lt16pz.png",
                "alt": "Imagen del código 205 Reset Content"
            }
        ]
    },
    {
        "code": 206,
        "status": "Partial Content",
        "category": "Success",
        "description": "El código 206 Partial Content indica que el servidor está entregando solo una parte del recurso solicitado debido a un encabezado Range enviado por el cliente. Este código es fundamental para la descarga de archivos grandes, streaming de video/audio, y para permitir la reanudación de descargas interrumpidas. Cuando un cliente solicita un rango específico de bytes de un recurso (por ejemplo, bytes 0-1023 de un archivo de 100MB), el servidor responde con 206 y solo los bytes solicitados. La respuesta debe incluir encabezados Content-Range que especifican qué porción del recurso se está enviando y el tamaño total del recurso, y Content-Length que indica el tamaño de la porción actual. Este mecanismo es esencial para aplicaciones de streaming donde el cliente puede solicitar chunks específicos de un video o audio, para administradores de descargas que dividen archivos grandes en múltiples segmentos para descargar en paralelo, y para reanudar descargas interrumpidas solicitando solo la porción faltante. Los navegadores modernos y reproductores de video utilizan extensivamente este código para permitir la búsqueda dentro de videos (cuando mueves la barra de progreso), para cargar solo las porciones visibles de archivos PDF grandes, o para implementar lazy loading eficiente de recursos multimedia.",
        "useCases": [
            "Streaming de video y audio (permitiendo seek/skip)",
            "Descarga resumible de archivos grandes",
            "Descarga paralela de archivos en múltiples segmentos",
            "Visualización de porciones específicas de documentos grandes (PDFs)",
            "Optimización de ancho de banda cargando solo lo necesario",
            "Implementación de lazy loading para contenido multimedia"
        ],
        "examples": [
            {
                "scenario": "Solicitud de rango de bytes de un video",
                "request": "GET /videos/movie.mp4 HTTP/1.1\nHost: cdn.example.com\nRange: bytes=1000000-2999999",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: video/mp4\nContent-Length: 2000000\nContent-Range: bytes 1000000-2999999/500000000\nAccept-Ranges: bytes\n\n[2MB de datos de video]",
                "explanation": "El servidor envía 2MB específicos del video (del byte 1M al byte 3M) de un total de 500MB"
            },
            {
                "scenario": "Reanudación de descarga interrumpida",
                "request": "GET /downloads/software.zip HTTP/1.1\nHost: downloads.example.com\nRange: bytes=50000000-",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: application/zip\nContent-Length: 50000000\nContent-Range: bytes 50000000-99999999/100000000\nAccept-Ranges: bytes\n\n[50MB restantes del archivo]",
                "explanation": "La descarga se reanuda desde el byte 50M hasta el final del archivo de 100MB"
            },
            {
                "scenario": "Descarga paralela con múltiples rangos",
                "request": "GET /files/large-dataset.dat HTTP/1.1\nHost: data.example.com\nRange: bytes=0-10485759,10485760-20971519",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=BOUNDARY_STRING\nContent-Length: 20971520\n\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 0-10485759/1073741824\n\n[primeros 10MB]\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 10485760-20971519/1073741824\n\n[siguientes 10MB]\n--BOUNDARY_STRING--",
                "explanation": "El cliente solicita dos rangos simultáneos para descarga paralela"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613659/7_ts5rgr.png",
                "alt": "Imagen que representa el nombre del código 206 Partial Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619763/11-removebg-preview_krzu2a.png",
                "alt": "Imagen del código 206 Partial Content"
            }
        ]
    },
    {
        "code": 207,
        "status": "Multi-Status",
        "category": "Success",
        "description": "El código 207 Multi-Status es utilizado principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para transmitir información sobre múltiples recursos cuando la operación sobre varios recursos puede tener resultados variados. A diferencia de otros códigos de estado que aplican a toda la respuesta, 207 indica que el cuerpo del mensaje contiene un documento XML con múltiples códigos de estado de respuesta, uno para cada recurso o sub-operación involucrada. Esto es esencial cuando se realizan operaciones sobre colecciones de recursos donde algunos pueden tener éxito y otros fallar. Por ejemplo, al intentar eliminar una carpeta con 10 archivos, 5 podrían eliminarse exitosamente (200), 3 podrían estar bloqueados (423), y 2 podrían no existir (404). El código 207 permite comunicar todos estos estados diferentes en una sola respuesta estructurada. El cuerpo de la respuesta típicamente contiene XML con elementos <response> para cada recurso, cada uno con su propio <status> y potencialmente <propstat> para propiedades. Esto hace que las operaciones batch sean más eficientes y permite al cliente manejar éxitos y fallos parciales de manera granular sin necesidad de múltiples requests individuales.",
        "useCases": [
            "Operaciones WebDAV sobre múltiples archivos o carpetas (PROPFIND, COPY, MOVE, DELETE)",
            "Operaciones batch en APIs que procesan múltiples recursos",
            "Sincronización de colecciones de recursos donde algunos pueden fallar",
            "Consultas de propiedades sobre múltiples recursos simultáneamente",
            "Operaciones de backup o restauración de múltiples archivos"
        ],
        "examples": [
            {
                "scenario": "PROPFIND sobre una colección de archivos",
                "request": "PROPFIND /documents/ HTTP/1.1\nHost: webdav.example.com\nDepth: 1\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <getcontentlength/>\n    <getlastmodified/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 1234\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/documents/file1.pdf</href>\n    <propstat>\n      <prop>\n        <getcontentlength>4500</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 12:00:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/file2.docx</href>\n    <propstat>\n      <prop>\n        <getcontentlength>15000</getcontentlength>\n        <getlastmodified>Tue, 16 Jan 2024 09:30:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/protected.txt</href>\n    <propstat>\n      <status>HTTP/1.1 403 Forbidden</status>\n    </propstat>\n  </response>\n</multistatus>",
                "explanation": "El servidor devuelve propiedades de múltiples archivos, algunos exitosos (200) y uno con acceso denegado (403)"
            },
            {
                "scenario": "Operación COPY batch sobre múltiples recursos",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup-folder/\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/source-folder/document1.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/document2.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/locked-file.dat</href>\n    <status>HTTP/1.1 423 Locked</status>\n  </response>\n</multistatus>",
                "explanation": "Algunos archivos se copiaron exitosamente mientras uno estaba bloqueado"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613656/8_gh0rl4.png",
                "alt": "Imagen que representa el nombre del código 207 Multi-Status"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619766/12-removebg-preview_xsybjn.png",
                "alt": "Imagen del código 207 Multi-Status"
            }
        ]
    },
    {
        "code": 208,
        "status": "Already Reported",
        "category": "Success",
        "description": "El código 208 Already Reported es utilizado exclusivamente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para evitar la enumeración repetida de recursos internos en respuestas Multi-Status. Este código representa una optimización crítica cuando se trabaja con bindings WebDAV, que son esencialmente referencias o enlaces a recursos que pueden aparecer en múltiples ubicaciones dentro de una jerarquía de carpetas. Cuando un cliente realiza una operación PROPFIND con profundidad infinita sobre una colección que contiene múltiples bindings (enlaces, referencias, o aliases) apuntando al mismo recurso subyacente, sin el código 208 la respuesta incluiría información completa del mismo recurso múltiples veces, una por cada binding. Esto no solo infla innecesariamente el tamaño de la respuesta XML sino que también consume recursos de procesamiento tanto en el servidor como en el cliente. El código 208 permite al servidor reportar el recurso completo la primera vez que lo encuentra durante el traversal de la jerarquía, y luego usar 208 Already Reported para las referencias subsecuentes al mismo recurso. Esto es análogo a cómo los lenguajes de programación manejan referencias circulares en estructuras de datos - la primera vez que encuentras un objeto lo procesas completamente, las siguientes veces solo indicas 'ya vimos esto'. En sistemas de archivos modernos con soporte para hard links, enlaces simbólicos, o sistemas distribuidos donde el mismo archivo puede ser accesible desde múltiples rutas virtuales, este código es esencial para mantener las respuestas manejables. La implementación correcta de 208 requiere que el servidor mantenga un registro de qué recursos ya ha incluido en la respuesta actual para evitar duplicación. Es importante notar que este código solo tiene sentido en el contexto de una respuesta 207 Multi-Status y específicamente en operaciones WebDAV que pueden atravesar colecciones con múltiples referencias.",
        "useCases": [
            "Operaciones PROPFIND recursivas sobre colecciones con bindings WebDAV duplicados",
            "Prevención de duplicación en listados de recursos en sistemas con hard links",
            "Optimización de respuestas en traversal de jerarquías con enlaces simbólicos",
            "Reducción del tamaño de respuestas XML en operaciones sobre estructuras complejas de carpetas",
            "Sistemas de archivos distribuidos donde el mismo recurso tiene múltiples rutas de acceso",
            "Implementaciones de versionado donde múltiples versiones pueden compartir contenido subyacente"
        ],
        "examples": [
            {
                "scenario": "PROPFIND recursivo con bindings duplicados",
                "request": "PROPFIND /workspace/projects/ HTTP/1.1\nHost: webdav.example.com\nDepth: infinity\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <displayname/>\n    <getcontentlength/>\n    <getcontenttype/>\n    <resourcetype/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/workspace/projects/shared-library/utils.js</href>\n    <propstat>\n      <prop>\n        <displayname>utils.js</displayname>\n        <getcontentlength>45000</getcontentlength>\n        <getcontenttype>application/javascript</getcontenttype>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/workspace/projects/project-a/lib/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-b/dependencies/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-c/shared/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El archivo utils.js es compartido por múltiples proyectos mediante bindings. Se reporta completamente solo la primera vez, las subsecuentes referencias usan 208 para evitar duplicación innecesaria de datos."
            },
            {
                "scenario": "Traversal de sistema con hard links",
                "request": "PROPFIND /storage/backups/ HTTP/1.1\nHost: dav.example.com\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/storage/backups/2024-01/database.dump</href>\n    <propstat>\n      <prop>\n        <displayname>database.dump</displayname>\n        <getcontentlength>524288000</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 02:00:00 GMT</getlastmodified>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/storage/backups/2024-02/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/storage/backups/latest/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El mismo archivo de backup está vinculado en múltiples directorios mediante hard links para deduplicación. Solo se reporta una vez con sus propiedades completas."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 5842, Section 7.1",
        "relatedCodes": [
            207
        ],
        "technicalNotes": "Este código solo es válido dentro del contexto de una respuesta 207 Multi-Status. El servidor debe implementar lógica para rastrear qué recursos ya han sido reportados durante el traversal de la jerarquía actual. No debe usarse fuera del contexto WebDAV.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613636/9_vly4qs.png",
                "alt": "Imagen que representa el nombre del código 208 Already Reported"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619797/13-removebg-preview_snc3fy.png",
                "alt": "Imagen del código 208 Already Reported"
            }
        ]
    },
    {
        "code": 214,
        "status": "Transformation Applied",
        "category": "Success (Warning Code)",
        "description": "El código 214 Transformation Applied es un código de advertencia HTTP que se transmite a través del encabezado Warning, no como código de estado HTTP principal. Los códigos de advertencia proporcionan información adicional sobre el estado de la respuesta que puede no ser evidente solo con el código de estado. El 214 específicamente informa al cliente que un intermediario (proxy, gateway, CDN) ha aplicado alguna transformación al contenido del mensaje antes de entregarlo. Estas transformaciones pueden ser dramáticas o sutiles: desde conversión de formatos de imagen (JPEG a WebP), transcodificación de video para diferentes dispositivos, compresión agresiva, minificación de código, aplicación de filtros de contenido, hasta modificación de resoluciones o tasas de bits. A diferencia del código de estado 203 Non-Authoritative Information que indica modificación de metadatos (encabezados), el código 214 se enfoca específicamente en transformaciones del cuerpo del mensaje. El formato del encabezado Warning es: 'Warning: 214 agent \"Transformation Applied\" \"descripción detallada\"' donde 'agent' identifica el intermediario que aplicó la transformación y la descripción explica qué se modificó. Esto es crucial para transparencia, debugging, y cumplimiento de políticas de contenido. Por ejemplo, un desarrollador depurando por qué una imagen se ve diferente en producción vs desarrollo puede ver el warning 214 y entender que un CDN está optimizando las imágenes. O un sistema de validación de contenido puede verificar que las transformaciones aplicadas cumplen con políticas corporativas. Los proxies modernos de optimización web, CDNs con procesamiento inteligente de assets, y gateways de adaptación de contenido para diferentes tipos de red (3G, 4G, 5G, WiFi) utilizan extensivamente este mecanismo. Es especialmente importante en contextos móviles donde los operadores de red pueden aplicar optimizaciones agresivas para reducir consumo de datos.",
        "useCases": [
            "Proxies de optimización que comprimen imágenes para reducir ancho de banda en redes lentas",
            "CDNs que convierten formatos de imagen a WebP o AVIF para navegadores compatibles",
            "Transcodificación automática de video según capacidades del dispositivo cliente",
            "Minificación y bundling de archivos JavaScript/CSS por intermediarios",
            "Aplicación de filtros de contenido corporativos o gubernamentales",
            "Adaptación de resolución de imágenes según tipo de conexión (WiFi vs móvil)",
            "Compresión adicional aplicada por operadores móviles en redes congestionadas",
            "Conversión de documentos a formatos más ligeros (por ejemplo, reducir calidad de PDFs)"
        ],
        "examples": [
            {
                "scenario": "CDN optimizando imagen para móvil",
                "request": "GET /assets/hero-image.jpg HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0...)\nAccept: image/webp,image/jpeg,*/*",
                "response": "HTTP/1.1 200 OK\nContent-Type: image/webp\nContent-Length: 28000\nWarning: 214 cdn.example.com \"Transformation Applied\" \"Original JPEG (150KB) converted to WebP format and compressed to 28KB for mobile optimization\"\nVary: Accept, User-Agent\nX-Original-Format: image/jpeg\nX-Original-Size: 153600\nVia: 1.1 cdn.example.com\n\n[WebP image data]",
                "explanation": "El CDN detectó un iPhone con soporte para WebP, convirtió la imagen original JPEG, aplicó compresión agresiva, y notificó la transformación mediante Warning 214."
            },
            {
                "scenario": "Proxy de operador móvil comprimiendo contenido",
                "request": "GET /download/whitepaper.pdf HTTP/1.1\nHost: docs.example.com\nVia: 1.1 mobile-proxy.carrier.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/pdf\nContent-Length: 450000\nWarning: 214 mobile-proxy.carrier.com \"Transformation Applied\" \"PDF images recompressed to reduce file size from 2.5MB to 450KB for data saving on mobile network\"\nX-Data-Saver-Applied: true\nX-Original-Size: 2621440\n\n[compressed PDF data]",
                "explanation": "El proxy del operador móvil aplicó compresión agresiva al PDF para ahorrar datos del plan del usuario."
            },
            {
                "scenario": "Transcodificación de video adaptativa",
                "request": "GET /videos/tutorial.mp4 HTTP/1.1\nHost: media.example.com\nUser-Agent: Mozilla/5.0 (Linux; Android 12...)",
                "response": "HTTP/1.1 200 OK\nContent-Type: video/mp4\nContent-Length: 15000000\nWarning: 214 video-gateway.example.com \"Transformation Applied\" \"Video transcoded from 1080p H.265 to 480p H.264 for Android device with limited bandwidth\"\nX-Original-Resolution: 1920x1080\nX-Original-Codec: hevc\nX-Transcoded-Resolution: 854x480\nX-Transcoded-Codec: h264\n\n[transcoded video data]",
                "explanation": "El gateway de video detectó un dispositivo Android en una conexión lenta y transcodificó el video a menor resolución y codec más compatible."
            },
            {
                "scenario": "Minificación de JavaScript por proxy corporativo",
                "request": "GET /js/app.js HTTP/1.1\nHost: cdn.example.com\nVia: 1.1 corporate-proxy.company.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/javascript\nContent-Length: 85000\nWarning: 214 corporate-proxy.company.com \"Transformation Applied\" \"JavaScript minified and comments removed, reduced from 245KB to 85KB\"\nX-Original-Size: 250880\nX-Minified: true\n\n[minified JavaScript code]",
                "explanation": "Un proxy corporativo minificó automáticamente el JavaScript para optimizar el ancho de banda de la red empresarial."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7234, Section 5.5",
        "headerFormat": "Warning: 214 agent \"Transformation Applied\" \"detailed description\"",
        "relatedHeaders": [
            "Via",
            "X-Original-Size",
            "X-Transformed-By",
            "Vary"
        ],
        "technicalNotes": "Este es un código de advertencia (Warning code), no un código de estado HTTP. Se transmite mediante el encabezado Warning. Múltiples advertencias pueden estar presentes en una sola respuesta. Los códigos de advertencia en el rango 2xx indican que no hubo error pero hay información adicional importante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613638/10_rezx3u.png",
                "alt": "Imagen que representa el nombre del código 214 Transformation Applied"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619790/14-removebg-preview_ypwtjm.png",
                "alt": "Imagen del código 214 Transformation Applied"
            }
        ]
    },
    {
        "code": 226,
        "status": "IM Used",
        "category": "Success",
        "description": "El código 226 IM Used (Instance Manipulation Used) indica que el servidor ha cumplido exitosamente con una solicitud GET para un recurso, pero en lugar de devolver la representación completa del recurso, está devolviendo el resultado de aplicar una o más manipulaciones de instancia (Instance Manipulations o IM) a la instancia actual del recurso. Este código es parte del framework de delta encoding especificado en RFC 3229, un mecanismo sofisticado diseñado para optimizar dramáticamente el uso de ancho de banda cuando los clientes solicitan recursos que han cambiado solo parcialmente desde una versión anterior que ya poseen. El concepto fundamental es simple pero poderoso: si tienes la versión 1 de un documento de 10MB y el servidor tiene la versión 2, en lugar de descargar los 10MB completos nuevamente, el servidor puede enviar solo un 'delta' (diferencia) de quizás 500KB que describe los cambios. El cliente entonces aplica este delta a su versión local para reconstruir la versión 2. El encabezado A-IM (Accept Instance Manipulation) en la solicitud especifica qué tipos de deltas o manipulaciones el cliente puede procesar (por ejemplo: vcdiff, gdiff, diffe, gzip). El servidor responde con 226 y el encabezado IM indica qué manipulación fue aplicada, mientras que Delta-Base identifica la versión base usada para calcular el delta. Este mecanismo es especialmente valioso para documentos grandes que evolucionan incrementalmente: bases de datos, archivos de configuración extensos, imágenes satelitales con actualizaciones periódicas, datasets científicos, o código fuente versionado. Aunque técnicamente poderoso, 226 es raramente implementado en la web moderna porque requiere soporte sofisticado tanto del cliente como del servidor, incluyendo algoritmos de diff/patch, gestión de versiones, y lógica de fallback. Muchos desarrolladores prefieren soluciones más simples como versionado de recursos con ETags para cacheo, o dividir recursos grandes en chunks más pequeños.",
        "useCases": [
            "Sincronización eficiente de archivos grandes con cambios incrementales (bases de datos, logs)",
            "Actualización de datasets científicos o geoespaciales que cambian parcialmente",
            "Distribución de actualizaciones de software mediante deltas en lugar de instaladores completos",
            "APIs que sirven documentos versionados donde el cliente probablemente tiene versiones anteriores",
            "Sistemas de colaboración en documentos grandes con control de versiones",
            "Optimización de ancho de banda en enlaces satelitales o conexiones lentas costosas",
            "Sincronización de repositorios de código fuente sobre HTTP (similar a Git pero vía HTTP puro)"
        ],
        "examples": [
            {
                "scenario": "Delta encoding con formato vcdiff",
                "request": "GET /datasets/weather-data.csv HTTP/1.1\nHost: data.example.com\nA-IM: vcdiff, diffe\nIf-None-Match: \"v2024-01-15-abc123\"\nAccept-Encoding: gzip",
                "response": "HTTP/1.1 226 IM Used\nETag: \"v2024-01-16-def456\"\nIM: vcdiff\nDelta-Base: \"v2024-01-15-abc123\"\nContent-Type: application/x-vcdiff\nContent-Encoding: gzip\nContent-Length: 125000\nCache-Control: private, must-revalidate\n\n[gzipped vcdiff delta data]",
                "explanation": "El cliente tiene los datos meteorológicos del 15 de enero. El servidor envía solo los cambios del 16 de enero usando formato vcdiff comprimido con gzip, reduciendo la transferencia de 50MB completos a solo 125KB de delta."
            },
            {
                "scenario": "Actualización incremental de documento JSON grande",
                "request": "GET /api/products-catalog.json HTTP/1.1\nHost: api.example.com\nA-IM: json-patch, json-merge-patch\nIf-None-Match: \"catalog-v105\"",
                "response": "HTTP/1.1 226 IM Used\nETag: \"catalog-v106\"\nIM: json-patch\nDelta-Base: \"catalog-v105\"\nContent-Type: application/json-patch+json\nContent-Length: 3500\n\n[\n  {\"op\": \"replace\", \"path\": \"/products/42/price\", \"value\": 29.99},\n  {\"op\": \"replace\", \"path\": \"/products/42/stock\", \"value\": 150},\n  {\"op\": \"add\", \"path\": \"/products/999\", \"value\": {\n    \"id\": 999,\n    \"name\": \"New Product\",\n    \"price\": 49.99,\n    \"stock\": 50\n  }},\n  {\"op\": \"remove\", \"path\": \"/products/123\"}\n]",
                "explanation": "En lugar de enviar todo el catálogo de productos (5MB), el servidor envía un JSON Patch (3.5KB) con solo los cambios: actualizaciones de precio/stock de un producto, adición de un producto nuevo, y eliminación de un producto descontinuado."
            },
            {
                "scenario": "Sincronización de base de datos SQLite",
                "request": "GET /db/application.db HTTP/1.1\nHost: sync.example.com\nA-IM: gdiff\nIf-None-Match: \"db-snapshot-20240115-120000\"\nRange: bytes=0-",
                "response": "HTTP/1.1 226 IM Used\nETag: \"db-snapshot-20240116-140000\"\nIM: gdiff\nDelta-Base: \"db-snapshot-20240115-120000\"\nContent-Type: application/x-gdiff\nContent-Length: 450000\n\n[gdiff binary delta data]",
                "explanation": "El cliente sincroniza una base de datos SQLite de 250MB. Solo han cambiado algunas tablas (nuevas filas, actualizaciones). El servidor calcula un delta binario de 450KB usando gdiff, evitando transferir los 250MB completos."
            },
            {
                "scenario": "Fallback cuando delta no es posible",
                "request": "GET /documents/report.pdf HTTP/1.1\nHost: docs.example.com\nA-IM: vcdiff\nIf-None-Match: \"report-v1\"",
                "response": "HTTP/1.1 200 OK\nETag: \"report-v5\"\nContent-Type: application/pdf\nContent-Length: 2500000\nVary: A-IM, If-None-Match\n\n[complete PDF file]",
                "explanation": "El cliente tiene la versión 1 pero la versión actual es 5. Los cambios son tan extensos que el delta sería casi tan grande como el archivo completo, o el servidor no tiene la versión intermedia. Se envía el archivo completo con código 200 en lugar de 226."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 3229, Section 10.4.1",
        "relatedHeaders": [
            "A-IM (Accept-Instance-Manipulation)",
            "IM (Instance-Manipulation)",
            "Delta-Base",
            "If-None-Match",
            "ETag"
        ],
        "deltaFormats": {
            "vcdiff": "Binary delta encoding format (RFC 3284), muy eficiente para archivos binarios",
            "gdiff": "Generic diff format, usado para diferencias binarias",
            "diffe": "Ed-style diff, basado en comandos de edición",
            "json-patch": "RFC 6902, para documentos JSON estructurados",
            "json-merge-patch": "RFC 7396, merge patches para JSON"
        },
        "technicalNotes": "El servidor debe almacenar versiones anteriores o calcular deltas on-the-fly. La implementación requiere algoritmos sofisticados de diff/patch. Si calcular el delta es más costoso que enviar el recurso completo, el servidor debe usar 200 OK. Los clientes deben implementar lógica de fallback para cuando 200 se recibe en lugar de 226.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613648/11_ozqx4y.png",
                "alt": "Imagen que representa el nombre del código 226 IM Used"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619794/15-removebg-preview_yxl4gy.png",
                "alt": "Imagen del código 226 IM Used"
            }
        ]
    },
    {
        "code": 300,
        "status": "Multiple Choices",
        "category": "Redirection",
        "description": "El código 300 Multiple Choices indica que el recurso solicitado corresponde a múltiples representaciones diferentes, cada una con su propia ubicación específica, y se está proporcionando información para que el agente de usuario (o el usuario final) pueda seleccionar una representación preferida y redirigir su solicitud a esa ubicación. Este código representa una situación de negociación de contenido donde el servidor no puede o no quiere tomar automáticamente la decisión sobre cuál variante servir. Es fundamentalmente diferente de otros códigos de redirección porque no impone una única redirección, sino que ofrece opciones. La respuesta debe incluir una lista de las alternativas disponibles junto con sus ubicaciones y características distintivas, permitiendo que el cliente (o usuario) haga una elección informada. Por ejemplo, un documento podría estar disponible en múltiples formatos (PDF, HTML, DOCX), idiomas (inglés, español, francés), o versiones (para principiantes, intermedio, avanzado). El servidor podría responder con 300 y proporcionar enlaces a todas estas variantes. El cuerpo de la respuesta típicamente contiene un documento HTML con enlaces a las diferentes opciones, o puede usar el encabezado Location para sugerir una opción preferida mientras lista otras alternativas en el cuerpo. En la práctica moderna, 300 es raramente utilizado porque los servidores generalmente implementan negociación de contenido automática basada en encabezados Accept, Accept-Language, Accept-Encoding del cliente, eligiendo la mejor representación y devolviéndola directamente con código 200 OK, o usando redirecciones 302/303 para dirigir automáticamente a una variante específica. Sin embargo, 300 sigue siendo útil en escenarios donde la elección tiene implicaciones significativas que no pueden ser determinadas automáticamente, como diferentes niveles de detalle de documentación, versiones con diferentes licencias, o formatos que requieren diferentes aplicaciones.",
        "useCases": [
            "Documentos disponibles en múltiples formatos que requieren elección explícita del usuario",
            "Contenido multilingüe donde el servidor no puede determinar automáticamente el idioma preferido",
            "Diferentes versiones de un recurso (simplificada, completa, técnica) donde la elección depende del contexto",
            "Recursos con múltiples licencias donde el usuario debe seleccionar términos específicos",
            "APIs que ofrecen múltiples endpoints para la misma funcionalidad con diferentes características",
            "Contenido disponible en diferentes niveles de calidad o resolución",
            "Archivos disponibles desde múltiples servidores mirror donde el usuario debe elegir el más cercano"
        ],
        "examples": [
            {
                "scenario": "Documento en múltiples formatos",
                "request": "GET /documentation/user-guide HTTP/1.1\nHost: docs.example.com\nAccept: */*",
                "response": "HTTP/1.1 300 Multiple Choices\nLocation: /documentation/user-guide.html\nContent-Type: text/html; charset=utf-8\nVary: Accept\n\n<!DOCTYPE html>\n<html>\n<head><title>Multiple Formats Available</title></head>\n<body>\n  <h1>User Guide - Multiple Formats</h1>\n  <p>This documentation is available in several formats:</p>\n  <ul>\n    <li><a href=\"/documentation/user-guide.html\">HTML Version</a></li>\n    <li><a href=\"/documentation/user-guide.pdf\">PDF Version</a></li>\n    <li><a href=\"/documentation/user-guide.epub\">EPUB Version</a></li>\n    <li><a href=\"/documentation/user-guide.docx\">DOCX Version</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El servidor ofrece el mismo contenido en cuatro formatos diferentes. El encabezado Location sugiere HTML como opción predeterminada, pero el usuario puede elegir cualquier formato según sus necesidades."
            },
            {
                "scenario": "Contenido multilingüe sin preferencia clara",
                "request": "GET /welcome HTTP/1.1\nHost: www.example.com\nAccept-Language: *",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: text/html; charset=utf-8\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head><title>Language Selection</title></head>\n<body>\n  <h1>Please select your language</h1>\n  <ul>\n    <li><a href=\"/welcome?lang=en\" hreflang=\"en\">English</a></li>\n    <li><a href=\"/welcome?lang=es\" hreflang=\"es\">Español</a></li>\n    <li><a href=\"/welcome?lang=fr\" hreflang=\"fr\">Français</a></li>\n    <li><a href=\"/welcome?lang=de\" hreflang=\"de\">Deutsch</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El cliente no especificó una preferencia clara de idioma, por lo que el servidor presenta todas las opciones de idioma disponibles para que el usuario elija."
            },
            {
                "scenario": "API con múltiples versiones",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: application/json\nLocation: /api/v3/data\n\n{\n  \"message\": \"Multiple API versions available\",\n  \"versions\": [\n    {\n      \"version\": \"v1\",\n      \"url\": \"/api/v1/data\",\n      \"status\": \"deprecated\"\n    },\n    {\n      \"version\": \"v2\",\n      \"url\": \"/api/v2/data\",\n      \"status\": \"stable\"\n    },\n    {\n      \"version\": \"v3\",\n      \"url\": \"/api/v3/data\",\n      \"status\": \"recommended\"\n    }\n  ]\n}",
                "explanation": "El endpoint base de la API devuelve información sobre todas las versiones disponibles, permitiendo que el cliente elija según sus necesidades de estabilidad versus características nuevas."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.1",
        "relatedHeaders": [
            "Location",
            "Vary",
            "Content-Type",
            "Link"
        ],
        "technicalNotes": "Aunque especificado en HTTP/1.0, es raramente usado en la práctica moderna. La mayoría de los servidores implementan content negotiation automática usando encabezados Accept-* y devuelven 200 OK con la mejor representación, o usan 302/303 para redirigir automáticamente.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/300_gepcv9.png",
                "alt": "Imagen que representa el nombre del código 300 Multiple Choices"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/16-removebg-preview_pobkgs.png",
                "alt": "Imagen del código 300 Multiple Choices"
            }
        ]
    },
    {
        "code": 301,
        "status": "Moved Permanently",
        "category": "Redirection",
        "description": "El código 301 Moved Permanently indica que el recurso solicitado ha sido movido permanentemente a una nueva ubicación URI, y todas las referencias futuras a este recurso deben usar una de las URIs devueltas. Este es uno de los códigos de redirección más importantes y ampliamente utilizados en HTTP, fundamental para SEO, mantenimiento de sitios web, y reorganización de estructuras de URLs. La palabra clave aquí es 'permanentemente' - este código comunica tanto a navegadores como a motores de búsqueda que el cambio es definitivo y no temporal. Los motores de búsqueda como Google, cuando encuentran un 301, transferirán el 'link juice' (valor SEO) del URL antiguo al nuevo, actualizarán sus índices, y eventualmente dejarán de rastrear el URL antiguo. Los navegadores típicamente almacenan en caché redirecciones 301, lo que significa que en visitas futuras pueden ir directamente al nuevo URL sin siquiera consultar el servidor sobre el URL antiguo. La respuesta debe incluir un encabezado Location con la nueva URI del recurso. Es crucial usar 301 correctamente: solo debe usarse cuando estás absolutamente seguro de que el movimiento es permanente. Si hay alguna posibilidad de que el recurso regrese al URL original en el futuro, usa 302 o 307 en su lugar. Las aplicaciones comunes incluyen: migración de HTTP a HTTPS, cambio de nombres de dominio, reestructuración de sitios web, consolidación de contenido duplicado, normalización de URLs (con/sin www, con/sin trailing slash), y redirección de páginas antiguas a nuevas versiones. Un uso inadecuado de 301 puede causar problemas graves: si rediriges permanentemente y luego intentas restaurar el URL original, los navegadores con caché pueden seguir redirigiendo automáticamente incluso después de que hayas eliminado la redirección del servidor.",
        "useCases": [
            "Migración permanente de HTTP a HTTPS para todo un sitio web",
            "Cambio de nombre de dominio (example.com a newbrand.com)",
            "Reestructuración de URLs (/old-page.html a /new-structure/page)",
            "Consolidación de contenido duplicado hacia una URL canónica",
            "Normalización de URLs (www.example.com a example.com o viceversa)",
            "Redirección de trailing slash (/page a /page/ o viceversa)",
            "Movimiento permanente de recursos a CDN o subdominios",
            "Redirección de páginas de productos discontinuados a categorías o alternativas",
            "Migración de plataformas (WordPress a Jamstack, cambio de CMS)",
            "Internacionalización (example.com/page a example.com/en/page)"
        ],
        "examples": [
            {
                "scenario": "Migración HTTP a HTTPS",
                "request": "GET /secure-page HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/secure-page\nContent-Type: text/html; charset=UTF-8\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"https://example.com/secure-page\">here</a>.</p>\n</body>\n</html>",
                "explanation": "El sitio ha migrado permanentemente a HTTPS. Todas las solicitudes HTTP son redirigidas a sus equivalentes HTTPS. Los motores de búsqueda actualizarán sus índices para usar HTTPS."
            },
            {
                "scenario": "Cambio de nombre de dominio",
                "request": "GET /products/widget-x HTTP/1.1\nHost: oldcompany.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://newcompany.com/products/widget-x\nCache-Control: max-age=31536000, immutable",
                "explanation": "La empresa cambió de nombre y dominio. Redirección permanente con caché de 1 año para maximizar eficiencia. Los motores de búsqueda transferirán el valor SEO al nuevo dominio."
            },
            {
                "scenario": "Reestructuración de URLs SEO-friendly",
                "request": "GET /page.php?id=123&category=electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://shop.example.com/electronics/products/smartphone-pro-123\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Moved</title>\n  <link rel=\"canonical\" href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">\n</head>\n<body>\n  <h1>This page has moved permanently</h1>\n  <p>New URL: <a href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">Smartphone Pro</a></p>\n</body>\n</html>",
                "explanation": "URLs antiguas con parámetros query son redirigidas permanentemente a URLs amigables para SEO. Incluye canonical tag para reforzar la URL correcta."
            },
            {
                "scenario": "Normalización www vs non-www",
                "request": "GET / HTTP/1.1\nHost: www.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/\nStrict-Transport-Security: max-age=31536000; includeSubDomains",
                "explanation": "Normalización permanente hacia versión sin www. Incluye HSTS para forzar HTTPS en futuras visitas y mejorar la seguridad."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.2",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Vary",
            "Link",
            "Deprecation",
            "Sunset"
        ],
        "technicalNotes": "En HTTP/1.0, la especificación permitía que navegadores cambiaran el método de POST a GET al seguir un 301. HTTP/1.1 clarificó que el método debe preservarse, pero muchos navegadores aún cambian POST a GET por compatibilidad histórica. Para comportamiento predecible con POST requests, usa 308 en su lugar. Los navegadores cachean 301 agresivamente incluso sin Cache-Control explícito.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/301_wdshbj.png",
                "alt": "Imagen que representa el nombre del código 301 Moved Permanently"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/17-removebg-preview_uthv3h.png",
                "alt": "Imagen del código 301 Moved Permanently"
            }
        ]
    },
    {
        "code": 302,
        "status": "Found",
        "category": "Redirection",
        "description": "El código 302 Found (originalmente 'Moved Temporarily' en HTTP/1.0) indica que el recurso solicitado reside temporalmente bajo una URI diferente. A diferencia de 301 que señala un cambio permanente, 302 comunica que el recurso puede volver a su ubicación original en el futuro, o que su ubicación temporal puede cambiar. Esta distinción es crucial tanto para navegadores como para motores de búsqueda. Los navegadores generalmente NO cachean redirecciones 302 de forma agresiva, lo que significa que seguirán consultando el URL original en futuras visitas. Los motores de búsqueda mantienen el URL original en sus índices y continúan rastreándolo, no transfieren el 'link juice' al URL de destino. El encabezado Location especifica la URI temporal donde el recurso puede encontrarse actualmente. El código 302 es históricamente ambiguo en cuanto al manejo del método HTTP: aunque la especificación HTTP/1.1 dice que el método de solicitud no debe cambiar al seguir la redirección, en la práctica la mayoría de los navegadores cambian POST a GET cuando siguen un 302. Esta inconsistencia llevó a la creación de códigos más específicos: 303 See Other (explícitamente cambia a GET) y 307 Temporary Redirect (explícitamente preserva el método). Sin embargo, 302 sigue siendo extremadamente común en la web moderna y es el código de redirección temporal por defecto en muchos frameworks y servidores web. Los casos de uso típicos incluyen: redirecciones post-login, redirecciones después de operaciones POST (pattern Post-Redirect-Get), mantenimiento temporal de sitios, A/B testing, distribución de carga entre servidores, redirecciones basadas en geolocalización, y páginas temporales de campaña de marketing.",
        "useCases": [
            "Redirección post-login a dashboard o página de perfil",
            "Patrón Post-Redirect-Get (PRG) para prevenir reenvíos de formularios",
            "Mantenimiento temporal del sitio (redirigir a página de mantenimiento)",
            "A/B testing y experimentos de usuario",
            "Redirecciones basadas en geolocalización o detección de idioma",
            "Páginas temporales de campaña de marketing o eventos",
            "Distribución temporal de carga entre servidores espejo",
            "Redirecciones condicionales basadas en cookies, sesión, o headers",
            "URLs cortas temporales para campañas (bit.ly, tinyurl)",
            "Redirección durante migraciones graduales (canary deployments)"
        ],
        "examples": [
            {
                "scenario": "Redirección post-login",
                "request": "POST /login HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=john&password=secret123",
                "response": "HTTP/1.1 302 Found\nLocation: https://example.com/dashboard\nSet-Cookie: session_id=abc123xyz; HttpOnly; Secure; SameSite=Lax\nCache-Control: no-store, no-cache, must-revalidate",
                "explanation": "Después de autenticación exitosa, el usuario es redirigido temporalmente a su dashboard. Se establece una cookie de sesión y se previene el cacheo de la redirección."
            },
            {
                "scenario": "Patrón Post-Redirect-Get (PRG)",
                "request": "POST /orders/create HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"product_id\": 456,\n  \"quantity\": 2\n}",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/orders/confirmation/789\nX-Order-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"order_id\": 789\n}",
                "explanation": "Después de crear la orden (POST), el servidor redirige a una página de confirmación (GET). Esto previene que el usuario reenvíe la orden accidentalmente al refrescar la página."
            },
            {
                "scenario": "Página de mantenimiento temporal",
                "request": "GET /products/electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/maintenance\nRetry-After: 3600\nCache-Control: no-cache, no-store\n\n<!DOCTYPE html>\n<html>\n<head><title>Temporary Maintenance</title></head>\n<body>\n  <h1>Scheduled Maintenance</h1>\n  <p>We're performing system upgrades. Please check back in 1 hour.</p>\n</body>\n</html>",
                "explanation": "Durante mantenimiento, las páginas redirigen temporalmente a una página de mantenimiento. Retry-After sugiere cuándo reintentar. La redirección es temporal porque las páginas normales volverán después del mantenimiento."
            },
            {
                "scenario": "Redirección basada en geolocalización",
                "request": "GET / HTTP/1.1\nHost: www.globalshop.com\nAccept-Language: es-MX\nX-Forwarded-For: 189.203.10.5",
                "response": "HTTP/1.1 302 Found\nLocation: https://www.globalshop.com/mx/\nVary: Accept-Language, X-Forwarded-For\nSet-Cookie: geo_region=mx; Path=/; Max-Age=86400\nCache-Control: private, no-cache",
                "explanation": "El servidor detecta que el usuario está en México y redirige temporalmente a la versión mexicana del sitio. La redirección es temporal porque el usuario podría estar viajando o usando VPN."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.3",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "Set-Cookie"
        ],
        "technicalNotes": "302 es históricamente ambiguo: la especificación dice preservar el método, pero la mayoría de los navegadores cambian POST a GET. Para comportamiento explícito: usa 303 (fuerza GET) o 307 (preserva método). Las redirecciones 302 generalmente NO se cachean agresivamente. Los motores de búsqueda mantienen el URL original en índices y no transfieren SEO value.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701320/302_pr9ato.png",
                "alt": "Imagen que representa el nombre del código 302 Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/18-removebg-preview_qckrk0.png",
                "alt": "Imagen del código 302 Found"
            }
        ]
    },
    {
        "code": 303,
        "status": "See Other",
        "category": "Redirection",
        "description": "El código 303 See Other indica que el servidor está redirigiendo al cliente a un recurso diferente, identificado por el URI en el encabezado Location, y que la respuesta a la solicitud original puede ser encontrada allí usando una solicitud GET. La característica distintiva y crucial de 303 es que SIEMPRE requiere que el cliente use el método GET para la solicitud redirigida, sin importar qué método HTTP se usó en la solicitud original. Esto lo hace perfectamente adecuado para el patrón Post-Redirect-Get (PRG), una de las mejores prácticas más importantes en desarrollo web. El código 303 fue introducido en HTTP/1.1 específicamente para eliminar la ambigüedad del código 302, que teóricamente debería preservar el método pero en la práctica los navegadores lo cambian a GET. Con 303, este comportamiento está explícitamente codificado en la especificación: si un servidor responde con 303 a una solicitud POST, el navegador DEBE hacer una solicitud GET al URL en el encabezado Location. Esto resuelve el problema clásico de 'duplicación de envíos de formularios' donde un usuario envía un formulario (POST), ve la página de confirmación, y luego al refrescar el navegador, se le pregunta si quiere reenviar el formulario. Con 303, el flujo es: (1) usuario envía formulario con POST, (2) servidor procesa y responde 303 con Location a página de confirmación, (3) navegador hace GET a esa página de confirmación, (4) usuario ve confirmación y puede refrescar sin problemas porque ahora es un GET simple. El código 303 es semánticamente diferente de 302 y 307: mientras que 302 es ambiguo y 307 preserva explícitamente el método, 303 explícitamente cambia a GET. Es la elección correcta para cualquier situación donde procesas una operación de modificación de estado (POST, PUT, DELETE) y quieres redirigir al usuario a una representación del resultado.",
        "useCases": [
            "Implementación del patrón Post-Redirect-Get (PRG) después de envíos de formularios",
            "Redirección después de operaciones POST, PUT, DELETE en APIs REST",
            "Confirmaciones de operaciones que modifican estado (creación, actualización, eliminación)",
            "Redirección después de procesamiento de pagos o transacciones",
            "Redirigir desde endpoint de acción a vista de recurso",
            "Prevenir reenvíos accidentales de formularios al refrescar navegador",
            "Redirección de operaciones asíncronas completadas a página de resultados",
            "Upload de archivos seguido de redirección a página de vista previa"
        ],
        "examples": [
            {
                "scenario": "Patrón Post-Redirect-Get clásico",
                "request": "POST /contact HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&email=john%40example.com&message=Hello",
                "response": "HTTP/1.1 303 See Other\nLocation: https://example.com/contact/thank-you\nCache-Control: no-cache, no-store, must-revalidate\nX-Message-ID: msg_123456\n\n<!DOCTYPE html>\n<html>\n<head><title>Message Sent</title></head>\n<body>\n  <p>Your message has been sent successfully.</p>\n  <p>Redirecting to confirmation page...</p>\n</body>\n</html>",
                "explanation": "Después de procesar el formulario de contacto (POST), el servidor redirige con 303 a una página de agradecimiento. El navegador hará GET a /contact/thank-you. Si el usuario refresca, solo re-hace el GET, no reenvía el formulario."
            },
            {
                "scenario": "Creación de recurso en API REST",
                "request": "POST /api/articles HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token_abc123\n\n{\n  \"title\": \"Understanding HTTP 303\",\n  \"content\": \"The 303 status code is...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://blog.example.com/api/articles/789\nX-Article-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"message\": \"Article published successfully\",\n  \"article_id\": 789,\n  \"view_url\": \"/api/articles/789\"\n}",
                "explanation": "El artículo fue creado exitosamente. En lugar de devolver 201 Created, el servidor usa 303 para indicar que el cliente debe hacer GET a /api/articles/789 para ver el recurso completo. Esto separa claramente la operación de creación (POST) de la recuperación (GET)."
            },
            {
                "scenario": "Procesamiento de pago con redirección",
                "request": "POST /checkout/process-payment HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_visa_1234\",\n  \"cart_id\": \"cart_xyz789\"\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://shop.example.com/orders/confirmation/ord_456\nX-Order-ID: ord_456\nX-Transaction-ID: txn_789xyz\nSet-Cookie: cart_id=; Max-Age=0; Path=/\nCache-Control: no-store, no-cache\n\n{\n  \"status\": \"payment_successful\",\n  \"order_id\": \"ord_456\",\n  \"confirmation_url\": \"/orders/confirmation/ord_456\"\n}",
                "explanation": "Después de procesar el pago exitosamente, el servidor redirige con 303 a la página de confirmación de orden. Esto previene que el usuario accidentalmente procese el pago dos veces si refresca la página."
            },
            {
                "scenario": "Eliminación de recurso con redirección a lista",
                "request": "DELETE /api/users/123 HTTP/1.1\nHost: admin.example.com\nAuthorization: Bearer admin_token_xyz\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 303 See Other\nLocation: https://admin.example.com/api/users\nX-Deleted-User-ID: 123\nCache-Control: no-cache\n\n{\n  \"status\": \"deleted\",\n  \"message\": \"User account deleted successfully\",\n  \"deleted_user_id\": 123,\n  \"redirect_to\": \"/api/users\"\n}",
                "explanation": "Después de eliminar el usuario (DELETE), el servidor redirige con 303 a la lista de usuarios. El cliente hará GET a /api/users para ver la lista actualizada sin el usuario eliminado."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.4",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "X-Request-ID",
            "X-Resource-ID"
        ],
        "technicalNotes": "303 fue introducido en HTTP/1.1 para resolver la ambigüedad de 302. El método SIEMPRE cambia a GET - esto no es un bug, es la característica principal. Los navegadores SIEMPRE cambian el método a GET cuando siguen una redirección 303, sin importar el método original (POST, PUT, DELETE). Si necesitas preservar el método, usa 307 en su lugar.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/303_b4nnly.png",
                "alt": "Imagen que representa el nombre del código 303 See Other"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685324/19-removebg-preview_akkhp7.png",
                "alt": "Imagen del código 303 See Other"
            }
        ]
    },
    {
        "code": 304,
        "status": "Not Modified",
        "category": "Redirection",
        "description": "El código 304 Not Modified es un código de estado especial que indica que el recurso no ha sido modificado desde la versión especificada por los encabezados de solicitud condicional del cliente (If-Modified-Since, If-None-Match), y por lo tanto el cliente puede usar su copia en caché. Este código es fundamental para la optimización del rendimiento web y el ahorro de ancho de banda. A diferencia de otros códigos de redirección, 304 no redirige a una ubicación diferente, sino que instruye al cliente a usar la copia que ya tiene almacenada localmente. El flujo típico funciona así: (1) cliente hace una solicitud inicial GET y recibe 200 OK con el recurso completo más encabezados ETag y/o Last-Modified, (2) cliente almacena el recurso en caché junto con estos validadores, (3) en solicitudes subsecuentes, cliente incluye If-None-Match (con el ETag) y/o If-Modified-Since (con la fecha), (4) servidor verifica si el recurso cambió comparando con los validadores, (5) si NO cambió, servidor responde 304 sin cuerpo de mensaje - solo headers, (6) cliente usa su versión cacheada. Esto ahorra ancho de banda significativo porque solo se transmiten headers (aproximadamente 200-500 bytes) en lugar del recurso completo (que podría ser megabytes). La respuesta 304 NUNCA debe contener un cuerpo de mensaje - el mensaje termina inmediatamente después de los encabezados. Debe incluir headers que habrían sido enviados con 200 OK si el recurso hubiera sido modificado, específicamente: Date, ETag, Cache-Control, Expires, Vary. El código 304 es esencial para: carga eficiente de sitios web con muchos assets estáticos, APIs que sirven datos que cambian infrecuentemente, distribución de contenido mediante CDNs, reducción de carga en servidores de origen, mejora de velocidad percibida por usuarios, y optimización de consumo de datos en dispositivos móviles.",
        "useCases": [
            "Validación de caché para assets estáticos (imágenes, CSS, JavaScript)",
            "APIs que sirven datos que cambian infrecuentemente",
            "Verificación de actualizaciones de recursos sin transferir todo el contenido",
            "Optimización de rendimiento en sitios web con muchos recursos",
            "Reducción de ancho de banda en aplicaciones móviles",
            "Implementación de polling eficiente para verificar cambios",
            "CDN edge caching y validación con servidores origen",
            "Sincronización eficiente de recursos entre cliente y servidor"
        ],
        "examples": [
            {
                "scenario": "Validación con ETag - recurso no modificado",
                "request": "GET /assets/logo.png HTTP/1.1\nHost: cdn.example.com\nIf-None-Match: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: max-age=0",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:00:00 GMT\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: public, max-age=31536000, immutable\nVary: Accept-Encoding\nX-Cache: HIT",
                "explanation": "El cliente tiene logo.png con ETag específico. El servidor verifica que el archivo no ha cambiado (mismo ETag) y responde 304. El navegador usa su copia cacheada. No se transmite la imagen, ahorrando ancho de banda significativo."
            },
            {
                "scenario": "Validación con Last-Modified - recurso no modificado",
                "request": "GET /api/products.json HTTP/1.1\nHost: api.example.com\nIf-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:05:00 GMT\nLast-Modified: Mon, 15 Jan 2024 10:00:00 GMT\nCache-Control: private, must-revalidate, max-age=3600\nVary: Accept",
                "explanation": "El cliente pregunta si products.json cambió desde el 15 de enero. No ha cambiado, entonces el servidor responde 304. Cliente usa su copia cacheada, ahorrando potencialmente varios MB de datos JSON."
            },
            {
                "scenario": "Validación con ETag - recurso SÍ modificado",
                "request": "GET /news/latest-article HTTP/1.1\nHost: blog.example.com\nIf-None-Match: \"old-etag-abc123\"\nAccept: text/html",
                "response": "HTTP/1.1 200 OK\nDate: Tue, 16 Jan 2024 19:10:00 GMT\nETag: \"new-etag-xyz789\"\nLast-Modified: Tue, 16 Jan 2024 18:00:00 GMT\nContent-Type: text/html; charset=utf-8\nCache-Control: public, max-age=600\n\n<!DOCTYPE html>\n<html>\n<head><title>Breaking News Updated!</title></head>\n<body>\n  <article>\n    <h1>Major Update to Story</h1>\n    <p>New information has emerged...</p>\n  </article>\n</body>\n</html>",
                "explanation": "El artículo fue actualizado (ETag diferente), entonces el servidor responde 200 OK con el contenido completo actualizado y nuevo ETag. El cliente reemplaza su caché con la nueva versión."
            },
            {
                "scenario": "API polling eficiente",
                "request": "GET /api/notifications HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nIf-None-Match: W/\"notifications-hash-abc\"\nX-Polling-Interval: 30",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:20:00 GMT\nETag: W/\"notifications-hash-abc\"\nCache-Control: private, no-cache, must-revalidate\nX-Poll-Interval: 30",
                "explanation": "Cliente hace polling cada 30 segundos para notificaciones. No hay nuevas notificaciones, entonces 304. Esto es muchísimo más eficiente que transferir la lista completa de notificaciones en cada poll."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7232, Section 4.1",
        "relatedHeaders": [
            "If-Modified-Since",
            "If-None-Match",
            "ETag",
            "Last-Modified",
            "Date",
            "Cache-Control",
            "Expires",
            "Vary"
        ],
        "technicalNotes": "La respuesta 304 NUNCA debe incluir un cuerpo de mensaje. DEBE incluir Date header. DEBE incluir ETag y/o Last-Modified si estaban en la respuesta 200 original. DEBE incluir Cache-Control y Expires si aplican. NO debe incluir Content-Length porque no hay cuerpo. Los navegadores automáticamente incluyen If-None-Match/If-Modified-Since cuando revalidan recursos cacheados.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/304_ot5mbk.png",
                "alt": "Imagen que representa el nombre del código 304 Not Modified"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/20-removebg-preview_mnc4wo.png",
                "alt": "Imagen del código 304 Not Modified"
            }
        ]
    },
    {
        "code": 305,
        "status": "Use Proxy",
        "category": "Redirection",
        "description": "El código 305 Use Proxy indica que el recurso solicitado debe ser accedido a través de un proxy especificado en el encabezado Location. Este código fue definido en versiones anteriores de la especificación HTTP pero ha sido DEPRECADO en HTTP/1.1 debido a serias preocupaciones de seguridad. El código 305 fue diseñado originalmente para permitir que los servidores indiquen a los clientes que deben acceder a un recurso específico a través de un proxy particular. Sin embargo, esta funcionalidad presentaba riesgos significativos de seguridad ya que permitía que servidores potencialmente maliciosos obligaran a los clientes a enrutar su tráfico a través de proxies no confiables, lo que podría resultar en ataques man-in-the-middle, interceptación de datos sensibles, modificación de contenido, o redirección a sitios maliciosos. Debido a estos riesgos, la mayoría de los navegadores modernos y clientes HTTP ignoran completamente el código 305 y nunca lo implementaron correctamente. El código fue formalmente deprecado y las implementaciones modernas NO deben usarlo ni responder a él. En lugar de 305, las configuraciones de proxy deben ser manejadas a nivel de sistema operativo, configuración de red, o mediante configuración explícita del usuario en la aplicación cliente (como las configuraciones de proxy en navegadores). La especificación HTTP/1.1 revisada recomienda explícitamente NO usar este código bajo ninguna circunstancia. Si un servidor necesita comunicar información sobre proxies, debe hacerlo a través de otros mecanismos más seguros como encabezados informativos personalizados, documentación fuera de banda, o configuración manual del cliente. El código 305 representa un ejemplo importante en la evolución de HTTP de cómo consideraciones de seguridad pueden llevar a la deprecación de características que parecían útiles pero resultaron ser vectores de ataque potenciales.",
        "useCases": [
            "NINGUNO - Este código está DEPRECADO y NO debe ser usado",
            "Históricamente fue diseñado para indicar uso de proxy, pero fue abandonado por riesgos de seguridad",
            "No tiene casos de uso válidos en implementaciones modernas"
        ],
        "examples": [
            {
                "scenario": "Ejemplo histórico (NO usar en producción)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 305 Use Proxy\nLocation: http://proxy.example.com:8080\n\n[Este código está DEPRECADO y no debe ser usado]",
                "explanation": "Este es solo un ejemplo histórico de cómo se habría usado 305. En la práctica moderna, este código NUNCA debe ser usado debido a graves riesgos de seguridad. Los navegadores modernos lo ignoran completamente."
            },
            {
                "scenario": "Respuesta moderna correcta (usar configuración de proxy apropiada)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nX-Proxy-Info: For proxy configuration, see https://example.com/proxy-setup\n\n{\n  \"message\": \"Resource accessed successfully\",\n  \"proxy_documentation\": \"https://example.com/proxy-setup\"\n}",
                "explanation": "En lugar de usar 305 deprecado, proporciona información sobre configuración de proxy a través de documentación o headers informativos. La configuración de proxy debe manejarse a nivel de cliente, no mediante respuestas HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1 (DEPRECADO)",
        "specification": "RFC 7231, Section 6.4.5 (marcado como deprecado)",
        "relatedHeaders": [
            "Location"
        ],
        "technicalNotes": "Este código está OFICIALMENTE DEPRECADO desde HTTP/1.1. Fue removido de la especificación debido a serias preocupaciones de seguridad. Los navegadores modernos NO lo implementan y lo ignoran. Representaba un vector de ataque para man-in-the-middle. NUNCA debe ser usado en implementaciones nuevas. Las configuraciones de proxy deben manejarse a nivel de sistema operativo, configuración de red del usuario, o PAC (Proxy Auto-Config) files, NO mediante respuestas HTTP.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/305_paioqd.png",
                "alt": "Imagen que representa el nombre del código 305 Use Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/21-removebg-preview_vr87er.png",
                "alt": "Imagen del código 305 Use Proxy"
            }
        ]
    },
    {
        "code": 306,
        "status": "Switch Proxy",
        "category": "Redirection",
        "description": "El código 306 Switch Proxy es un código de estado que ya no se utiliza en las especificaciones HTTP modernas y está completamente OBSOLETO. Este código fue definido en una versión preliminar de la especificación HTTP/1.1 pero nunca llegó a ser parte del estándar oficial final. Originalmente, el código 306 estaba destinado a indicar que las solicitudes subsecuentes deben usar el proxy especificado, similar en concepto al deprecado 305 Use Proxy, pero con la intención de que fuera utilizado en solicitudes futuras en lugar de la solicitud actual. Sin embargo, debido a las mismas preocupaciones graves de seguridad que llevaron a la deprecación del código 305, el código 306 fue eliminado completamente de la especificación antes de su finalización. El código 306 nunca fue ampliamente implementado por navegadores o servidores web, y hoy en día no tiene ningún significado definido en HTTP. Si un servidor envía un código 306, los clientes modernos no sabrán cómo manejarlo correctamente. En la especificación oficial RFC 7231 de HTTP/1.1, el código 306 simplemente está marcado como '(Unused)' - no utilizado. El espacio del código 306 fue reservado pero nunca se le asignó un significado oficial, y permanece sin uso en todas las versiones modernas de HTTP. Esto representa un caso interesante en el desarrollo de estándares donde un código fue propuesto, asignado un número, pero luego abandonado antes de la ratificación final del estándar. A diferencia del 305 que fue oficialmente deprecado después de ser parte del estándar, el 306 simplemente nunca llegó a existir oficialmente. En implementaciones modernas, este código no debe ser usado bajo ninguna circunstancia y si se encuentra en respuestas, debe ser tratado como un error desconocido o no válido.",
        "useCases": [
            "NINGUNO - Este código está completamente OBSOLETO y nunca fue parte del estándar oficial",
            "No tiene significado definido en HTTP moderno",
            "Fue abandonado antes de la finalización de HTTP/1.1",
            "No debe ser usado en ninguna implementación"
        ],
        "examples": [
            {
                "scenario": "Código obsoleto sin uso oficial",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 306 (Unused)\n\n[Este código NO tiene significado oficial y NO debe ser usado]",
                "explanation": "El código 306 nunca fue oficialmente definido en el estándar HTTP final. Si un servidor responde con 306, los clientes modernos no sabrán cómo manejarlo. Este código simplemente no debe ser usado."
            },
            {
                "scenario": "Manejo correcto en cliente moderno",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "Si un cliente recibe 306:\n- Debe tratarlo como un código de estado desconocido\n- Puede registrar un error o advertencia\n- No debe intentar interpretarlo como una redirección válida\n- Debería fallar la solicitud o usar comportamiento de fallback",
                "explanation": "Los clientes modernos correctamente implementados no tienen lógica especial para manejar 306 porque nunca fue parte del estándar. Si se encuentra, indica un problema de configuración del servidor."
            }
        ],
        "httpVersion": "HTTP/1.1 (NUNCA OFICIALIZADO)",
        "specification": "RFC 7231 - marcado como '(Unused)' / Sin uso oficial",
        "relatedHeaders": [],
        "technicalNotes": "El código 306 fue propuesto en borradores tempranos de HTTP/1.1 pero fue eliminado antes de la especificación final. En RFC 7231, aparece listado como '306 (Unused)' indicando que el número está reservado pero sin significado asignado. A diferencia del 305 que fue deprecado después de uso, el 306 simplemente nunca existió oficialmente. NO debe ser implementado ni usado en sistemas modernos. Su presencia en listados de códigos HTTP es puramente histórica.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701322/306_egqdxk.png",
                "alt": "Imagen que representa el nombre del código 306 Switch Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/22-removebg-preview_q8lfzw.png",
                "alt": "Imagen del código 306 Switch Proxy"
            }
        ]
    },
    {
        "code": 307,
        "status": "Temporary Redirect",
        "category": "Redirection",
        "description": "El código 307 Temporary Redirect indica que el recurso solicitado reside temporalmente bajo una URI diferente, y el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. Esta es la diferencia crítica y el propósito principal del código 307: garantizar que el método HTTP se preserve durante la redirección. Mientras que el código 302 Found es históricamente ambiguo (la especificación dice preservar el método, pero los navegadores cambian POST a GET en la práctica), el código 307 elimina toda ambigüedad al requerir explícitamente que el método se mantenga idéntico. Si la solicitud original fue POST, la solicitud redirigida también debe ser POST. Si fue DELETE, la redirigida también debe ser DELETE. Esto es esencial en escenarios donde el método HTTP tiene significado semántico importante y cambiarlo podría causar comportamiento incorrecto o inseguro. Por ejemplo, si un cliente envía una solicitud POST con datos importantes a un servidor que responde con redirección, es crucial que esos datos sean enviados al nuevo destino también con POST, no convertidos a GET (que podría perder los datos del cuerpo o exponerlos en la URL). El código 307 fue introducido en HTTP/1.1 específicamente para proporcionar una versión sin ambigüedades del 302 que preserve el método. Al igual que 302, el 307 indica que la redirección es temporal, no permanente, por lo que los motores de búsqueda deben mantener el URL original en sus índices y los navegadores no deben cachear la redirección de forma agresiva. Los casos de uso comunes incluyen: mantenimiento temporal donde se necesita redirigir solicitudes POST, balanceo de carga que preserva el método de la solicitud, redirecciones de API donde el método es crítico para la semántica de la operación, y cualquier escenario de redirección temporal donde cambiar el método HTTP sería semánticamente incorrecto o podría causar pérdida de datos.",
        "useCases": [
            "Redirecciones temporales donde preservar el método HTTP es crítico",
            "Mantenimiento temporal de APIs que manejan POST, PUT, DELETE",
            "Balanceo de carga entre servidores manteniendo el método original",
            "Redirecciones de APIs RESTful donde el método define la operación",
            "Migración gradual de endpoints preservando semántica del método",
            "Redirección temporal de uploads (POST con archivos)",
            "Failover entre servidores sin cambiar la naturaleza de la solicitud",
            "Testing A/B de APIs donde el método debe mantenerse consistente"
        ],
        "examples": [
            {
                "scenario": "Redirección POST preservando el método",
                "request": "POST /api/orders HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"product_id\": 789,\n  \"quantity\": 3,\n  \"customer_id\": 456,\n  \"shipping_address\": \"123 Main St\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-backup.example.com/api/orders\nRetry-After: 120\nCache-Control: no-cache, no-store\nX-Redirect-Reason: primary_server_maintenance\n\n{\n  \"message\": \"Primary server under maintenance\",\n  \"redirect_to\": \"https://api-backup.example.com/api/orders\",\n  \"note\": \"Your request will be resubmitted automatically\"\n}",
                "explanation": "El servidor principal está en mantenimiento temporal. La redirección 307 asegura que el navegador/cliente reenvíe la solicitud POST completa con todos los datos del pedido al servidor de backup, sin cambiar a GET que perdería los datos."
            },
            {
                "scenario": "Balanceo de carga con método preservado",
                "request": "PUT /api/users/123/profile HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john.new@example.com\",\n  \"phone\": \"+1234567890\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-node-2.example.com/api/users/123/profile\nX-Load-Balancer: round-robin\nX-Target-Node: node-2\nCache-Control: no-cache\n\n{\n  \"status\": \"redirecting\",\n  \"target_server\": \"node-2\",\n  \"message\": \"Request being routed to optimal server node\"\n}",
                "explanation": "El load balancer redirige temporalmente la solicitud PUT a otro nodo del cluster. El código 307 garantiza que la solicitud PUT con los datos de actualización del perfil se envíe al nuevo servidor, no se convierta en GET."
            },
            {
                "scenario": "Upload de archivo con redirección temporal",
                "request": "POST /api/uploads HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data; boundary=----Boundary\nContent-Length: 5242880\n\n------Boundary\nContent-Disposition: form-data; name=\"file\"; filename=\"report.pdf\"\nContent-Type: application/pdf\n\n[5MB de datos del archivo PDF]\n------Boundary--",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://storage-region-2.example.com/api/uploads\nX-Storage-Region: us-west-2\nX-Redirect-Reason: region_optimization\nRetry-After: 0\n\n{\n  \"message\": \"Redirecting to optimal storage region\",\n  \"target_region\": \"us-west-2\",\n  \"note\": \"File upload will be resubmitted automatically\"\n}",
                "explanation": "El sistema de storage detecta que el usuario está más cerca de otra región y redirige temporalmente. El código 307 asegura que el POST con el archivo completo se reenvíe al servidor de la nueva región sin perder datos."
            },
            {
                "scenario": "Mantenimiento de API con DELETE preservado",
                "request": "DELETE /api/articles/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_abc\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-maintenance.example.com/api/articles/456\nX-Maintenance-Mode: true\nX-Estimated-Duration: 1800\nCache-Control: no-store\n\n{\n  \"status\": \"maintenance_redirect\",\n  \"message\": \"Main API under scheduled maintenance\",\n  \"maintenance_endpoint\": \"https://api-maintenance.example.com\",\n  \"operation_will_complete\": true\n}",
                "explanation": "Durante mantenimiento programado, las solicitudes DELETE son redirigidas a un servidor de mantenimiento que puede procesarlas. El 307 preserva el método DELETE para que la operación de eliminación se ejecute correctamente en el nuevo servidor."
            },
            {
                "scenario": "Migración gradual de endpoints",
                "request": "PATCH /api/v2/settings/notifications HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\n\n{\n  \"email_notifications\": false,\n  \"push_notifications\": true\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://new-api.example.com/api/v2/settings/notifications\nX-Migration-Phase: gradual-rollout\nX-Legacy-Endpoint: deprecated\nDeprecation: true\nLink: <https://docs.example.com/api-migration>; rel=\"deprecation\"\n\n{\n  \"message\": \"This endpoint is being migrated to new infrastructure\",\n  \"new_location\": \"https://new-api.example.com/api/v2/settings/notifications\",\n  \"migration_guide\": \"https://docs.example.com/api-migration\"\n}",
                "explanation": "Durante una migración gradual de API, el endpoint antiguo redirige temporalmente al nuevo con 307, preservando el método PATCH y los datos de actualización de configuración."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.7",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "X-Redirect-Reason"
        ],
        "technicalNotes": "El código 307 fue introducido en HTTP/1.1 para eliminar la ambigüedad del 302. La diferencia clave es que 307 GARANTIZA que el método HTTP se preserve (POST sigue siendo POST, PUT sigue siendo PUT, etc.), mientras que 302 en la práctica causa que navegadores cambien POST a GET. Para redirecciones temporales donde el método debe preservarse, siempre usa 307. Para redirecciones temporales donde cambiar a GET es aceptable o deseado, usa 302 o mejor aún 303. Los navegadores NO cachean 307 agresivamente, similar a 302. Los motores de búsqueda mantienen el URL original en índices.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701321/307_zejcdc.png",
                "alt": "Imagen que representa el nombre del código 307 Temporary Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/23-removebg-preview_lguvh9.png",
                "alt": "Imagen del código 307 Temporary Redirect"
            }
        ]
    },
    {
        "code": 308,
        "status": "Permanent Redirect",
        "category": "Redirection",
        "description": "El código 308 Permanent Redirect indica que el recurso solicitado ha sido movido permanentemente a una nueva URI especificada en el encabezado Location, y todas las futuras solicitudes deben usar la nueva URI. Además, y esto es lo más importante, el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. El código 308 es a 301 lo que 307 es a 302: proporciona una versión sin ambigüedades que garantiza la preservación del método HTTP. Mientras que el código 301 Moved Permanently es históricamente ambiguo (muchos navegadores cambian POST a GET al seguir un 301, aunque la especificación dice preservar el método), el código 308 elimina completamente esta ambigüedad. Si la solicitud original fue POST, la redirigida debe ser POST. Si fue PUT, la redirigida debe ser PUT. Si fue DELETE, la redirigida debe ser DELETE. Esta garantía es crítica para APIs RESTful y aplicaciones donde el método HTTP tiene significado semántico importante. El código 308 fue estandarizado más recientemente que otros códigos de redirección (en RFC 7538 de 2015) para llenar un vacío en la especificación HTTP. Combina dos propiedades importantes: (1) permanencia - como 301, indica que el cambio es definitivo y permanente, los motores de búsqueda deben actualizar índices, los navegadores pueden cachear la redirección, y el valor SEO debe transferirse al nuevo URL; (2) preservación del método - como 307, garantiza que el método HTTP no cambie durante la redirección. Los casos de uso típicos incluyen: reestructuración permanente de APIs donde los métodos deben preservarse, migración permanente de endpoints RESTful, consolidación de servicios manteniendo semántica de métodos HTTP, cambios de infraestructura permanentes donde POST/PUT/DELETE deben mantenerse, y cualquier redirección permanente donde cambiar el método sería semánticamente incorrecto o causaría pérdida de datos.",
        "useCases": [
            "Reestructuración permanente de APIs RESTful preservando métodos HTTP",
            "Migración permanente de endpoints donde POST, PUT, DELETE deben mantenerse",
            "Cambio permanente de dominio para APIs con operaciones de escritura",
            "Consolidación de servicios manteniendo semántica RESTful",
            "Deprecación definitiva de endpoints antiguos hacia nuevos con misma funcionalidad",
            "Migración de infraestructura permanente (on-premise a cloud) preservando métodos",
            "Reorganización de URLs en APIs donde el método HTTP es parte de la semántica",
            "Versioning de APIs con redirección permanente preservando operaciones"
        ],
        "examples": [
            {
                "scenario": "Migración permanente de API endpoint con POST",
                "request": "POST /api/v1/users HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane@example.com\",\n  \"role\": \"admin\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v2/users\nCache-Control: max-age=31536000\nDeprecation: true\nSunset: Mon, 01 Jan 2025 00:00:00 GMT\n\n{\n  \"message\": \"API v1 has been permanently moved to v2\",\n  \"new_endpoint\": \"https://api.example.com/v2/users\",\n  \"documentation\": \"https://docs.example.com/api/v2\",\n  \"note\": \"Please update your integration to use the new endpoint\"\n}",
                "explanation": "La API v1 ha sido permanentemente reemplazada por v2. El código 308 asegura que la solicitud POST con los datos del nuevo usuario se reenvíe al nuevo endpoint manteniendo POST, no convirtiéndose a GET que perdería los datos."
            },
            {
                "scenario": "Cambio permanente de dominio con PUT preservado",
                "request": "PUT /api/products/789 HTTP/1.1\nHost: shop-api.oldcompany.com\nContent-Type: application/json\nAuthorization: Bearer token_abc\n\n{\n  \"name\": \"Updated Product Name\",\n  \"price\": 99.99,\n  \"stock\": 150,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.newcompany.com/api/products/789\nCache-Control: public, max-age=31536000, immutable\nX-Company-Rebrand: true\nLink: <https://www.newcompany.com/api-migration>; rel=\"alternate\"\n\n{\n  \"status\": \"permanent_redirect\",\n  \"message\": \"Our company has rebranded. API permanently moved to new domain.\",\n  \"new_location\": \"https://api.newcompany.com\",\n  \"migration_complete\": true\n}",
                "explanation": "La empresa cambió de marca y dominio permanentemente. El 308 garantiza que la solicitud PUT para actualizar el producto se reenvíe al nuevo dominio manteniendo el método PUT y todos los datos de actualización."
            },
            {
                "scenario": "Reestructuración permanente con DELETE preservado",
                "request": "DELETE /services/old-structure/items/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v3/items/456\nCache-Control: max-age=2592000\nX-API-Restructure: v3-final\n\n{\n  \"message\": \"API structure has been permanently reorganized\",\n  \"old_path\": \"/services/old-structure/items/:id\",\n  \"new_path\": \"/v3/items/:id\",\n  \"operation_preserved\": \"DELETE\",\n  \"note\": \"Your delete operation will complete at the new location\"\n}",
                "explanation": "La estructura de la API fue permanentemente reorganizada. El 308 asegura que la solicitud DELETE se reenvíe a la nueva estructura manteniendo la operación de eliminación, no cambiando a GET."
            },
            {
                "scenario": "Migración cloud permanente con PATCH",
                "request": "PATCH /api/configurations/global HTTP/1.1\nHost: on-premise.example.com\nContent-Type: application/json\n\n{\n  \"maintenance_mode\": false,\n  \"max_connections\": 1000,\n  \"timeout_seconds\": 30\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://cloud-api.example.com/api/configurations/global\nX-Migration-Type: on-premise-to-cloud\nX-Migration-Date: 2024-01-15\nCache-Control: public, max-age=31536000\n\n{\n  \"message\": \"Service permanently migrated to cloud infrastructure\",\n  \"cloud_endpoint\": \"https://cloud-api.example.com\",\n  \"on_premise_shutdown\": \"2024-06-01\",\n  \"benefits\": \"Improved reliability, scalability, and performance\"\n}",
                "explanation": "El servicio fue migrado permanentemente de infraestructura on-premise a cloud. El 308 preserva el método PATCH para que la actualización parcial de configuración se aplique correctamente en el nuevo servidor cloud."
            },
            {
                "scenario": "Consolidación de microservicios con POST",
                "request": "POST /payment-service/api/process HTTP/1.1\nHost: payments.example.com\nContent-Type: application/json\n\n{\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_12345\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://unified-api.example.com/payments/process\nX-Service-Consolidation: microservices-to-unified\nCache-Control: max-age=15552000\n\n{\n  \"message\": \"Payment service consolidated into unified API\",\n  \"new_endpoint\": \"https://unified-api.example.com/payments/process\",\n  \"consolidation_date\": \"2024-01-01\",\n  \"note\": \"All microservices now under unified API gateway\"\n}",
                "explanation": "Múltiples microservicios fueron consolidados en una API unificada permanentemente. El 308 asegura que la solicitud POST de procesamiento de pago con datos sensibles se reenvíe correctamente manteniendo POST."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7538 (2015)",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Deprecation",
            "Sunset",
            "Link"
        ],
        "relatedCodes": [
            301,
            307
        ],
        "technicalNotes": "El código 308 es relativamente nuevo (RFC 7538, 2015) y fue creado para llenar el vacío de un código de redirección permanente que preserve el método HTTP. Es a 301 lo que 307 es a 302. Combina permanencia (como 301) con preservación de método (como 307). Los navegadores modernos lo soportan bien desde ~2015-2016. Al igual que 301, los navegadores y motores de búsqueda deben cachear 308 y actualizar índices. La diferencia crítica con 301 es que 308 GARANTIZA que POST/PUT/DELETE/PATCH se preserven, mientras que 301 históricamente causa que navegadores cambien POST a GET. Para APIs RESTful con redirecciones permanentes, 308 es casi siempre la elección correcta.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/308_ypkqc3.png",
                "alt": "Imagen que representa el nombre del código 308 Permanent Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/24-removebg-preview_ee4zid.png",
                "alt": "Imagen del código 308 Permanent Redirect"
            }
        ]
    },
    {
        "code": 400,
        "status": "Bad Request",
        "category": "Client Error",
        "description": "El código 400 Bad Request indica que el servidor no puede o no procesará la solicitud debido a algo que se percibe como un error del cliente. Este es uno de los códigos de error más comunes y versátiles en HTTP, utilizado como respuesta genérica para una amplia variedad de errores de solicitud del cliente que no encajan en categorías más específicas. El servidor está indicando que la solicitud está malformada, contiene sintaxis inválida, parámetros inválidos, o es imposible de cumplir por razones que son responsabilidad del cliente. Las causas comunes incluyen: JSON o XML mal formado en el cuerpo de la solicitud, parámetros de query string inválidos o que faltan, encabezados HTTP malformados o contradictorios, tamaño de solicitud que excede límites del servidor, errores de codificación de caracteres, valores de datos que no cumplen con reglas de validación, tipos de contenido no soportados, o cualquier otra violación del protocolo HTTP o de las expectativas de la API. A diferencia de errores 5xx que indican problemas del servidor, el 400 señala claramente que el problema está en la solicitud del cliente y que reenviar la misma solicitud sin modificaciones resultará en el mismo error. El cliente debe corregir la solicitud antes de reintentarla. Es importante que las respuestas 400 incluyan información descriptiva en el cuerpo del mensaje explicando qué está mal con la solicitud para ayudar a los desarrolladores a corregir el problema. Una buena respuesta 400 debería especificar: qué campo o parámetro causó el error, qué se esperaba versus qué se recibió, y cómo corregir el problema. En APIs RESTful modernas, es común incluir códigos de error estructurados, mensajes de error detallados, y referencias a documentación. El código 400 es preferible a códigos de error más específicos cuando el error no encaja claramente en categorías como 401 (autenticación), 403 (autorización), 404 (no encontrado), etc.",
        "useCases": [
            "JSON o XML malformado en el cuerpo de la solicitud",
            "Parámetros de query string inválidos, faltantes o mal formateados",
            "Errores de validación de datos de entrada (formatos incorrectos, valores fuera de rango)",
            "Encabezados HTTP contradictorios o malformados",
            "Tamaño de solicitud que excede límites permitidos",
            "Tipo de contenido no soportado o Content-Type incorrecto",
            "Errores de codificación de caracteres en la solicitud",
            "Violaciones de esquema o estructura de datos esperada",
            "Combinaciones inválidas de parámetros",
            "Requests que violan reglas de negocio básicas"
        ],
        "examples": [
            {
                "scenario": "JSON malformado en el cuerpo de la solicitud",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  // Comentario inválido en JSON\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_request_body\",\n  \"message\": \"Request body contains malformed JSON\",\n  \"details\": \"Unexpected token '/' at position 78. JSON does not support comments.\",\n  \"documentation\": \"https://api.example.com/docs/errors/invalid-json\"\n}",
                "explanation": "El JSON en el cuerpo contiene un comentario que no es válido en JSON estándar. El servidor responde con 400 y explica específicamente qué está mal y dónde ocurrió el error."
            },
            {
                "scenario": "Parámetros de validación fallidos",
                "request": "POST /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"AB\",\n  \"price\": -10.50,\n  \"stock\": \"not_a_number\"\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Request validation failed\",\n  \"validation_errors\": [\n    {\n      \"field\": \"name\",\n      \"message\": \"Name must be at least 3 characters long\",\n      \"received\": \"AB\"\n    },\n    {\n      \"field\": \"price\",\n      \"message\": \"Price must be a positive number\",\n      \"received\": -10.50\n    },\n    {\n      \"field\": \"stock\",\n      \"message\": \"Stock must be an integer\",\n      \"received_type\": \"string\"\n    }\n  ]\n}",
                "explanation": "Múltiples campos tienen errores de validación. La respuesta 400 proporciona detalles específicos de cada error, facilitando que el cliente corrija todos los problemas de una vez."
            },
            {
                "scenario": "Parámetros de query string inválidos",
                "request": "GET /api/users?page=abc&limit=-5 HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_query_parameters\",\n  \"message\": \"One or more query parameters are invalid\",\n  \"errors\": [\n    {\n      \"parameter\": \"page\",\n      \"error\": \"Page must be a positive integer\",\n      \"received\": \"abc\"\n    },\n    {\n      \"parameter\": \"limit\",\n      \"error\": \"Limit must be between 1 and 100\",\n      \"received\": -5\n    }\n  ]\n}",
                "explanation": "Los parámetros de paginación contienen valores inválidos. El servidor indica qué parámetros están mal y qué valores son aceptables."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.1",
        "relatedHeaders": [
            "Content-Type",
            "Content-Length"
        ],
        "technicalNotes": "400 es un código de error genérico del cliente. Cuando sea posible, usa códigos más específicos: 401 para autenticación, 403 para autorización, 404 para recursos no encontrados, 405 para métodos no permitidos, 409 para conflictos, 422 para errores de validación semántica. El 400 debe reservarse para errores de sintaxis, malformaciones, o cuando ningún código más específico aplica. Siempre incluye un cuerpo de respuesta descriptivo con detalles del error para facilitar debugging.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712934/400_odwp8l.png",
                "alt": "Imagen que representa el nombre del código 400 Bad Request"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712631/25-removebg-preview_ujorgb.png",
                "alt": "Imagen del código 400 Bad Request"
            }
        ]
    },
    {
        "code": 401,
        "status": "Unauthorized",
        "category": "Client Error",
        "description": "El código 401 Unauthorized indica que la solicitud requiere autenticación del usuario y que las credenciales proporcionadas son inválidas, están ausentes, o han expirado. A pesar de su nombre algo confuso ('Unauthorized'), este código específicamente se refiere a problemas de AUTENTICACIÓN (verificar quién eres), no de AUTORIZACIÓN (verificar qué puedes hacer). El nombre más preciso sería 'Unauthenticated', pero por razones históricas se mantiene como 'Unauthorized'. Cuando un servidor responde con 401, está diciendo: 'No sé quién eres' o 'Las credenciales que proporcionaste no son válidas' o 'Tu sesión ha expirado'. El cliente debe proporcionar credenciales válidas (o renovarlas) para acceder al recurso. La respuesta 401 DEBE incluir un encabezado WWW-Authenticate que especifique el esquema de autenticación que el servidor espera (Basic, Bearer, Digest, etc.). Este encabezado informa al cliente qué tipo de credenciales se requieren y cómo deben ser enviadas. Los escenarios comunes incluyen: intentar acceder a un recurso protegido sin proporcionar token de autenticación, proporcionar un token JWT expirado o inválido, credenciales de usuario/contraseña incorrectas, token de API key inválido o revocado, sesión expirada que necesita renovación, o intentar usar un token de autenticación que fue emitido para otro recurso o dominio. En aplicaciones web modernas, 401 típicamente resulta en redireccionar al usuario a una página de login o mostrar un modal de autenticación. En APIs, puede desencadenar un flujo de renovación de tokens (refresh token flow) o requerir que el usuario vuelva a autenticarse. Es crucial distinguir 401 de 403 Forbidden: usa 401 cuando el problema es que el cliente no está autenticado o sus credenciales son inválidas; usa 403 cuando el cliente está correctamente autenticado pero no tiene permisos para acceder al recurso específico.",
        "useCases": [
            "Acceso a recursos protegidos sin proporcionar token de autenticación",
            "Token JWT expirado que necesita renovación",
            "Credenciales de usuario/contraseña incorrectas en login",
            "API key inválida, revocada o faltante",
            "Sesión de usuario expirada que requiere re-autenticación",
            "Token de autenticación malformado o corrupto",
            "Intentar acceder con credenciales que fueron revocadas",
            "Autenticación de dos factores (2FA) fallida",
            "Token OAuth inválido o expirado",
            "Certificado de cliente inválido o faltante en mTLS"
        ],
        "examples": [
            {
                "scenario": "Acceso sin token de autenticación",
                "request": "GET /api/user/profile HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"authentication_required\",\n  \"message\": \"Authentication is required to access this resource\",\n  \"required_header\": \"Authorization: Bearer <token>\",\n  \"obtain_token\": \"https://api.example.com/auth/login\"\n}",
                "explanation": "La solicitud intenta acceder a un perfil de usuario protegido sin proporcionar ningún token de autenticación. El servidor responde con 401 y el encabezado WWW-Authenticate indicando que se requiere autenticación Bearer."
            },
            {
                "scenario": "Token JWT expirado",
                "request": "GET /api/orders HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired_token.signature",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"The access token expired\"\nContent-Type: application/json\n\n{\n  \"error\": \"token_expired\",\n  \"message\": \"Your access token has expired\",\n  \"expired_at\": \"2024-01-15T10:00:00Z\",\n  \"refresh_endpoint\": \"/auth/refresh\"\n}",
                "explanation": "El token JWT proporcionado es válido estructuralmente pero ha expirado. El servidor indica cuándo expiró y cómo obtener un nuevo token usando el refresh token."
            },
            {
                "scenario": "Credenciales de login incorrectas",
                "request": "POST /auth/login HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"username\": \"john@example.com\",\n  \"password\": \"wrong_password\"\n}",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_credentials\",\n  \"message\": \"The username or password you entered is incorrect\",\n  \"attempts_remaining\": 3,\n  \"lockout_warning\": \"Account will be locked after 5 failed attempts\"\n}",
                "explanation": "El usuario proporcionó credenciales incorrectas. El servidor responde con 401 e información sobre intentos restantes antes de bloqueo de cuenta."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7235, Section 3.1",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization",
            "Proxy-Authenticate",
            "Proxy-Authorization"
        ],
        "technicalNotes": "401 es específicamente para AUTENTICACIÓN (quién eres), no AUTORIZACIÓN (qué puedes hacer). La respuesta DEBE incluir encabezado WWW-Authenticate. Los esquemas comunes son: Basic, Bearer (JWT/OAuth), Digest, OAuth, ApiKey. Distinguir de 403 Forbidden: 401 = no estás autenticado o credenciales inválidas; 403 = estás autenticado pero no autorizado. En aplicaciones web, 401 típicamente resulta en redirect a login; en APIs, puede trigger refresh token flow.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712933/401_bmlwc3.png",
                "alt": "Imagen que representa el nombre del código 401 Unauthorized"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712629/26-removebg-preview_kemtbk.png",
                "alt": "Imagen del código 401 Unauthorized"
            }
        ]
    },
    {
        "code": 402,
        "status": "Payment Required",
        "category": "Client Error",
        "description": "El código 402 Payment Required está RESERVADO para uso futuro y originalmente fue concebido para sistemas de pago digital y micropagos en la web. Este código fue incluido en la especificación original de HTTP con la visión de que la web eventualmente incorporaría sistemas de pago integrados directamente en el protocolo HTTP. La idea era que los servidores pudieran responder con 402 cuando un recurso requiriera pago, y los navegadores tendrían capacidades integradas para manejar transacciones. Sin embargo, más de 30 años después de su creación, el código 402 sigue sin tener una definición formal o implementación estándar. Aunque está reservado oficialmente, NO existe un comportamiento estándar definido para él en las especificaciones HTTP. A pesar de esto, algunas APIs modernas y servicios han comenzado a utilizar 402 de manera no estándar para indicar varios escenarios relacionados con pagos: cuando un usuario ha excedido su cuota de API gratuita y necesita actualizar a un plan de pago, cuando una suscripción ha expirado, cuando se requiere pago para acceder a contenido premium, o cuando un servicio freemium ha alcanzado sus límites gratuitos. Sin embargo, estas implementaciones son completamente no estandarizadas y varían significativamente entre diferentes servicios. Debido a la falta de estándares, muchos desarrolladores y servicios evitan usar 402 y en su lugar optan por códigos alternativos como 403 Forbidden con mensajes explicativos sobre requisitos de pago, 451 Unavailable For Legal Reasons para contenido bloqueado por razones comerciales, o códigos de error personalizados en el rango 4xx. Algunos argumentan que 402 podría ser útil para distinguir problemas de pago de otros errores, pero sin estandarización, su uso sigue siendo experimental y no recomendado para producción crítica.",
        "useCases": [
            "USO NO ESTÁNDAR: Indicar que se ha excedido cuota de API gratuita",
            "USO NO ESTÁNDAR: Suscripción expirada que requiere renovación",
            "USO NO ESTÁNDAR: Contenido premium que requiere pago",
            "USO NO ESTÁNDAR: Límites de freemium alcanzados",
            "NOTA: Ninguno de estos usos está estandarizado oficialmente"
        ],
        "examples": [
            {
                "scenario": "Uso experimental (NO estándar) - Cuota de API excedida",
                "request": "GET /api/premium-data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 402 Payment Required\nContent-Type: application/json\n\n{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"You have exceeded your free tier quota\",\n  \"quota_limit\": 1000,\n  \"quota_used\": 1000,\n  \"upgrade_url\": \"https://billing.example.com/upgrade\",\n  \"note\": \"Non-standard use of 402. Standard practice would be 403 or 429.\"\n}",
                "explanation": "USO EXPERIMENTAL: Este servicio usa 402 para indicar que el usuario gratuito ha excedido su cuota. Sin embargo, este NO es un uso estándar. Sería más apropiado usar 429 (Too Many Requests) o 403 (Forbidden) con información de pago."
            },
            {
                "scenario": "Alternativa ESTÁNDAR recomendada - Usar 403 con contexto de pago",
                "request": "GET /api/premium-features HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"payment_required\",\n  \"message\": \"This feature requires a paid subscription\",\n  \"current_plan\": \"free\",\n  \"required_plan\": \"premium\",\n  \"upgrade_url\": \"https://example.com/upgrade\",\n  \"price\": \"$19.99/month\"\n}",
                "explanation": "MEJOR PRÁCTICA: Usar 403 Forbidden con información detallada sobre requisitos de pago es más estándar y ampliamente entendido que usar el no estandarizado 402."
            },
            {
                "scenario": "Alternativa usando 429 para límites de cuota",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1706745600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded your monthly API quota\",\n  \"reset_date\": \"2024-02-01T00:00:00Z\",\n  \"upgrade_info\": \"https://billing.example.com/upgrade\"\n}",
                "explanation": "MEJOR PRÁCTICA: Para límites de cuota/rate limiting, 429 Too Many Requests es semánticamente más correcto que 402, incluso si el upgrade requiere pago."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.2 (Reserved for future use)",
        "relatedHeaders": [],
        "technicalNotes": "El código 402 está OFICIALMENTE RESERVADO pero NO DEFINIDO en las especificaciones HTTP. No existe comportamiento estándar para este código. Su uso en producción es NO RECOMENDADO. Alternativas estándar: 403 Forbidden (para contenido que requiere pago), 429 Too Many Requests (para límites de cuota), o códigos personalizados 4xx. Muchas empresas evitan 402 completamente debido a la falta de estandarización.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712936/402_vofv3h.png",
                "alt": "Imagen que representa el nombre del código 402 Payment Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712628/27-removebg-preview_sws62c.png",
                "alt": "Imagen del código 402 Payment Required"
            }
        ]
    },
    {
        "code": 403,
        "status": "Forbidden",
        "category": "Client Error",
        "description": "El código 403 Forbidden indica que el servidor entendió la solicitud pero se niega a autorizarla. A diferencia del 401 Unauthorized que se refiere a problemas de AUTENTICACIÓN (quién eres), el 403 se refiere específicamente a problemas de AUTORIZACIÓN (qué tienes permitido hacer). Cuando un servidor responde con 403, está diciendo: 'Sé quién eres (estás autenticado correctamente), pero no tienes permiso para acceder a este recurso' o 'Este recurso está prohibido para ti'. Este es un punto crítico de distinción: 401 significa que no te has identificado o tus credenciales son inválidas, mientras que 403 significa que te identificaste correctamente pero no tienes los permisos necesarios. Un 403 indica que proporcionar credenciales diferentes no ayudará - el acceso está prohibido independientemente de la autenticación. Las causas comunes incluyen: intentar acceder a un recurso para el cual tu rol de usuario no tiene permisos, intentar realizar una operación que excede tus privilegios (por ejemplo, un usuario regular intentando acceder a funciones de administrador), acceder a recursos que están geográficamente restringidos, intentar acceder a contenido que requiere una suscripción o plan de pago superior, violación de políticas de seguridad o control de acceso, acceso bloqueado por firewall de aplicación web (WAF), direcciones IP bloqueadas o en lista negra, intentar acceder a archivos del sistema o directorios protegidos, o violación de límites de rate limiting basados en permisos. A diferencia del 401 que puede ser resuelto proporcionando credenciales válidas, un 403 generalmente requiere que se otorguen permisos adicionales al usuario, que se cambie de plan de suscripción, que se modifiquen políticas de acceso, o que se eliminen restricciones. Las respuestas 403 deben ser cuidadosamente diseñadas para no revelar información sensible sobre la estructura del sistema o existencia de recursos, ya que esto podría ser explotado por atacantes. Es una buena práctica incluir información útil sobre por qué el acceso fue denegado (sin revelar detalles de seguridad sensibles) y qué acciones podría tomar el usuario para obtener acceso.",
        "useCases": [
            "Usuario autenticado intenta acceder a recursos de administrador sin privilegios",
            "Acceso a recursos que requieren roles o permisos específicos que el usuario no tiene",
            "Intentar modificar o eliminar recursos que pertenecen a otro usuario",
            "Acceso a contenido premium sin suscripción adecuada",
            "Restricciones geográficas o de región (geo-blocking)",
            "Límites de rate limiting excedidos para el nivel de usuario",
            "IP bloqueada o en lista negra por razones de seguridad",
            "Violación de políticas de uso o términos de servicio",
            "Acceso a recursos durante horarios restringidos",
            "Intentar realizar operaciones en modo de solo lectura"
        ],
        "examples": [
            {
                "scenario": "Usuario sin privilegios de administrador",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer valid_user_token_not_admin",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"insufficient_permissions\",\n  \"message\": \"You do not have permission to perform this action\",\n  \"required_role\": \"admin\",\n  \"your_role\": \"user\",\n  \"action_attempted\": \"delete_user\",\n  \"contact\": \"Please contact your administrator to request elevated permissions\",\n  \"documentation\": \"https://docs.example.com/permissions/roles\"\n}",
                "explanation": "El usuario está correctamente autenticado (el token es válido) pero su rol de 'user' no tiene permisos para eliminar usuarios. Solo los administradores pueden realizar esta acción. Proporcionar un token diferente de usuario regular no ayudará."
            },
            {
                "scenario": "Acceso a recurso de otro usuario",
                "request": "GET /api/users/456/private-messages HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_123_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"access_denied\",\n  \"message\": \"You are not authorized to access this resource\",\n  \"reason\": \"This resource belongs to another user\",\n  \"resource_owner\": \"user_456\",\n  \"authenticated_as\": \"user_123\",\n  \"allowed_actions\": [\n    \"View your own messages at /api/users/123/private-messages\"\n  ]\n}",
                "explanation": "El usuario 123 está autenticado correctamente pero está intentando acceder a los mensajes privados del usuario 456. Por razones de privacidad y seguridad, esto está prohibido. Solo puede acceder a sus propios mensajes."
            },
            {
                "scenario": "Contenido premium sin suscripción adecuada",
                "request": "GET /api/premium-analytics/advanced-reports HTTP/1.1\nHost: analytics.example.com\nAuthorization: Bearer basic_plan_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"subscription_required\",\n  \"message\": \"This feature requires a premium subscription\",\n  \"current_plan\": \"Basic\",\n  \"required_plan\": \"Premium\",\n  \"feature_name\": \"Advanced Analytics Reports\",\n  \"upgrade_info\": {\n    \"plan_name\": \"Premium Plan\",\n    \"monthly_price\": \"$49.99\",\n    \"annual_price\": \"$499.99 (2 months free)\",\n    \"features\": [\n      \"Advanced analytics reports\",\n      \"Custom dashboards\",\n      \"API access\",\n      \"Priority support\"\n    ],\n    \"upgrade_url\": \"https://analytics.example.com/upgrade\",\n    \"trial_available\": true,\n    \"trial_duration\": \"14 days\"\n  }\n}",
                "explanation": "El usuario está autenticado y tiene una cuenta válida con plan Basic, pero este recurso específico requiere un plan Premium. El acceso está prohibido hasta que actualice su suscripción."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.3",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization"
        ],
        "technicalNotes": "403 es específicamente para AUTORIZACIÓN (qué puedes hacer), no AUTENTICACIÓN (quién eres). La diferencia con 401: 401 = no autenticado o credenciales inválidas (solucionable con login correcto); 403 = autenticado pero sin permisos (proporcionar otras credenciales no ayuda, se necesitan permisos adicionales). No incluyas WWW-Authenticate en 403, ese encabezado es para 401. Por seguridad, considera si deberías devolver 404 en lugar de 403 cuando no quieras revelar que un recurso existe. 403 es apropiado cuando el usuario debe saber que el recurso existe pero no puede accederlo.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712938/403_vobb9m.png",
                "alt": "Imagen que representa el nombre del código 403 Forbidden"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712627/28-removebg-preview_kc6xuc.png",
                "alt": "Imagen del código 403 Forbidden"
            }
        ]
    },
    {
        "code": 404,
        "status": "Not Found",
        "category": "Client Error",
        "description": "El código 404 Not Found es probablemente el código de estado HTTP más conocido y reconocible, incluso fuera de la comunidad técnica. Indica que el servidor no pudo encontrar el recurso solicitado. Es importante entender que 404 significa específicamente que el URI solicitado no corresponde a ningún recurso existente en el servidor, pero no proporciona información sobre si esta ausencia es temporal o permanente. El servidor está diciendo: 'Busqué en la ubicación que especificaste y no hay nada allí'. Esto puede ocurrir por varias razones: el recurso nunca existió en esa ubicación, el recurso existió anteriormente pero fue eliminado, el recurso fue movido a otra ubicación sin configurar una redirección, hay un error tipográfico en la URL, o el usuario no tiene permisos para saber que el recurso existe (en cuyo caso 404 se usa intencionalmente en lugar de 403 por razones de seguridad). El código 404 es apropiado tanto para recursos que definitivamente no existen como para aquellos cuya existencia no debería ser revelada por razones de seguridad o privacidad. Por ejemplo, si un usuario intenta acceder a '/admin/secret-page' pero no tiene permisos, podrías devolver 404 en lugar de 403 para no confirmar que esa página existe. El 404 es distinto del 410 Gone, que específicamente indica que el recurso existió anteriormente pero fue eliminado permanentemente y no regresará. Si sabes con certeza que un recurso fue eliminado permanentemente, 410 es más semántico, pero 404 es aceptable y más comúnmente usado. Las páginas 404 personalizadas son una práctica común en diseño web, ofreciendo navegación útil, búsqueda, o contenido relacionado en lugar de simplemente indicar el error. En APIs RESTful, las respuestas 404 deben incluir información estructurada sobre qué recurso no se encontró y potencialmente sugerencias de recursos similares o acciones alternativas. Es importante que las respuestas 404 sean informativas pero no revelen información sensible del sistema.",
        "useCases": [
            "URL con error tipográfico o mal formada",
            "Recurso que fue eliminado y no existe más",
            "Recurso que nunca existió en la ubicación especificada",
            "ID de recurso inválido en APIs RESTful (producto, usuario, orden que no existe)",
            "Ruta de archivo o directorio inexistente",
            "Endpoint de API que no está definido o fue deprecado",
            "Recurso movido sin redirección configurada",
            "Seguridad: ocultar existencia de recursos sensibles devolviendo 404 en lugar de 403",
            "Páginas que fueron parte de una reestructuración de sitio sin mantener URLs antiguas",
            "Recursos temporales que expiraron (cupones, tokens de verificación vencidos)"
        ],
        "examples": [
            {
                "scenario": "Recurso no encontrado en API REST",
                "request": "GET /api/products/99999 HTTP/1.1\nHost: shop.example.com\nAccept: application/json",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"resource_not_found\",\n  \"message\": \"Product not found\",\n  \"resource_type\": \"product\",\n  \"resource_id\": \"99999\",\n  \"requested_url\": \"/api/products/99999\",\n  \"suggestions\": [\n    \"Verify the product ID is correct\",\n    \"Browse available products at /api/products\",\n    \"Search products at /api/products/search\"\n  ],\n  \"documentation\": \"https://docs.shop.example.com/api/products\"\n}",
                "explanation": "El cliente solicitó un producto con ID 99999 que no existe en la base de datos. El servidor responde con 404 e información útil sobre cómo proceder."
            },
            {
                "scenario": "Página web no encontrada con sugerencias útiles",
                "request": "GET /blog/non-existent-article HTTP/1.1\nHost: www.example.com\nAccept: text/html",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Not Found - Example Blog</title>\n  <meta name=\"robots\" content=\"noindex\">\n</head>\n<body>\n  <h1>404 - Page Not Found</h1>\n  <p>Sorry, we couldn't find the page you're looking for.</p>\n  <h2>You might be interested in:</h2>\n  <ul>\n    <li><a href=\"/blog\">Latest Blog Posts</a></li>\n    <li><a href=\"/blog/popular\">Popular Articles</a></li>\n    <li><a href=\"/search?q=article\">Search our site</a></li>\n  </ul>\n  <p>Or <a href=\"/\">return to homepage</a></p>\n</body>\n</html>",
                "explanation": "La página solicitada no existe. En lugar de un error genérico, se proporciona una página 404 personalizada con navegación útil, enlaces a contenido popular y opción de búsqueda para ayudar al usuario a encontrar lo que busca."
            },
            {
                "scenario": "Endpoint de API inexistente",
                "request": "POST /api/v2/invalid-endpoint HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"data\": \"some data\"\n}",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"endpoint_not_found\",\n  \"message\": \"The requested API endpoint does not exist\",\n  \"requested_path\": \"/api/v2/invalid-endpoint\",\n  \"method\": \"POST\",\n  \"api_version\": \"v2\",\n  \"available_endpoints\": [\n    \"GET /api/v2/users\",\n    \"POST /api/v2/users\",\n    \"GET /api/v2/products\",\n    \"POST /api/v2/orders\"\n  ],\n  \"documentation\": \"https://api.example.com/docs/v2\",\n  \"support\": \"api-support@example.com\"\n}",
                "explanation": "El cliente está intentando acceder a un endpoint que no existe en la API. El servidor responde con 404 y lista de endpoints disponibles para ayudar al desarrollador a corregir la solicitud."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.4",
        "relatedHeaders": [
            "Content-Type",
            "Cache-Control"
        ],
        "relatedCodes": [
            410
        ],
        "technicalNotes": "404 significa que el recurso no fue encontrado en la ubicación solicitada, pero no especifica si es temporal o permanente. Para eliminaciones permanentes conocidas, considera usar 410 Gone en su lugar. Por seguridad, 404 puede ser usado intencionalmente en lugar de 403 Forbidden para no revelar la existencia de recursos sensibles. Las páginas 404 deben incluir meta tag noindex para evitar que sean indexadas por motores de búsqueda. En APIs, siempre proporciona información estructurada sobre qué recurso no se encontró. Considera implementar logging de 404s para detectar enlaces rotos o problemas de integración.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712940/404_xr4mgz.png",
                "alt": "Imagen que representa el nombre del código 404 Not Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712638/29-removebg-preview_pml3fe.png",
                "alt": "Imagen del código 404 Not Found"
            }
        ]
    },
    {
        "code": 405,
        "status": "Method Not Allowed",
        "category": "Client Error",
        "description": "El código 405 Method Not Allowed indica que el servidor reconoce el método HTTP utilizado en la solicitud (GET, POST, PUT, DELETE, PATCH, etc.), pero ese método específico no está permitido para el recurso solicitado. Es crucial entender que esto es diferente de 404 Not Found: con 405, el recurso SÍ existe y fue encontrado, pero el método HTTP que estás intentando usar sobre ese recurso no está soportado o permitido. El servidor está diciendo: 'Conozco este recurso y existe, pero no puedes usar ese método HTTP en él'. Por ejemplo, si tienes un endpoint de API de solo lectura en /api/statistics, podrías permitir GET pero no POST, PUT o DELETE. Si un cliente intenta hacer POST a ese endpoint, recibiría 405. La respuesta 405 DEBE incluir un encabezado Allow que liste los métodos HTTP que SÍ son permitidos para ese recurso. Este encabezado es obligatorio según la especificación HTTP y proporciona información valiosa al cliente sobre cómo interactuar correctamente con el recurso. Por ejemplo: 'Allow: GET, HEAD, OPTIONS'. Las causas comunes de 405 incluyen: intentar usar POST en un endpoint que solo acepta GET, intentar modificar (PUT/PATCH) o eliminar (DELETE) un recurso de solo lectura, usar métodos no implementados en endpoints específicos, o violar restricciones de seguridad que permiten solo ciertos métodos. El código 405 es fundamental en el diseño de APIs RESTful donde diferentes recursos tienen diferentes conjuntos de operaciones permitidas. Por ejemplo, un endpoint de listado podría solo permitir GET, mientras que un endpoint de recurso individual podría permitir GET, PUT, PATCH, DELETE pero no POST. Es importante distinguir 405 de otros códigos: 404 significa que el recurso no existe; 403 significa que existe pero no tienes permiso; 405 significa que existe, puedes tener permiso, pero el método que intentas usar no es válido para este recurso. Las implementaciones bien diseñadas también responden correctamente a solicitudes OPTIONS, que son usadas por navegadores en CORS preflight para descubrir qué métodos están permitidos.",
        "useCases": [
            "Intentar POST en un endpoint de solo lectura que solo acepta GET",
            "Intentar DELETE en un recurso que no puede ser eliminado",
            "Intentar PUT/PATCH en un recurso inmutable o de solo lectura",
            "Usar métodos HTTP no implementados en endpoints específicos de API",
            "Intentar modificar recursos del sistema que son configurables solo por administradores",
            "Endpoints que solo permiten operaciones de consulta (GET) pero no modificaciones",
            "Recursos que solo permiten creación (POST) pero no actualizaciones individuales",
            "Violación de restricciones de diseño REST donde ciertos recursos solo soportan subconjuntos de métodos",
            "Intentar usar métodos HTTP personalizados o no estándar no soportados por el servidor"
        ],
        "examples": [
            {
                "scenario": "Intentar POST en endpoint de solo lectura",
                "request": "POST /api/statistics/daily-summary HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"date\": \"2024-01-16\",\n  \"views\": 5000\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"The POST method is not allowed for this resource\",\n  \"requested_method\": \"POST\",\n  \"requested_resource\": \"/api/statistics/daily-summary\",\n  \"allowed_methods\": [\"GET\", \"HEAD\", \"OPTIONS\"],\n  \"reason\": \"This is a read-only statistics endpoint. Data is automatically generated and cannot be manually posted.\",\n  \"alternatives\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"Retrieve daily statistics summary\",\n      \"example\": \"GET /api/statistics/daily-summary?date=2024-01-16\"\n    }\n  ],\n  \"documentation\": \"https://docs.analytics.example.com/api/statistics\"\n}",
                "explanation": "El endpoint de estadísticas es de solo lectura porque los datos son generados automáticamente por el sistema. El cliente intentó usar POST para crear datos manualmente, lo cual no está permitido. El encabezado Allow indica que solo GET, HEAD y OPTIONS son válidos."
            },
            {
                "scenario": "Intentar DELETE en recurso no eliminable",
                "request": "DELETE /api/system/configuration/core-settings HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, PUT, PATCH, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"DELETE method is not allowed on core system settings\",\n  \"requested_method\": \"DELETE\",\n  \"resource_type\": \"system_configuration\",\n  \"allowed_methods\": [\"GET\", \"PUT\", \"PATCH\", \"OPTIONS\"],\n  \"reason\": \"Core settings cannot be deleted as they are required for system operation. They can only be viewed or modified.\",\n  \"allowed_operations\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"View current core settings\"\n    },\n    {\n      \"method\": \"PUT\",\n      \"description\": \"Replace all core settings\"\n    },\n    {\n      \"method\": \"PATCH\",\n      \"description\": \"Update specific core settings\"\n    }\n  ],\n  \"warning\": \"Modifying core settings requires administrator privileges and can affect system stability\"\n}",
                "explanation": "Las configuraciones centrales del sistema no pueden ser eliminadas porque son esenciales para el funcionamiento del sistema. Solo pueden ser leídas o modificadas. El método DELETE no tiene sentido para este recurso."
            },
            {
                "scenario": "Intentar PUT en endpoint de colección que solo acepta POST",
                "request": "PUT /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"name\": \"New Product\",\n  \"price\": 29.99,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"PUT method is not allowed on the products collection endpoint\",\n  \"requested_method\": \"PUT\",\n  \"requested_resource\": \"/api/products\",\n  \"allowed_methods\": [\"GET\", \"POST\", \"HEAD\", \"OPTIONS\"],\n  \"explanation\": \"PUT is used to update specific resources, not collections. To create a new product, use POST. To update an existing product, use PUT on /api/products/{id}\",\n  \"correct_usage\": [\n    {\n      \"operation\": \"Create new product\",\n      \"method\": \"POST\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"POST /api/products with product data in body\"\n    },\n    {\n      \"operation\": \"Update existing product\",\n      \"method\": \"PUT\",\n      \"endpoint\": \"/api/products/{id}\",\n      \"example\": \"PUT /api/products/123 with updated product data\"\n    },\n    {\n      \"operation\": \"List all products\",\n      \"method\": \"GET\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"GET /api/products?page=1&limit=20\"\n    }\n  ]\n}",
                "explanation": "Según principios REST, PUT se usa en recursos individuales específicos, no en colecciones. Para crear un producto, debe usar POST en /api/products. Para actualizar un producto específico, debe usar PUT en /api/products/{id}."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.5",
        "relatedHeaders": [
            "Allow"
        ],
        "relatedCodes": [
            501
        ],
        "technicalNotes": "405 es diferente de 501 Not Implemented: 405 significa que el servidor soporta el método en general pero no para este recurso específico; 501 significa que el servidor no implementa ese método en absoluto. La respuesta 405 DEBE incluir el encabezado Allow listando los métodos permitidos. Este encabezado es obligatorio según RFC 7231. Las solicitudes OPTIONS deben ser manejadas apropiadamente para CORS preflight, respondiendo con los métodos permitidos. En diseño REST: colecciones típicamente permiten GET y POST; recursos individuales permiten GET, PUT, PATCH, DELETE. No confundir con 403 (tienes permiso pero no autorización) o 404 (recurso no existe).",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712942/405_iq06kt.png",
                "alt": "Imagen que representa el nombre del código 405 Method Not Allowed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712634/30-removebg-preview_mns9bp.png",
                "alt": "Imagen del código 405 Method Not Allowed"
            }
        ]
    },
    {
        "code": 406,
        "status": "Not Acceptable",
        "category": "Client Error",
        "description": "El código 406 Not Acceptable indica que el servidor no puede producir una respuesta que coincida con los criterios de aceptabilidad especificados en los encabezados de la solicitud del cliente, particularmente los encabezados Accept, Accept-Charset, Accept-Encoding, y Accept-Language. Este código es parte del mecanismo de negociación de contenido (content negotiation) en HTTP. Cuando un cliente envía una solicitud, puede especificar qué tipos de contenido acepta mediante estos encabezados. Por ejemplo, un cliente podría decir 'Accept: application/json' indicando que solo puede procesar respuestas en formato JSON. Si el servidor solo puede proporcionar el recurso en formato XML, debe responder con 406 indicando que no puede satisfacer los requisitos del cliente. El servidor está diciendo: 'Tengo el recurso que solicitaste, pero no puedo entregártelo en ninguno de los formatos que me dijiste que aceptas'. Es importante notar que 406 es relativamente raro en la práctica web moderna porque la mayoría de los servidores simplemente ignoran parcial o totalmente las preferencias del cliente cuando no pueden satisfacerlas, y envían una respuesta en un formato por defecto (usualmente con código 200). Sin embargo, en APIs estrictamente diseñadas y sistemas que implementan negociación de contenido rigurosa, 406 es la respuesta correcta cuando hay una incompatibilidad irreconciliable. Los escenarios incluyen: un cliente que solo acepta JSON pero el servidor solo produce XML, un cliente que requiere compresión gzip pero el servidor no la soporta, un cliente que solicita un idioma específico que no está disponible, o un cliente que requiere un conjunto de caracteres no soportado por el servidor. La respuesta 406 puede incluir una lista de las representaciones disponibles para ayudar al cliente a reformular su solicitud, aunque esto no es obligatorio. Es crucial distinguir 406 de 415 Unsupported Media Type: 415 se refiere al Content-Type que el cliente ENVÍA en el cuerpo de la solicitud, mientras que 406 se refiere a lo que el cliente especifica que puede ACEPTAR en la respuesta.",
        "useCases": [
            "Cliente solicita JSON pero servidor solo puede producir XML",
            "Cliente requiere codificación de caracteres no soportada por el servidor",
            "Cliente solicita idioma específico no disponible",
            "Cliente requiere compresión específica no implementada en servidor",
            "APIs estrictas donde formato de respuesta debe coincidir exactamente con Accept header",
            "Cliente especifica calidad de media type que servidor no puede satisfacer",
            "Negociación de contenido falla completamente sin formato común",
            "Cliente requiere nivel de detalle o versión de API no disponible"
        ],
        "examples": [
            {
                "scenario": "Cliente requiere JSON pero servidor solo produce XML",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAuthorization: Bearer valid_token",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"not_acceptable\",\n  \"message\": \"The requested resource cannot be provided in the requested format\",\n  \"requested_formats\": [\"application/json\"],\n  \"available_formats\": [\n    {\n      \"content_type\": \"application/xml\",\n      \"description\": \"XML representation\",\n      \"example_request\": \"Accept: application/xml\"\n    },\n    {\n      \"content_type\": \"text/xml\",\n      \"description\": \"Plain XML\",\n      \"example_request\": \"Accept: text/xml\"\n    }\n  ],\n  \"suggestion\": \"Please modify your Accept header to one of the available formats\",\n  \"documentation\": \"https://api.example.com/docs/content-negotiation\"\n}",
                "explanation": "El cliente especificó que solo acepta JSON (Accept: application/json), pero este servidor legacy solo puede producir XML. Como no hay un formato común, el servidor responde con 406 y lista los formatos disponibles."
            },
            {
                "scenario": "Idioma solicitado no disponible",
                "request": "GET /api/content/article-123 HTTP/1.1\nHost: content.example.com\nAccept: application/json\nAccept-Language: ja-JP",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\nContent-Language: en-US\n\n{\n  \"error\": \"language_not_available\",\n  \"message\": \"The requested content is not available in the requested language\",\n  \"requested_language\": \"ja-JP\",\n  \"available_languages\": [\n    {\n      \"code\": \"en-US\",\n      \"name\": \"English (United States)\",\n      \"is_default\": true\n    },\n    {\n      \"code\": \"es-ES\",\n      \"name\": \"Spanish (Spain)\"\n    },\n    {\n      \"code\": \"fr-FR\",\n      \"name\": \"French (France)\"\n    },\n    {\n      \"code\": \"de-DE\",\n      \"name\": \"German (Germany)\"\n    }\n  ],\n  \"suggestion\": \"Try requesting with Accept-Language: en-US, es-ES, fr-FR, or de-DE\",\n  \"note\": \"If no Accept-Language header is provided, content will be served in English (default)\"\n}",
                "explanation": "El cliente solicitó contenido en japonés (ja-JP), pero ese idioma no está disponible para este recurso. El servidor lista los idiomas disponibles para ayudar al cliente a hacer una solicitud válida."
            },
            {
                "scenario": "Codificación de caracteres no soportada",
                "request": "GET /api/legacy-data HTTP/1.1\nHost: api.example.com\nAccept: text/plain\nAccept-Charset: ISO-8859-1",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"charset_not_supported\",\n  \"message\": \"The requested character encoding is not supported\",\n  \"requested_charset\": \"ISO-8859-1\",\n  \"available_charsets\": [\n    {\n      \"charset\": \"UTF-8\",\n      \"description\": \"Unicode UTF-8 (recommended)\",\n      \"is_default\": true\n    },\n    {\n      \"charset\": \"UTF-16\",\n      \"description\": \"Unicode UTF-16\"\n    }\n  ],\n  \"recommendation\": \"Use Accept-Charset: UTF-8 or omit the header to receive UTF-8 by default\",\n  \"reason\": \"Modern APIs exclusively use Unicode encodings for better international character support\"\n}",
                "explanation": "El cliente solicitó codificación ISO-8859-1 (Latin-1), pero el servidor moderno solo soporta Unicode (UTF-8 y UTF-16). Se recomienda al cliente usar UTF-8 que es el estándar actual."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.6",
        "relatedHeaders": [
            "Accept",
            "Accept-Charset",
            "Accept-Encoding",
            "Accept-Language",
            "Content-Type"
        ],
        "relatedCodes": [
            415
        ],
        "technicalNotes": "406 se refiere a negociación de contenido proactiva basada en lo que el cliente puede ACEPTAR (headers Accept-*). No confundir con 415 Unsupported Media Type que se refiere al Content-Type que el cliente ENVÍA. En la práctica, 406 es raro porque muchos servidores ignoran parcialmente las preferencias del cliente y envían un formato por defecto con 200. Usar 406 indica una implementación estricta de content negotiation. La respuesta puede incluir lista de representaciones disponibles, aunque no es obligatorio. Si el servidor puede producir múltiples formatos pero ninguno coincide con Accept, debe responder 406, no elegir arbitrariamente uno.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712944/406_dlslce.png",
                "alt": "Imagen que representa el nombre del código 406 Not Acceptable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712632/31-removebg-preview_glqv2u.png",
                "alt": "Imagen del código 406 Not Acceptable"
            }
        ]
    },
    {
        "code": 407,
        "status": "Proxy Authentication Required",
        "category": "Client Error",
        "description": "El código 407 Proxy Authentication Required es similar al 401 Unauthorized, pero indica específicamente que el cliente debe autenticarse primero con un servidor proxy antes de que la solicitud pueda ser procesada. Este código es utilizado en escenarios donde la comunicación entre el cliente y el servidor final debe pasar a través de un proxy intermedio que requiere autenticación. El proxy está diciendo: 'Antes de que pueda reenviar tu solicitud al servidor de destino, necesitas autenticarte conmigo'. Esto es común en entornos corporativos donde todo el tráfico HTTP/HTTPS debe pasar por un proxy corporativo que implementa políticas de seguridad, filtrado de contenido, o logging. La respuesta 407 DEBE incluir un encabezado Proxy-Authenticate que especifica el esquema de autenticación que el proxy requiere, similar a cómo 401 usa WWW-Authenticate. Los esquemas comunes incluyen Basic, Digest, NTLM (en entornos Windows/Active Directory), o esquemas personalizados. Cuando un cliente recibe un 407, debe reenviar la solicitud incluyendo un encabezado Proxy-Authorization con las credenciales apropiadas para el proxy. Es importante distinguir entre autenticación de proxy (407) y autenticación de servidor final (401): puede haber escenarios donde ambas son necesarias, primero autenticándose con el proxy (407) y luego con el servidor de destino (401). El código 407 es transparente para muchas aplicaciones modernas porque los navegadores y librerías HTTP manejan automáticamente la autenticación de proxy usando credenciales configuradas a nivel de sistema operativo o aplicación. En entornos empresariales, es común que los administradores configuren credenciales de proxy a nivel de sistema para que todas las aplicaciones puedan usarlas automáticamente. Los proxies pueden requerir autenticación por varias razones: control de acceso y seguridad, rastreo de uso por usuario o departamento, implementación de políticas de uso aceptable, prevención de uso no autorizado de recursos de red, o cumplimiento de requisitos regulatorios. En APIs y aplicaciones server-to-server, manejar 407 correctamente es crucial para funcionar en entornos corporativos donde los proxies son obligatorios.",
        "useCases": [
            "Proxies corporativos que requieren autenticación de empleados",
            "Proxies de red que implementan control de acceso",
            "Proxies de filtrado de contenido en instituciones educativas",
            "Proxies que rastrean y registran uso de internet por usuario",
            "Proxies de caché que requieren identificación de usuarios",
            "Proxies que implementan políticas de uso aceptable",
            "Gateways de seguridad que validan identidad antes de permitir tráfico externo",
            "Proxies que aplican límites de ancho de banda por usuario autenticado"
        ],
        "examples": [
            {
                "scenario": "Proxy corporativo requiere autenticación Basic",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: Basic realm=\"Corporate Proxy\"\nProxy-Connection: close\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>Proxy Authentication Required</title></head>\n<body>\n  <h1>407 Proxy Authentication Required</h1>\n  <p>This request must be authenticated with the corporate proxy before it can be forwarded.</p>\n  <p>Please configure your application with valid proxy credentials.</p>\n  <p>Contact IT Support if you need assistance: support@company.com</p>\n</body>\n</html>",
                "explanation": "Un proxy corporativo interceptó la solicitud al servidor externo. Antes de reenviar la solicitud, requiere que el cliente se autentique usando credenciales corporativas con esquema Basic authentication. El cliente debe reenviar con encabezado Proxy-Authorization."
            },
            {
                "scenario": "Solicitud correcta con autenticación de proxy",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nProxy-Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nVia: 1.1 corporate-proxy.company.com\n\n{\n  \"message\": \"Request successfully forwarded through authenticated proxy\",\n  \"data\": {\n    \"user\": \"authenticated_user\",\n    \"proxy\": \"corporate-proxy.company.com\",\n    \"result\": \"success\"\n  }\n}",
                "explanation": "Después de recibir 407, el cliente reenvió la solicitud incluyendo el encabezado Proxy-Authorization con credenciales válidas. El proxy validó las credenciales y reenvió la solicitud al servidor de destino, que respondió exitosamente. El encabezado Via indica que pasó por el proxy."
            },
            {
                "scenario": "Proxy con autenticación NTLM (entorno Windows)",
                "request": "GET http://internet-resource.example.com/page HTTP/1.1\nHost: internet-resource.example.com",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: NTLM\nProxy-Authenticate: Negotiate\nContent-Type: application/json\n\n{\n  \"error\": \"proxy_authentication_required\",\n  \"message\": \"Authentication with the corporate proxy is required\",\n  \"proxy_server\": \"proxy.corporate.local\",\n  \"authentication_methods\": [\n    {\n      \"method\": \"NTLM\",\n      \"description\": \"Windows integrated authentication\",\n      \"automatic\": true,\n      \"note\": \"Your Windows credentials will be used automatically if configured\"\n    },\n    {\n      \"method\": \"Negotiate\",\n      \"description\": \"Kerberos/NTLM negotiation\",\n      \"automatic\": true\n    }\n  ],\n  \"help\": \"If automatic authentication fails, contact IT: it-support@corporate.local\",\n  \"documentation\": \"https://intranet.corporate.local/proxy-setup\"\n}",
                "explanation": "Un proxy en entorno Windows corporativo ofrece autenticación NTLM y Negotiate (Kerberos). Estos esquemas típicamente usan las credenciales de dominio del usuario de Windows automáticamente, sin requerir entrada manual de credenciales."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7235, Section 3.2",
        "relatedHeaders": [
            "Proxy-Authenticate",
            "Proxy-Authorization",
            "Via",
            "Proxy-Connection"
        ],
        "relatedCodes": [
            401
        ],
        "technicalNotes": "407 es específico para autenticación de PROXY, no del servidor final. Similar a como 401 requiere WWW-Authenticate, 407 DEBE incluir Proxy-Authenticate. El cliente responde con Proxy-Authorization (no Authorization). Es posible recibir tanto 407 como 401 en secuencia: primero autenticarse con proxy, luego con servidor destino. Los navegadores modernos manejan 407 automáticamente usando credenciales de proxy configuradas. En aplicaciones, las librerías HTTP típicamente soportan configuración de proxy con credenciales. NTLM y Negotiate son comunes en entornos Windows/Active Directory. El encabezado Via indica proxies por los que pasó la solicitud.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752638/407_wyw0bl.png",
                "alt": "Imagen que representa el nombre del código 407 Proxy Authentication Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752254/32-removebg-preview_ww1jb2.png",
                "alt": "Imagen del código 407 Proxy Authentication Required"
            }
        ]
    },
    {
        "code": 408,
        "status": "Request Timeout",
        "category": "Client Error",
        "description": "El código 408 Request Timeout indica que el servidor decidió cerrar la conexión porque el cliente no produjo una solicitud completa dentro del tiempo que el servidor estaba preparado para esperar. Este código se utiliza cuando un cliente establece una conexión con el servidor pero tarda demasiado tiempo en enviar la solicitud HTTP completa, o cuando hay períodos de inactividad prolongados durante la transmisión de la solicitud. El servidor está diciendo: 'Estableciste una conexión conmigo, pero tardaste demasiado en enviar tu solicitud completa, así que voy a cerrar la conexión'. Es importante entender que 408 se refiere al tiempo de espera durante la RECEPCIÓN de la solicitud, no durante el PROCESAMIENTO de la misma. Si el servidor recibe la solicitud completa pero tarda mucho en procesarla, eso sería un problema diferente (potencialmente 504 Gateway Timeout si hay un proxy/gateway involucrado). Las causas comunes de 408 incluyen: conexiones de red lentas o inestables donde los datos se transmiten muy lentamente, clientes que establecen conexiones pero no envían datos (posiblemente por bugs), problemas de firewall o proxy que interrumpen la transmisión de datos, clientes que pausan o se quedan en espera durante la construcción de la solicitud, o ataques de denegación de servicio de tipo slowloris donde los atacantes mantienen conexiones abiertas enviando datos muy lentamente para agotar recursos del servidor. Los servidores implementan timeouts de solicitud como mecanismo de seguridad y gestión de recursos para evitar que conexiones ociosas o lentas consuman recursos indefinidamente. Los valores típicos de timeout varían desde 30 segundos hasta varios minutos dependiendo de la configuración del servidor y el caso de uso. La respuesta 408 puede incluir un encabezado Connection: close indicando que el servidor está cerrando la conexión. Los clientes que reciben 408 pueden reintentar la solicitud, pero deberían investigar por qué la solicitud original fue tan lenta. En aplicaciones modernas, 408 es relativamente raro porque las redes y clientes son generalmente rápidos, pero puede ocurrir en conexiones móviles inestables, uploads de archivos grandes interrumpidos, o situaciones de red degradada.",
        "useCases": [
            "Cliente con conexión de red muy lenta que tarda demasiado en enviar solicitud",
            "Cliente que establece conexión pero no envía datos por bug o error de implementación",
            "Uploads de archivos grandes interrumpidos o extremadamente lentos",
            "Conexiones móviles inestables con pérdida de paquetes y retransmisiones",
            "Problemas de firewall o proxy que causan pausas prolongadas en transmisión",
            "Ataques slowloris u otros ataques de DoS basados en conexiones lentas",
            "Cliente que pausa durante construcción de payload muy grande",
            "Timeout de keep-alive en conexiones HTTP persistentes sin actividad"
        ],
        "examples": [
            {
                "scenario": "Cliente tarda demasiado en enviar solicitud completa",
                "request": "POST /api/upload HTTP/1.1\nHost: api.example.com\nContent-Type: multipart/form-data\nContent-Length: 104857600\n\n[cliente envía datos muy lentamente, solo 10% después de 60 segundos]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nContent-Type: application/json\n\n{\n  \"error\": \"request_timeout\",\n  \"message\": \"The server timed out waiting for the complete request\",\n  \"timeout_duration\": \"60 seconds\",\n  \"bytes_received\": 10485760,\n  \"bytes_expected\": 104857600,\n  \"percentage_received\": \"10%\",\n  \"reason\": \"Request transmission too slow or interrupted\",\n  \"suggestion\": \"Check your network connection and retry the upload\",\n  \"retry_recommended\": true,\n  \"max_upload_time\": \"300 seconds for files up to 100MB\"\n}",
                "explanation": "El cliente comenzó a subir un archivo de 100MB pero la transmisión fue extremadamente lenta. Después de 60 segundos, solo se recibió el 10% de los datos. El servidor cerró la conexión para liberar recursos. El cliente debe verificar su conexión y reintentar."
            },
            {
                "scenario": "Conexión establecida pero sin datos enviados",
                "request": "[TCP connection established]\n[30 seconds pass with no HTTP request sent]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>408 Request Timeout</title></head>\n<body>\n  <h1>408 Request Timeout</h1>\n  <p>The server closed this connection because no request was received within the expected time.</p>\n  <p>Connection was established but no data was sent for 30 seconds.</p>\n  <p>This may indicate a client-side error or network issue.</p>\n  <p>Please check your application and network connection.</p>\n</body>\n</html>",
                "explanation": "El cliente estableció una conexión TCP con el servidor pero no envió ninguna solicitud HTTP durante 30 segundos. Esto podría indicar un bug en el cliente, un problema de red, o un intento de ataque slowloris. El servidor cierra la conexión."
            },
            {
                "scenario": "Timeout de keep-alive en conexión persistente",
                "request": "[Previous request completed successfully]\n[HTTP persistent connection kept alive]\n[No new request for 120 seconds]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nKeep-Alive: timeout=120, max=100\nContent-Type: application/json\n\n{\n  \"error\": \"keepalive_timeout\",\n  \"message\": \"Persistent connection timed out due to inactivity\",\n  \"connection_type\": \"HTTP/1.1 persistent (keep-alive)\",\n  \"inactive_duration\": \"120 seconds\",\n  \"keepalive_timeout\": \"120 seconds\",\n  \"requests_on_connection\": 5,\n  \"max_requests_per_connection\": 100,\n  \"action\": \"Connection closed. Establish new connection for additional requests.\",\n  \"note\": \"This is normal behavior for idle persistent connections\"\n}",
                "explanation": "En una conexión HTTP/1.1 persistente (keep-alive), el cliente no envió una nueva solicitud durante 120 segundos después de la última respuesta. El servidor cierra la conexión idle para liberar recursos. El cliente puede establecer una nueva conexión si necesita hacer más solicitudes."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.7",
        "relatedHeaders": [
            "Connection",
            "Keep-Alive",
            "Timeout"
        ],
        "relatedCodes": [
            504
        ],
        "technicalNotes": "408 se refiere al timeout durante la RECEPCIÓN de la solicitud (cliente → servidor), no durante el procesamiento. No confundir con 504 Gateway Timeout que es para timeouts de servidor upstream durante procesamiento. La respuesta 408 típicamente incluye Connection: close porque el servidor está cerrando la conexión. Los clientes PUEDEN reintentar automáticamente solicitudes que reciben 408, pero deben implementar backoff exponencial. Los timeouts típicos varían: 30-60 segundos para solicitudes normales, 5-10 minutos para uploads grandes. Los servidores modernos configuran timeouts para: prevenir ataques DoS slowloris, liberar recursos de conexiones idle, optimizar uso de recursos. 408 es relativamente raro en aplicaciones web modernas con conexiones rápidas.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/408_w91uv5.png",
                "alt": "Imagen que representa el nombre del código 408 Request Timeout"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752253/33-removebg-preview_ogidrb.png",
                "alt": "Imagen del código 408 Request Timeout"
            }
        ]
    },
    {
        "code": 409,
        "status": "Conflict",
        "category": "Client Error",
        "description": "El código 409 Conflict indica que la solicitud no pudo ser completada debido a un conflicto con el estado actual del recurso en el servidor. Este código señala que existe una incompatibilidad o contradicción entre lo que el cliente está intentando hacer y el estado actual del sistema. El servidor está diciendo: 'Entiendo lo que quieres hacer, pero no puedo hacerlo porque entraría en conflicto con algo que ya existe o con el estado actual del sistema'. Los conflictos 409 son comunes en operaciones que implican concurrencia, unicidad, o restricciones de integridad de datos. Por ejemplo, intentar crear un usuario con un email que ya está registrado, intentar actualizar un recurso que ha sido modificado por otro usuario desde que lo recuperaste (conflicto de concurrencia), intentar eliminar un recurso que tiene dependencias, intentar reservar un recurso que ya está reservado, o violar restricciones de integridad referencial en bases de datos. El código 409 es fundamental en sistemas que implementan control de concurrencia optimista, donde múltiples clientes pueden intentar modificar el mismo recurso simultáneamente. En estos casos, 409 se usa típicamente con ETags o versionado: el cliente lee un recurso con su ETag actual, intenta actualizarlo enviando el ETag que leyó, pero si otro cliente modificó el recurso mientras tanto (cambiando el ETag), el servidor responde 409 indicando un conflicto de versión. La respuesta 409 debería incluir información suficiente en el cuerpo para que el cliente entienda la naturaleza del conflicto y potencialmente pueda resolverlo. Puede incluir detalles sobre qué causó el conflicto, el estado actual del recurso, y posibles acciones para resolver el conflicto. Es importante distinguir 409 de otros códigos: 400 es para errores de sintaxis o validación básica, 422 es para errores de validación semántica donde la sintaxis es correcta pero los datos no tienen sentido, y 409 es específicamente para conflictos con el estado actual del sistema. El 409 implica que la solicitud podría tener éxito en el futuro si el estado conflictivo cambia.",
        "useCases": [
            "Intentar crear usuario con email o username que ya existe",
            "Conflictos de concurrencia en actualizaciones simultáneas (violación de ETag/versión)",
            "Intentar eliminar recurso que tiene dependencias (foreign key constraints)",
            "Reservar recurso que ya está reservado por otro usuario",
            "Duplicación de transacciones o pedidos",
            "Intentar crear recurso con identificador único que ya existe",
            "Violación de reglas de negocio que dependen del estado actual",
            "Conflictos en sistemas de control de versiones o merge de datos",
            "Intentar aplicar cambios incompatibles con el estado actual del workflow"
        ],
        "examples": [
            {
                "scenario": "Email duplicado al crear usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 409 Conflict\nContent-Type: application/json\n\n{\n  \"error\": \"resource_conflict\",\n  \"message\": \"A user with this email address already exists\",\n  \"conflict_type\": \"duplicate_email\",\n  \"conflicting_field\": \"email\",\n  \"conflicting_value\": \"john@example.com\",\n  \"existing_user_id\": \"user_12345\",\n  \"created_at\": \"2023-06-15T10:30:00Z\",\n  \"suggestions\": [\n    \"Use a different email address\",\n    \"If this is your account, try logging in instead\",\n    \"Use the password reset feature if you forgot your password\"\n  ],\n  \"login_url\": \"/auth/login\",\n  \"password_reset_url\": \"/auth/forgot-password\"\n}",
                "explanation": "El cliente intentó crear un nuevo usuario con un email que ya está registrado en el sistema. Esto viola la restricción de unicidad del email. El servidor responde con 409 indicando el conflicto y sugiriendo acciones alternativas."
            },
            {
                "scenario": "Conflicto de concurrencia con ETag",
                "request": "PUT /api/documents/789 HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nIf-Match: \"version-abc123\"\n\n{\n  \"title\": \"Updated Title\",\n  \"content\": \"Updated content...\",\n  \"status\": \"published\"\n}",
                "response": "HTTP/1.1 409 Conflict\nETag: \"version-xyz789\"\nContent-Type: application/json\n\n{\n  \"error\": \"version_conflict\",\n  \"message\": \"The document has been modified by another user\",\n  \"conflict_type\": \"concurrent_modification\",\n  \"your_version\": \"version-abc123\",\n  \"current_version\": \"version-xyz789\",\n  \"last_modified_by\": \"user_456\",\n  \"last_modified_at\": \"2024-01-16T14:25:00Z\",\n  \"resolution_options\": [\n    {\n      \"option\": \"fetch_latest\",\n      \"description\": \"Get the latest version and manually merge your changes\",\n      \"endpoint\": \"GET /api/documents/789\"\n    },\n    {\n      \"option\": \"force_overwrite\",\n      \"description\": \"Overwrite with your version (will lose other user's changes)\",\n      \"warning\": \"This will discard changes made by user_456\",\n      \"not_recommended\": true\n    }\n  ],\n  \"current_document_url\": \"/api/documents/789\"\n}",
                "explanation": "El cliente intentó actualizar el documento usando un ETag antiguo (version-abc123). Otro usuario ya modificó el documento, cambiando el ETag a version-xyz789. Esto indica un conflicto de concurrencia. El cliente debe obtener la versión actual y decidir cómo resolver el conflicto."
            },
            {
                "scenario": "Eliminar recurso con dependencias",
                "request": "DELETE /api/categories/5 HTTP/1.1\nHost: shop.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 409 Conflict\nContent-Type: application/json\n\n{\n  \"error\": \"cannot_delete_resource\",\n  \"message\": \"Cannot delete category because it has dependent resources\",\n  \"conflict_type\": \"referential_integrity\",\n  \"category_id\": 5,\n  \"category_name\": \"Electronics\",\n  \"dependent_resources\": [\n    {\n      \"resource_type\": \"products\",\n      \"count\": 47,\n      \"description\": \"47 products are currently assigned to this category\"\n    },\n    {\n      \"resource_type\": \"subcategories\",\n      \"count\": 3,\n      \"description\": \"3 subcategories exist under this category\"\n    }\n  ],\n  \"resolution_steps\": [\n    \"1. Reassign all 47 products to different categories\",\n    \"2. Delete or reassign the 3 subcategories\",\n    \"3. Then retry deleting this category\"\n  ],\n  \"bulk_reassign_endpoint\": \"/api/categories/5/reassign-products\",\n  \"view_products_url\": \"/api/products?category=5\",\n  \"view_subcategories_url\": \"/api/categories?parent=5\"\n}",
                "explanation": "El administrador intentó eliminar una categoría, pero hay 47 productos y 3 subcategorías que dependen de ella. Eliminarla violaría la integridad referencial. El servidor responde con 409 y proporciona pasos claros para resolver el conflicto."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.8",
        "relatedHeaders": [
            "ETag",
            "If-Match",
            "If-None-Match"
        ],
        "relatedCodes": [
            400,
            422
        ],
        "technicalNotes": "409 es específicamente para conflictos con el ESTADO ACTUAL del recurso, no para errores de validación básica. Diferencias clave: 400 para errores de sintaxis/formato; 422 para validación semántica (datos bien formados pero no válidos); 409 para conflictos con estado existente. Común en control de concurrencia optimista usando ETags: el cliente incluye If-Match con el ETag que conoce, si cambió el servidor responde 409. La respuesta debe explicar claramente QUÉ está en conflicto y CÓMO resolverlo. 409 implica que la operación podría tener éxito si el estado conflictivo cambia. En REST, usar 409 para duplicados, violaciones de unicidad, y conflictos de concurrencia.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/409_wgclol.png",
                "alt": "Imagen que representa el nombre del código 409 Conflict"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752251/34-removebg-preview_caqa9i.png",
                "alt": "Imagen del código 409 Conflict"
            }
        ]
    },
    {
        "code": 410,
        "status": "Gone",
        "category": "Client Error",
        "description": "El código 410 Gone indica que el recurso solicitado ya no está disponible en el servidor y que esta condición es permanente, sin dirección de reenvío conocida. Este código es similar al 404 Not Found, pero proporciona información semántica adicional importante: 410 específicamente comunica que el recurso EXISTIÓ anteriormente pero ha sido INTENCIONALMENTE y PERMANENTEMENTE eliminado. El servidor está diciendo: 'Este recurso existía aquí antes, pero lo hemos eliminado deliberadamente y no volverá, y no hay una nueva ubicación para él'. La distinción clave entre 410 y 404 es: 404 significa 'no puedo encontrar esto' (puede que nunca haya existido, puede que haya sido movido, puede que sea temporal), mientras que 410 significa 'esto definitivamente existió aquí pero fue eliminado permanentemente de forma intencional'. El código 410 es útil para varias situaciones: contenido que fue publicado pero posteriormente retirado (artículos eliminados, productos descontinuados, páginas obsoletas), recursos que expiraron y fueron limpiados (cupones de descuento vencidos, promociones terminadas, enlaces de un solo uso consumidos), cuentas de usuario eliminadas permanentemente, o archivos que fueron removidos por violaciones de políticas. Usar 410 en lugar de 404 es beneficioso por varias razones: ayuda a los motores de búsqueda a entender que deben eliminar permanentemente la página de sus índices en lugar de seguir rastreándola esperando que regrese, informa a sistemas de caché que pueden purgar permanentemente el recurso, y proporciona mejor información a desarrolladores y usuarios sobre por qué el contenido no está disponible. Los motores de búsqueda como Google tratan 410 de manera diferente que 404: con 410, eliminan la URL de sus índices más rápidamente y dejan de rastrearla, mientras que con 404 pueden continuar verificando periódicamente si el recurso regresó. Sin embargo, en la práctica, 410 es mucho menos común que 404 porque requiere que el servidor mantenga un registro de qué recursos fueron eliminados, lo cual puede ser un overhead de mantenimiento. Muchos sitios simplemente usan 404 para todo lo que no existe, ya sea que nunca haya existido o haya sido eliminado.",
        "useCases": [
            "Artículos de blog o contenido que fue publicado pero posteriormente eliminado permanentemente",
            "Productos descontinuados en tiendas online que ya no se venderán",
            "Cuentas de usuario que fueron eliminadas permanentemente por solicitud del usuario",
            "Cupones de descuento o códigos promocionales que expiraron",
            "Enlaces de un solo uso que ya fueron consumidos (tokens de verificación, invitaciones)",
            "Contenido removido por violaciones de términos de servicio o derechos de autor",
            "Páginas web obsoletas que fueron retiradas intencionalmente sin reemplazo",
            "Recursos temporales que cumplieron su propósito y fueron limpiados",
            "Archivos subidos que fueron eliminados por el usuario propietario"
        ],
        "examples": [
            {
                "scenario": "Producto descontinuado permanentemente",
                "request": "GET /products/vintage-model-2015 HTTP/1.1\nHost: shop.example.com\nAccept: application/json",
                "response": "HTTP/1.1 410 Gone\nContent-Type: application/json\n\n{\n  \"error\": \"resource_gone\",\n  \"message\": \"This product has been permanently discontinued\",\n  \"resource_type\": \"product\",\n  \"product_id\": \"vintage-model-2015\",\n  \"product_name\": \"Vintage Model 2015\",\n  \"discontinued_date\": \"2023-12-31\",\n  \"reason\": \"Product line discontinued\",\n  \"status\": \"permanently_removed\",\n  \"alternatives\": [\n    {\n      \"product_id\": \"modern-model-2024\",\n      \"name\": \"Modern Model 2024\",\n      \"description\": \"Updated version with new features\",\n      \"url\": \"/products/modern-model-2024\"\n    },\n    {\n      \"product_id\": \"similar-alternative\",\n      \"name\": \"Similar Alternative\",\n      \"description\": \"Comparable product in same category\",\n      \"url\": \"/products/similar-alternative\"\n    }\n  ],\n  \"browse_category\": \"/categories/electronics\",\n  \"note\": \"This product will not return. Consider our alternatives above.\"\n}",
                "explanation": "El producto fue descontinuado permanentemente y no volverá a estar disponible. El código 410 informa a motores de búsqueda que deben eliminar esta URL de sus índices. Se proporcionan productos alternativos para ayudar al usuario."
            },
            {
                "scenario": "Artículo de blog eliminado permanentemente",
                "request": "GET /blog/2020/controversial-article HTTP/1.1\nHost: blog.example.com\nAccept: text/html",
                "response": "HTTP/1.1 410 Gone\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Article Removed - Example Blog</title>\n  <meta name=\"robots\" content=\"noindex, nofollow\">\n</head>\n<body>\n  <h1>410 - Article No Longer Available</h1>\n  <p>The article you're looking for has been permanently removed.</p>\n  <div class=\"info\">\n    <h2>Why was this removed?</h2>\n    <p>This article was removed on January 15, 2024 due to outdated information that could be misleading.</p>\n    <p>We maintain high standards for content accuracy and decided to remove this rather than update it.</p>\n  </div>\n  <div class=\"alternatives\">\n    <h2>You might be interested in:</h2>\n    <ul>\n      <li><a href=\"/blog/2024/updated-perspective\">Updated Perspective on the Topic (2024)</a></li>\n      <li><a href=\"/blog/category/same-topic\">More articles on this topic</a></li>\n      <li><a href=\"/blog\">Browse all blog posts</a></li>\n    </ul>\n  </div>\n</body>\n</html>",
                "explanation": "El artículo fue removido permanentemente por contener información desactualizada. El código 410 asegura que los motores de búsqueda eliminen la página de sus índices. Se incluye meta noindex y se ofrecen alternativas relevantes."
            },
            {
                "scenario": "Token de verificación de un solo uso ya consumido",
                "request": "GET /verify-email?token=abc123xyz789used HTTP/1.1\nHost: auth.example.com",
                "response": "HTTP/1.1 410 Gone\nContent-Type: application/json\n\n{\n  \"error\": \"token_consumed\",\n  \"message\": \"This verification token has already been used\",\n  \"token_type\": \"email_verification\",\n  \"token_status\": \"consumed\",\n  \"used_at\": \"2024-01-10T09:30:00Z\",\n  \"used_by_ip\": \"192.168.1.100\",\n  \"email_status\": \"verified\",\n  \"account_email\": \"user@example.com\",\n  \"action_taken\": \"Email was successfully verified on January 10, 2024\",\n  \"next_steps\": [\n    \"Your email is already verified\",\n    \"You can now log in to your account\",\n    \"If you didn't verify this email, contact support immediately\"\n  ],\n  \"login_url\": \"/auth/login\",\n  \"support_url\": \"/support/contact\"\n}",
                "explanation": "El token de verificación de email era de un solo uso y ya fue consumido el 10 de enero. No puede ser reutilizado. El código 410 indica que este token específico está permanentemente agotado. Se proporciona información sobre cuándo fue usado y qué hacer a continuación."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.9",
        "relatedHeaders": [
            "Content-Type",
            "Cache-Control"
        ],
        "relatedCodes": [
            404
        ],
        "technicalNotes": "410 es semánticamente diferente de 404: 410 significa eliminación PERMANENTE e INTENCIONAL de algo que existió; 404 es más genérico y no implica historia. Usar 410 beneficia SEO: los motores de búsqueda eliminan URLs con 410 de índices más rápido y dejan de rastrearlas. 410 es menos común que 404 en la práctica porque requiere que el servidor mantenga registro de recursos eliminados. Si no mantienes registro de qué fue eliminado, usa 404. Para redirecciones permanentes a nuevas ubicaciones, usa 301 no 410. 410 implica que NO hay nueva ubicación. Incluye meta tag noindex en respuestas HTML. La respuesta puede cacheable a menos que se indique lo contrario.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/410_dhmn6m.png",
                "alt": "Imagen que representa el nombre del código 410 Gone"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752248/35-removebg-preview_h8zeav.png",
                "alt": "Imagen del código 410 Gone"
            }
        ]
    },
    {
        "code": 411,
        "status": "Length Required",
        "category": "Client Error",
        "description": "El código 411 Length Required indica que el servidor se niega a aceptar la solicitud sin un encabezado Content-Length definido. Este código se utiliza cuando el servidor requiere conocer el tamaño exacto del cuerpo de la solicitud antes de comenzar a procesarla, pero el cliente no proporcionó el encabezado Content-Length. El servidor está diciendo: 'Necesito saber cuántos bytes de datos vas a enviarme antes de que pueda aceptar tu solicitud'. Este requisito es importante por varias razones: permite al servidor validar que tiene suficiente espacio o recursos para manejar la solicitud completa antes de comenzar a recibirla, ayuda a prevenir ataques de denegación de servicio donde un atacante podría enviar datos infinitos, permite implementar límites de tamaño de carga apropiados, y facilita la gestión eficiente de recursos del servidor. El código 411 es común en situaciones donde el servidor necesita asignar buffers o recursos basándose en el tamaño de la solicitud, cuando implementa límites de cuota o facturación basada en volumen de datos, o cuando necesita validar restricciones de tamaño antes de procesar. Sin embargo, es importante notar que HTTP/1.1 también soporta Transfer-Encoding: chunked, que permite enviar datos sin conocer la longitud total de antemano. Algunos servidores aceptan chunked encoding como alternativa a Content-Length, pero otros requieren específicamente Content-Length y responderán con 411 si no está presente. En HTTP/2, el concepto de Content-Length es menos crítico debido a la naturaleza del protocolo, pero en HTTP/1.1 sigue siendo relevante. Las causas comunes de 411 incluyen: clientes que intentan hacer POST o PUT sin especificar Content-Length, uso de streaming o chunked encoding cuando el servidor no lo soporta, bugs en implementaciones de cliente que omiten el encabezado, o proxies que eliminan el encabezado Content-Length durante el tránsito. La solución típica es que el cliente incluya el encabezado Content-Length con el número exacto de bytes en el cuerpo de la solicitud.",
        "useCases": [
            "Servidor que requiere Content-Length para validar límites de tamaño antes de aceptar uploads",
            "APIs que implementan cuotas o facturación basada en volumen de datos",
            "Servidores que necesitan pre-asignar buffers basándose en tamaño de solicitud",
            "Sistemas que validan capacidad de almacenamiento antes de aceptar datos",
            "Prevención de ataques DoS de streaming infinito de datos",
            "Servicios que requieren conocer tamaño total para operaciones transaccionales",
            "Sistemas legacy que no soportan Transfer-Encoding: chunked",
            "Validación de límites de recursos antes de procesamiento"
        ],
        "examples": [
            {
                "scenario": "POST sin Content-Length",
                "request": "POST /api/upload HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"data\": \"some content\"\n}",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"length_required\",\n  \"message\": \"Content-Length header is required for this request\",\n  \"missing_header\": \"Content-Length\",\n  \"reason\": \"Server must know the size of the request body before processing\",\n  \"requirements\": {\n    \"header_name\": \"Content-Length\",\n    \"header_value\": \"Size in bytes of the request body\",\n    \"example\": \"Content-Length: 1024\"\n  },\n  \"max_content_length\": 10485760,\n  \"max_content_length_human\": \"10 MB\",\n  \"supported_encodings\": [\"identity\"],\n  \"chunked_encoding_supported\": false,\n  \"how_to_fix\": [\n    \"Calculate the exact size of your request body in bytes\",\n    \"Add Content-Length header with that value\",\n    \"Example: Content-Length: 27 (for the JSON body shown)\"\n  ],\n  \"documentation\": \"https://api.example.com/docs/headers\"\n}",
                "explanation": "El cliente envió una solicitud POST con un cuerpo JSON pero omitió el encabezado Content-Length. El servidor requiere este encabezado para validar el tamaño antes de procesar. El cliente debe calcular el tamaño del cuerpo (27 bytes en este caso) y agregar Content-Length: 27."
            },
            {
                "scenario": "Upload de archivo sin especificar tamaño",
                "request": "PUT /api/files/document.pdf HTTP/1.1\nHost: storage.example.com\nContent-Type: application/pdf\nAuthorization: Bearer valid_token\n\n[binary PDF data without Content-Length]",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"content_length_required\",\n  \"message\": \"File uploads require Content-Length header\",\n  \"resource\": \"/api/files/document.pdf\",\n  \"operation\": \"file_upload\",\n  \"reason\": \"Server must validate available storage space before accepting upload\",\n  \"requirements\": {\n    \"required_headers\": [\n      \"Content-Length\",\n      \"Content-Type\"\n    ],\n    \"example_request\": \"PUT /api/files/document.pdf\\nContent-Type: application/pdf\\nContent-Length: 2048576\\n\\n[file data]\"\n  },\n  \"storage_limits\": {\n    \"max_file_size\": 104857600,\n    \"max_file_size_human\": \"100 MB\",\n    \"current_quota_used\": \"45%\",\n    \"available_space\": 57671680,\n    \"available_space_human\": \"55 MB\"\n  },\n  \"note\": \"Content-Length allows us to verify sufficient storage before accepting your file\"\n}",
                "explanation": "El cliente intenta subir un archivo PDF pero no especificó Content-Length. El servidor necesita este valor para verificar que tiene suficiente espacio de almacenamiento disponible antes de comenzar a recibir el archivo potencialmente grande."
            },
            {
                "scenario": "Solicitud con chunked encoding en servidor que no lo soporta",
                "request": "POST /api/data HTTP/1.1\nHost: legacy.example.com\nTransfer-Encoding: chunked\nContent-Type: application/json\n\n5\n{\"da\n2\nta\n3\n\":1\n2\n}\n\n0\n\n",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"content_length_required\",\n  \"message\": \"This server does not support chunked transfer encoding\",\n  \"received_encoding\": \"chunked\",\n  \"supported_encodings\": [\"identity\"],\n  \"required_header\": \"Content-Length\",\n  \"explanation\": \"This is a legacy server that requires Content-Length and does not support streaming uploads\",\n  \"solution\": [\n    \"Calculate the total size of your data before sending\",\n    \"Remove Transfer-Encoding: chunked header\",\n    \"Add Content-Length header with the exact byte count\",\n    \"Send the data in a single request body\"\n  ],\n  \"example_correct_request\": \"POST /api/data HTTP/1.1\\nContent-Type: application/json\\nContent-Length: 10\\n\\n{\\\"data\\\":1}\",\n  \"modernization_note\": \"Consider upgrading to our v2 API which supports chunked encoding: https://api-v2.example.com\"\n}",
                "explanation": "El cliente intentó usar Transfer-Encoding: chunked para enviar datos sin conocer la longitud total de antemano. Sin embargo, este servidor legacy no soporta chunked encoding y requiere específicamente el encabezado Content-Length."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.10",
        "relatedHeaders": [
            "Content-Length",
            "Transfer-Encoding"
        ],
        "relatedCodes": [
            413
        ],
        "technicalNotes": "411 requiere específicamente el encabezado Content-Length. Algunos servidores aceptan Transfer-Encoding: chunked como alternativa, pero otros no. La respuesta 411 indica que el servidor REQUIERE Content-Length. HTTP/1.1 soporta chunked encoding como alternativa donde la longitud no se conoce de antemano, pero no todos los servidores lo implementan. La diferencia con 413 Payload Too Large: 413 se usa cuando Content-Length ESTÁ presente pero el valor excede el límite; 411 se usa cuando Content-Length está AUSENTE. Para calcular Content-Length: contar bytes exactos del cuerpo de la solicitud (no caracteres, bytes). En HTTP/2, los conceptos de streaming son diferentes y 411 es menos relevante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/411_mkptuj.png",
                "alt": "Imagen que representa el nombre del código 411 Length Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752246/36-removebg-preview_h9lidy.png",
                "alt": "Imagen del código 411 Length Required"
            }
        ]
    },
    {
        "code": 412,
        "status": "Precondition Failed",
        "category": "Client Error",
        "description": "El código 412 Precondition Failed indica que una o más condiciones especificadas en los encabezados de solicitud del cliente fueron evaluadas como falsas cuando fueron probadas en el servidor. Este código es fundamental para implementar control de concurrencia condicional y operaciones seguras sobre recursos. Los encabezados de precondición permiten que los clientes especifiquen condiciones que deben cumplirse para que la solicitud sea procesada. Si alguna de estas condiciones falla, el servidor responde con 412 sin realizar la operación solicitada. Los encabezados de precondición más comunes son: If-Match (la operación solo debe proceder si el ETag actual del recurso coincide con el valor especificado), If-None-Match (proceder solo si el ETag NO coincide), If-Modified-Since (proceder solo si el recurso fue modificado después de la fecha especificada), If-Unmodified-Since (proceder solo si el recurso NO fue modificado desde la fecha especificada), y If-Range (para solicitudes de rango condicionales). El código 412 es especialmente importante en el control de concurrencia optimista, donde múltiples clientes pueden leer un recurso, pero solo uno debería poder modificarlo basándose en la versión que leyó. Por ejemplo: Cliente A lee un documento con ETag 'v1', Cliente B lee el mismo documento con ETag 'v1', Cliente B actualiza el documento (ETag cambia a 'v2'), Cliente A intenta actualizar enviando If-Match: 'v1', el servidor detecta que el ETag actual es 'v2' y responde 412 Precondition Failed, indicando que el documento cambió desde que Cliente A lo leyó. Esto previene que Cliente A sobrescriba inadvertidamente los cambios de Cliente B. El código 412 también es usado en operaciones de eliminación condicional (solo eliminar si el recurso no ha sido modificado), actualizaciones parciales con PATCH (solo aplicar cambios si la versión base es la esperada), y operaciones de caché condicionales. Es importante distinguir 412 de otros códigos: 409 Conflict se usa cuando hay un conflicto con el estado del recurso pero no necesariamente relacionado con precondiciones de encabezados; 428 Precondition Required se usa cuando el servidor REQUIERE una precondición pero el cliente no proporcionó ninguna; 412 se usa cuando el cliente SÍ proporcionó una precondición pero FALLÓ la evaluación.",
        "useCases": [
            "Control de concurrencia optimista con ETags en actualizaciones",
            "Prevenir sobrescritura de cambios concurrentes en edición colaborativa",
            "Validación de versión antes de aplicar actualizaciones o parches",
            "Operaciones condicionales que solo deben ejecutarse si el recurso no cambió",
            "Eliminación segura solo si el recurso está en el estado esperado",
            "Caché condicional basado en fechas de modificación",
            "Prevenir race conditions en operaciones críticas",
            "Validación de que prerequisitos se cumplen antes de operaciones complejas"
        ],
        "examples": [
            {
                "scenario": "Control de concurrencia con If-Match fallido",
                "request": "PUT /api/documents/456 HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nIf-Match: \"version-abc123\"\nAuthorization: Bearer valid_token\n\n{\n  \"title\": \"Updated Document Title\",\n  \"content\": \"My updated content...\",\n  \"status\": \"published\"\n}",
                "response": "HTTP/1.1 412 Precondition Failed\nETag: \"version-xyz789\"\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_failed\",\n  \"message\": \"The resource has been modified since you last retrieved it\",\n  \"precondition_type\": \"if_match\",\n  \"your_etag\": \"version-abc123\",\n  \"current_etag\": \"version-xyz789\",\n  \"last_modified\": \"2024-01-16T15:30:00Z\",\n  \"last_modified_by\": \"user_789\",\n  \"explanation\": \"Another user modified this document after you retrieved it. Your changes cannot be applied to avoid overwriting their work.\",\n  \"resolution_options\": [\n    {\n      \"option\": \"fetch_and_merge\",\n      \"description\": \"Retrieve the latest version and manually merge your changes\",\n      \"recommended\": true,\n      \"action\": \"GET /api/documents/456\"\n    },\n    {\n      \"option\": \"force_update\",\n      \"description\": \"Force your update and overwrite recent changes\",\n      \"warning\": \"This will discard changes made by user_789\",\n      \"action\": \"PUT /api/documents/456 without If-Match header\",\n      \"recommended\": false\n    }\n  ],\n  \"current_version_url\": \"/api/documents/456\"\n}",
                "explanation": "El cliente intentó actualizar el documento usando If-Match con un ETag antiguo (version-abc123). El ETag actual es version-xyz789, lo que significa que otro usuario modificó el documento. La precondición falló y el servidor responde 412 para prevenir sobrescritura accidental."
            },
            {
                "scenario": "If-Unmodified-Since fallido en DELETE",
                "request": "DELETE /api/posts/789 HTTP/1.1\nHost: blog.example.com\nIf-Unmodified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 412 Precondition Failed\nLast-Modified: Tue, 16 Jan 2024 14:20:00 GMT\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_failed\",\n  \"message\": \"The post has been modified since the specified date\",\n  \"precondition_type\": \"if_unmodified_since\",\n  \"your_date\": \"2024-01-15T10:00:00Z\",\n  \"last_modified_date\": \"2024-01-16T14:20:00Z\",\n  \"post_id\": 789,\n  \"post_title\": \"Important Announcement\",\n  \"modified_by\": \"editor_user_456\",\n  \"changes_made\": \"Content updated with critical corrections\",\n  \"explanation\": \"This post was modified after the date you specified. Deletion cannot proceed to prevent loss of recent updates.\",\n  \"next_steps\": [\n    \"Review the current version of the post\",\n    \"Verify that deletion is still appropriate given recent changes\",\n    \"If deletion is still desired, retry without the If-Unmodified-Since header or with the current Last-Modified date\"\n  ],\n  \"view_current_post\": \"/api/posts/789\"\n}",
                "explanation": "El administrador intentó eliminar un post solo si no había sido modificado desde el 15 de enero. Sin embargo, el post fue modificado el 16 de enero. La precondición If-Unmodified-Since falló, y el servidor responde 412 para prevenir eliminación accidental de contenido actualizado."
            },
            {
                "scenario": "If-None-Match fallido (recurso no cambió)",
                "request": "GET /api/data/statistics HTTP/1.1\nHost: api.example.com\nIf-None-Match: \"stats-current-etag-xyz\"\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nETag: \"stats-current-etag-xyz\"\nCache-Control: private, max-age=300\n\nNOTA: Este escenario NO resulta en 412, sino en 304 Not Modified.\nIf-None-Match con GET típicamente resulta en 304 cuando coincide.\n412 se usa principalmente con métodos de modificación (PUT, PATCH, DELETE, POST).",
                "explanation": "ACLARACIÓN IMPORTANTE: Con métodos seguros como GET, If-None-Match que coincide resulta en 304 Not Modified, no 412. El código 412 se usa principalmente cuando precondiciones fallan en métodos de modificación (PUT, PATCH, DELETE)."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7232, Section 4.2",
        "relatedHeaders": [
            "If-Match",
            "If-None-Match",
            "If-Modified-Since",
            "If-Unmodified-Since",
            "If-Range",
            "ETag",
            "Last-Modified"
        ],
        "relatedCodes": [
            304,
            409,
            428
        ],
        "technicalNotes": "412 indica que una PRECONDICIÓN proporcionada FALLÓ. Diferencias clave: 304 Not Modified se usa con GET cuando If-None-Match/If-Modified-Since indica que el recurso no cambió (esto es éxito, no error); 412 se usa principalmente con métodos de modificación cuando la precondición falla; 409 Conflict es para conflictos de estado no relacionados con precondiciones de encabezados; 428 Precondition Required es cuando el servidor REQUIERE una precondición pero no se proporcionó. Los encabezados If-Match e If-Unmodified-Since se usan para control de concurrencia optimista. 412 previene el 'lost update problem' donde actualizaciones concurrentes se sobrescriben. La respuesta debe incluir el ETag o Last-Modified actual para que el cliente pueda recuperar la versión actual.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/412_ewudq7.png",
                "alt": "Imagen que representa el nombre del código 412 Precondition Failed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752245/37-removebg-preview_zvinwn.png",
                "alt": "Imagen del código 412 Precondition Failed"
            }
        ]
    },
    {
        "code": 413,
        "status": "Payload Too Large",
        "category": "Client Error",
        "description": "El código 413 Payload Too Large (anteriormente conocido como 'Request Entity Too Large' en HTTP/1.1) indica que el servidor se niega a procesar la solicitud porque el cuerpo de la solicitud (payload) es más grande que los límites que el servidor está dispuesto o es capaz de procesar. El servidor está diciendo: 'Los datos que estás intentando enviarme son demasiado grandes, exceden mis límites configurados'. Este código es fundamental para la gestión de recursos del servidor y la prevención de abusos. Los servidores implementan límites de tamaño de payload por varias razones: prevenir ataques de denegación de servicio (DoS) donde atacantes intentan agotar memoria o almacenamiento del servidor con payloads enormes, gestionar eficientemente los recursos de memoria y almacenamiento, implementar límites de cuota por usuario o plan de suscripción, proteger contra uploads accidentales de archivos excesivamente grandes, y mantener tiempos de respuesta razonables. Los límites pueden aplicarse a diferentes aspectos: tamaño total del cuerpo de la solicitud, tamaño de archivos individuales en uploads multipart, tamaño de campos específicos en formularios, o límites agregados por periodo de tiempo. La respuesta 413 puede incluir un encabezado Retry-After si la condición es temporal (por ejemplo, el usuario ha excedido su cuota mensual pero puede reintentar el próximo mes), aunque esto es menos común. Es importante distinguir 413 de otros códigos relacionados con tamaño: 411 Length Required se usa cuando falta el encabezado Content-Length, mientras que 413 se usa cuando Content-Length ESTÁ presente pero el valor excede el límite permitido. Los límites típicos varían ampliamente según el tipo de servidor y aplicación: servidores web pueden limitar requests a 1-10MB por defecto, servicios de upload de archivos pueden permitir 100MB-5GB, APIs pueden limitar payloads JSON a 1-16MB, y servicios de email pueden limitar adjuntos a 25-50MB. Cuando un cliente recibe 413, las opciones incluyen: reducir el tamaño de los datos (comprimir, optimizar), dividir la carga en múltiples requests más pequeños, o actualizar a un plan de servicio con límites mayores si es una restricción de cuota.",
        "useCases": [
            "Upload de archivos que exceden el tamaño máximo permitido",
            "Solicitudes POST/PUT con payloads JSON o XML demasiado grandes",
            "Envío de formularios con datos que exceden límites configurados",
            "Uploads de imágenes o videos que superan restricciones de tamaño",
            "Requests que exceden cuotas de usuario o plan de suscripción",
            "Payloads que excederían capacidad de memoria o almacenamiento del servidor",
            "Múltiples archivos en upload multipart que exceden límite agregado",
            "Prevención de ataques DoS con payloads excesivamente grandes"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo que excede límite",
                "request": "POST /api/upload HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data\nContent-Length: 524288000\nAuthorization: Bearer valid_token\n\n[500MB de datos de archivo]",
                "response": "HTTP/1.1 413 Payload Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"payload_too_large\",\n  \"message\": \"The uploaded file exceeds the maximum allowed size\",\n  \"request_size\": 524288000,\n  \"request_size_human\": \"500 MB\",\n  \"max_size\": 104857600,\n  \"max_size_human\": \"100 MB\",\n  \"size_exceeded_by\": 419430400,\n  \"size_exceeded_by_human\": \"400 MB\",\n  \"user_plan\": \"free\",\n  \"plan_limits\": {\n    \"free\": \"100 MB per file\",\n    \"basic\": \"500 MB per file\",\n    \"premium\": \"5 GB per file\",\n    \"enterprise\": \"50 GB per file\"\n  },\n  \"suggestions\": [\n    \"Compress the file before uploading\",\n    \"Split the file into smaller chunks\",\n    \"Upgrade to Basic plan for 500 MB limit\",\n    \"Use our chunked upload API for files larger than 100 MB\"\n  ],\n  \"upgrade_url\": \"https://billing.example.com/upgrade\",\n  \"chunked_upload_docs\": \"https://docs.example.com/api/chunked-upload\"\n}",
                "explanation": "El cliente intentó subir un archivo de 500MB, pero el límite del plan gratuito es 100MB. El servidor rechaza la solicitud con 413 y proporciona información sobre límites de diferentes planes y alternativas como compresión o upload por chunks."
            },
            {
                "scenario": "Payload JSON demasiado grande en API",
                "request": "POST /api/bulk-import HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 16777216\nAuthorization: Bearer valid_token\n\n{\n  \"items\": [\n    ... 100,000 items de datos ...\n  ]\n}",
                "response": "HTTP/1.1 413 Payload Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"request_body_too_large\",\n  \"message\": \"Request body exceeds maximum allowed size for this endpoint\",\n  \"payload_size\": 16777216,\n  \"payload_size_human\": \"16 MB\",\n  \"max_allowed\": 5242880,\n  \"max_allowed_human\": \"5 MB\",\n  \"endpoint\": \"/api/bulk-import\",\n  \"items_in_request\": 100000,\n  \"recommended_batch_size\": 1000,\n  \"explanation\": \"Large bulk imports should be split into smaller batches to ensure reliability and performance\",\n  \"alternatives\": [\n    {\n      \"method\": \"batch_processing\",\n      \"description\": \"Split into batches of 1,000 items each\",\n      \"endpoint\": \"/api/bulk-import\",\n      \"max_items_per_batch\": 1000,\n      \"example\": \"Send 100 requests with 1,000 items each\"\n    },\n    {\n      \"method\": \"file_upload\",\n      \"description\": \"Upload CSV or JSON file for async processing\",\n      \"endpoint\": \"/api/bulk-import/file\",\n      \"max_file_size\": \"100 MB\",\n      \"format\": \"CSV or JSON\"\n    }\n  ],\n  \"documentation\": \"https://docs.example.com/api/bulk-operations\"\n}",
                "explanation": "El cliente intentó importar 100,000 items en una sola solicitud de 16MB, excediendo el límite de 5MB para este endpoint. Se sugiere dividir en lotes de 1,000 items o usar el endpoint de upload de archivo para procesamiento asíncrono."
            },
            {
                "scenario": "Límite de cuota mensual excedido",
                "request": "POST /api/data-processing HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 2097152\n\n[2MB de datos para procesamiento]",
                "response": "HTTP/1.1 413 Payload Too Large\nRetry-After: 1209600\nX-RateLimit-Limit: 104857600\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1709251200\nContent-Type: application/json\n\n{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"Monthly data processing quota has been exceeded\",\n  \"request_size\": 2097152,\n  \"request_size_human\": \"2 MB\",\n  \"quota_type\": \"monthly_processing\",\n  \"quota_limit\": 104857600,\n  \"quota_limit_human\": \"100 MB per month\",\n  \"quota_used\": 104857600,\n  \"quota_used_human\": \"100 MB\",\n  \"quota_remaining\": 0,\n  \"quota_reset_date\": \"2024-03-01T00:00:00Z\",\n  \"days_until_reset\": 14,\n  \"current_plan\": \"starter\",\n  \"plan_options\": [\n    {\n      \"plan\": \"professional\",\n      \"quota\": \"1 GB per month\",\n      \"price\": \"$29.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/professional\"\n    },\n    {\n      \"plan\": \"business\",\n      \"quota\": \"10 GB per month\",\n      \"price\": \"$99.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/business\"\n    }\n  ],\n  \"suggestions\": [\n    \"Wait 14 days for quota to reset on March 1st\",\n    \"Upgrade to a higher plan for increased quota\",\n    \"Optimize data to reduce processing size\"\n  ]\n}",
                "explanation": "El usuario ha consumido toda su cuota mensual de procesamiento de datos (100MB). Aunque la solicitud individual de 2MB es pequeña, no puede procesarse porque excedería la cuota del periodo. El encabezado Retry-After indica que puede reintentar en 14 días cuando se resetee la cuota."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.11",
        "relatedHeaders": [
            "Content-Length",
            "Retry-After",
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining"
        ],
        "relatedCodes": [
            411
        ],
        "technicalNotes": "413 se usa cuando el payload EXCEDE un límite, mientras que 411 Length Required se usa cuando falta el encabezado Content-Length. El nombre cambió de 'Request Entity Too Large' a 'Payload Too Large' en especificaciones recientes para mayor claridad. La respuesta puede incluir Retry-After si la condición es temporal (cuotas por periodo). Los límites pueden ser: por solicitud individual, agregados por periodo de tiempo, por usuario/plan, o por tipo de contenido. Los servidores deben documentar claramente sus límites. Para archivos grandes, considerar: chunked upload APIs, compresión, procesamiento asíncrono con polling. Los límites comunes: nginx default 1MB, Apache default 2GB (configurable), servicios cloud 5-100MB para APIs.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/413_s69lyx.png",
                "alt": "Imagen que representa el nombre del código 413 Payload Too Large"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753831/38-removebg-preview_y2zldy.png",
                "alt": "Imagen del código 413 Payload Too Large"
            }
        ]
    },
    {
        "code": 414,
        "status": "URI Too Long",
        "category": "Client Error",
        "description": "El código 414 URI Too Long indica que el servidor se niega a procesar la solicitud porque el URI (Uniform Resource Identifier) solicitado es más largo que lo que el servidor está dispuesto a interpretar. El servidor está diciendo: 'La URL que estás intentando usar es demasiado larga para que yo la procese'. Este código se aplica tanto a la longitud total del URI completo (incluyendo el esquema, host, path, y query string) como específicamente a componentes individuales que pueden tener límites. Las causas más comunes de URIs excesivamente largos son: query strings con demasiados parámetros o valores muy largos, especialmente cuando se pasan grandes cantidades de datos mediante GET en lugar de POST, encoding de datos complejos en la URL (como estado de aplicación, filtros múltiples, o datos serializados), redirecciones en cadena que acumulan parámetros, ataques que intentan explotar vulnerabilidades mediante URLs extremadamente largas, o simplemente diseño inadecuado de API que pone demasiada información en la URL. Los límites de longitud de URI varían significativamente entre diferentes servidores y navegadores: muchos navegadores modernos soportan URLs de hasta 2,000 caracteres (aunque técnicamente pueden manejar más), Internet Explorer históricamente tenía un límite de 2,083 caracteres, Apache tiene un límite por defecto de 8,190 bytes, nginx usa 4K-8K bytes por defecto, IIS tiene límites configurables pero típicamente 16K, y muchos servicios cloud imponen límites de 2K-8K. La especificación HTTP no define un límite máximo, dejándolo a la implementación del servidor. Cuando se encuentra un 414, las soluciones típicas incluyen: cambiar de GET a POST para enviar datos en el cuerpo de la solicitud en lugar de query parameters, acortar los parámetros de query usando IDs en lugar de datos completos, implementar algún tipo de compresión o codificación más eficiente, dividir la solicitud en múltiples requests más pequeños, o usar métodos alternativos como almacenar estado en el servidor y referenciar con un token corto. Es importante diseñar APIs que no dependan de URLs extremadamente largas.",
        "useCases": [
            "Query strings con demasiados parámetros de filtrado o búsqueda",
            "Pasar grandes cantidades de datos mediante GET en lugar de POST",
            "URLs que codifican estado completo de aplicación",
            "Múltiples parámetros de array o lista en query string",
            "Encoding de datos JSON o XML complejos en parámetros de URL",
            "Redirecciones que acumulan parámetros progresivamente",
            "Búsquedas con muchos términos o filtros simultáneos",
            "URLs generadas automáticamente que concatenan demasiada información"
        ],
        "examples": [
            {
                "scenario": "Query string excesivamente largo con múltiples filtros",
                "request": "GET /api/products?category=electronics&brand=Samsung&brand=Apple&brand=Sony&brand=LG&price_min=100&price_max=2000&color=black&color=white&color=silver&color=blue&features=wifi&features=bluetooth&features=4k&features=hdr&features=smart&rating_min=4&shipping=free&instock=true&warranty=2years&model=2024&model=2023&condition=new&region=north&region=south&region=east&region=west&sortby=price&order=asc&page=1&limit=50&include_reviews=true&include_specs=true&include_images=true&include_related=true&format=json... [continues for 3000+ characters] HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"The request URI exceeds the maximum allowed length\",\n  \"uri_length\": 3245,\n  \"max_uri_length\": 2048,\n  \"exceeded_by\": 1197,\n  \"component\": \"query_string\",\n  \"explanation\": \"Your search has too many filters and parameters in the URL\",\n  \"recommendations\": [\n    {\n      \"method\": \"use_post\",\n      \"description\": \"Use POST method with filters in request body\",\n      \"endpoint\": \"POST /api/products/search\",\n      \"example\": {\n        \"filters\": {\n          \"categories\": [\"electronics\"],\n          \"brands\": [\"Samsung\", \"Apple\", \"Sony\", \"LG\"],\n          \"price_range\": {\"min\": 100, \"max\": 2000},\n          \"colors\": [\"black\", \"white\", \"silver\", \"blue\"]\n        }\n      }\n    },\n    {\n      \"method\": \"save_search\",\n      \"description\": \"Save your search criteria and use a short reference ID\",\n      \"endpoint\": \"POST /api/saved-searches\",\n      \"usage\": \"GET /api/products?search_id=abc123\"\n    },\n    {\n      \"method\": \"simplify_filters\",\n      \"description\": \"Reduce the number of simultaneous filters\",\n      \"suggestion\": \"Focus on the most important criteria\"\n    }\n  ],\n  \"documentation\": \"https://docs.shop.example.com/api/search-best-practices\"\n}",
                "explanation": "El cliente intentó usar una URL de más de 3,000 caracteres con docenas de filtros y parámetros. El servidor tiene un límite de 2,048 caracteres. Se sugiere usar POST con los filtros en el cuerpo, o guardar la búsqueda y usar un ID corto."
            },
            {
                "scenario": "Datos codificados en URL que deberían estar en POST body",
                "request": "GET /api/report?data={\"users\":[{\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\",\"department\":\"Engineering\",\"projects\":[\"Project A\",\"Project B\",\"Project C\"]},{\"id\":2,\"name\":\"Jane Smith\",\"email\":\"jane@example.com\",\"department\":\"Marketing\",\"projects\":[\"Campaign X\",\"Campaign Y\"]}],\"date_range\":{\"start\":\"2024-01-01\",\"end\":\"2024-12-31\"},\"metrics\":[\"revenue\",\"users\",\"conversions\",\"engagement\"],\"groupby\":[\"month\",\"department\",\"project\"],\"format\":\"pdf\",\"include_charts\":true,\"include_summary\":true} HTTP/1.1\nHost: analytics.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"URI length exceeds server limits\",\n  \"uri_length\": 892,\n  \"max_uri_length\": 512,\n  \"issue\": \"Complex data structures should not be passed in URL parameters\",\n  \"correct_approach\": {\n    \"method\": \"POST\",\n    \"endpoint\": \"/api/report\",\n    \"content_type\": \"application/json\",\n    \"body_example\": {\n      \"users\": [\n        {\"id\": 1, \"name\": \"John Doe\"},\n        {\"id\": 2, \"name\": \"Jane Smith\"}\n      ],\n      \"date_range\": {\n        \"start\": \"2024-01-01\",\n        \"end\": \"2024-12-31\"\n      },\n      \"metrics\": [\"revenue\", \"users\"],\n      \"format\": \"pdf\"\n    }\n  },\n  \"why_post\": [\n    \"POST allows larger payloads in request body\",\n    \"Better security (data not visible in URLs/logs)\",\n    \"No URL encoding issues with special characters\",\n    \"Cleaner and more maintainable code\"\n  ],\n  \"security_note\": \"Sensitive data should never be in URLs as they may be logged or cached\",\n  \"documentation\": \"https://docs.analytics.example.com/api/reports\"\n}",
                "explanation": "El cliente intentó pasar datos JSON complejos como parámetro de query en GET. Esto no solo excede límites de longitud sino que también es mala práctica. Los datos estructurados complejos deben enviarse en el cuerpo de una solicitud POST."
            },
            {
                "scenario": "URL generada con IDs múltiples como parámetros individuales",
                "request": "GET /api/export?id=1001&id=1002&id=1003&id=1004&id=1005... [continues with 500 more IDs] ...&id=1500&format=csv&include_metadata=true HTTP/1.1\nHost: data.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"Too many ID parameters in URL\",\n  \"parameter_count\": 500,\n  \"uri_length\": 4567,\n  \"max_uri_length\": 2048,\n  \"better_approaches\": [\n    {\n      \"method\": \"post_with_body\",\n      \"description\": \"Use POST with IDs in request body\",\n      \"endpoint\": \"POST /api/export\",\n      \"example\": {\n        \"ids\": [1001, 1002, 1003, \"...\", 1500],\n        \"format\": \"csv\",\n        \"include_metadata\": true\n      }\n    },\n    {\n      \"method\": \"id_ranges\",\n      \"description\": \"Use ranges instead of individual IDs\",\n      \"example\": \"GET /api/export?ids=1001-1500&format=csv\"\n    },\n    {\n      \"method\": \"comma_separated\",\n      \"description\": \"Use comma-separated IDs in single parameter\",\n      \"example\": \"GET /api/export?ids=1001,1002,1003,...,1500&format=csv\",\n      \"note\": \"Still may exceed limits with many IDs, POST recommended\"\n    }\n  ],\n  \"max_recommended_ids_in_url\": 50,\n  \"recommendation\": \"For bulk operations with many IDs, always use POST method\"\n}",
                "explanation": "El cliente intentó exportar 500 items pasando cada ID como un parámetro separado &id=X. Esto crea una URL de más de 4,500 caracteres. Se recomienda usar POST con un array de IDs en el cuerpo, o usar rangos/listas separadas por comas con menos items."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.12",
        "relatedHeaders": [
            "Content-Length"
        ],
        "relatedCodes": [
            413
        ],
        "technicalNotes": "414 es específico para longitud de URI (URL completa incluyendo query string), mientras que 413 Payload Too Large es para el cuerpo de la solicitud. No hay límite máximo definido en la especificación HTTP, cada servidor implementa sus propios límites. Límites típicos: navegadores ~2,000 caracteres (IE: 2,083), servidores web 2K-8K bytes. Mejores prácticas: usar POST para datos complejos, mantener URLs bajo 2,000 caracteres para compatibilidad, usar IDs/tokens en lugar de datos completos, implementar mecanismos de 'saved searches' o 'saved filters'. Query strings largos también pueden causar problemas de seguridad (datos sensibles en logs) y caching issues.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/414_o8x00s.png",
                "alt": "Imagen que representa el nombre del código 414 URI Too Long"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753831/39-removebg-preview_llxt9h.png",
                "alt": "Imagen del código 414 URI Too Long"
            }
        ]
    },
    {
        "code": 415,
        "status": "Unsupported Media Type",
        "category": "Client Error",
        "description": "El código 415 Unsupported Media Type indica que el servidor se niega a aceptar la solicitud porque el formato del payload (cuerpo de la solicitud) está en un formato no soportado. Específicamente, se refiere al valor del encabezado Content-Type que el cliente especificó para los datos que está ENVIANDO al servidor. El servidor está diciendo: 'Recibí tus datos, pero están en un formato que no puedo procesar'. Este código es fundamental en APIs modernas donde los servidores pueden aceptar ciertos formatos de contenido pero no otros. Es importante distinguir 415 de 406 Not Acceptable: 415 se refiere al Content-Type de los datos que el cliente ENVÍA en la solicitud (lo que el cliente está produciendo); 406 se refiere a los tipos de contenido que el cliente puede ACEPTAR en la respuesta (lo que el cliente puede consumir, especificado en el encabezado Accept). Los escenarios comunes que causan 415 incluyen: enviar JSON cuando el servidor solo acepta XML, enviar datos de formulario (application/x-www-form-urlencoded) cuando se espera JSON, enviar archivos con Content-Type incorrecto (por ejemplo, text/plain en lugar de image/jpeg), olvidar incluir el encabezado Content-Type completamente, usar multipart/form-data incorrectamente, o enviar datos en un formato legacy que el servidor ya no soporta. Los servidores modernos típicamente soportan formatos comunes como application/json, application/xml, multipart/form-data para uploads de archivos, y application/x-www-form-urlencoded para formularios tradicionales. Sin embargo, algunos endpoints pueden ser más restrictivos y aceptar solo un formato específico. La respuesta 415 debería idealmente incluir información sobre qué formatos de contenido SÍ son aceptados por el servidor, típicamente mediante el encabezado Accept (aunque técnicamente Accept es para respuestas, algunos servidores lo usan en respuestas 415 para indicar formatos aceptados para solicitudes). En APIs bien diseñadas, la documentación especifica claramente qué Content-Type se requiere para cada endpoint.",
        "useCases": [
            "Enviar JSON cuando el servidor solo acepta XML",
            "Enviar form data cuando se requiere JSON",
            "Upload de archivo con Content-Type incorrecto o faltante",
            "Usar formato legacy no soportado por API moderna",
            "Content-Type mal formado o no reconocido",
            "Enviar datos sin especificar Content-Type cuando es requerido",
            "Intentar enviar formato binario cuando solo se acepta texto",
            "Mismatch entre Content-Type declarado y datos reales enviados"
        ],
        "examples": [
            {
                "scenario": "Enviar JSON cuando solo se acepta XML",
                "request": "POST /api/legacy-service HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 89\n\n{\n  \"userId\": 123,\n  \"action\": \"update\",\n  \"data\": {\n    \"status\": \"active\"\n  }\n}",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\nAccept: application/xml, text/xml\n\n{\n  \"error\": \"unsupported_media_type\",\n  \"message\": \"The media type of the request is not supported\",\n  \"received_content_type\": \"application/json\",\n  \"supported_types\": [\n    {\n      \"content_type\": \"application/xml\",\n      \"description\": \"XML format (preferred)\",\n      \"example\": \"<?xml version=\\\"1.0\\\"?>\\n<request>\\n  <userId>123</userId>\\n  <action>update</action>\\n</request>\"\n    },\n    {\n      \"content_type\": \"text/xml\",\n      \"description\": \"Plain XML format\"\n    }\n  ],\n  \"explanation\": \"This is a legacy endpoint that only accepts XML format\",\n  \"migration_note\": \"Consider using our v2 API which supports JSON: https://api.example.com/v2/\",\n  \"documentation\": \"https://docs.example.com/api/legacy/xml-format\"\n}",
                "explanation": "El cliente envió datos JSON a un endpoint legacy que solo acepta XML. El servidor responde con 415 e indica claramente qué formatos son aceptados, proporcionando un ejemplo de formato correcto y sugiriendo migrar a la API moderna que soporta JSON."
            },
            {
                "scenario": "Falta encabezado Content-Type en upload",
                "request": "POST /api/documents HTTP/1.1\nHost: storage.example.com\nAuthorization: Bearer valid_token\nContent-Length: 2048\n\n[binary PDF data without Content-Type header]",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\n\n{\n  \"error\": \"content_type_required\",\n  \"message\": \"Content-Type header is required and must specify a supported media type\",\n  \"received_content_type\": null,\n  \"issue\": \"No Content-Type header was provided\",\n  \"supported_types\": [\n    \"application/pdf\",\n    \"application/msword\",\n    \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"text/plain\"\n  ],\n  \"required_headers\": [\n    \"Content-Type\",\n    \"Content-Length\"\n  ],\n  \"example_correct_request\": \"POST /api/documents HTTP/1.1\\nContent-Type: application/pdf\\nContent-Length: 2048\\n\\n[PDF data]\",\n  \"note\": \"The Content-Type must match the actual file format being uploaded\",\n  \"documentation\": \"https://docs.storage.example.com/api/upload-requirements\"\n}",
                "explanation": "El cliente intentó subir un archivo PDF pero no incluyó el encabezado Content-Type. El servidor no puede determinar qué tipo de archivo es y responde con 415, listando los tipos de contenido aceptados y explicando que Content-Type es requerido."
            },
            {
                "scenario": "Content-Type no coincide con datos reales",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 45\n\nname=John+Doe&email=john%40example.com",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\n\n{\n  \"error\": \"content_type_mismatch\",\n  \"message\": \"Content-Type header does not match the actual content format\",\n  \"declared_content_type\": \"application/json\",\n  \"detected_format\": \"application/x-www-form-urlencoded\",\n  \"issue\": \"You declared JSON but sent URL-encoded form data\",\n  \"resolution_options\": [\n    {\n      \"option\": \"use_correct_content_type\",\n      \"description\": \"Change Content-Type to match your data format\",\n      \"correct_header\": \"Content-Type: application/x-www-form-urlencoded\"\n    },\n    {\n      \"option\": \"send_json\",\n      \"description\": \"Send actual JSON data as declared\",\n      \"example\": {\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n      },\n      \"note\": \"This endpoint prefers JSON format\"\n    }\n  ],\n  \"accepted_formats\": [\n    \"application/json (preferred)\",\n    \"application/x-www-form-urlencoded (legacy support)\"\n  ],\n  \"recommendation\": \"Use JSON format for better structure and type safety\"\n}",
                "explanation": "El cliente declaró Content-Type: application/json pero envió datos URL-encoded. Esta inconsistencia causa confusión y el servidor responde con 415, explicando el mismatch y proporcionando opciones para corregirlo."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.13",
        "relatedHeaders": [
            "Content-Type",
            "Accept"
        ],
        "relatedCodes": [
            406
        ],
        "technicalNotes": "415 es sobre el Content-Type de lo que el cliente ENVÍA (request body), mientras que 406 Not Acceptable es sobre lo que el cliente puede ACEPTAR en la respuesta (Accept header). El servidor debería incluir información sobre qué tipos de contenido acepta, aunque no hay un encabezado estándar específico para esto en respuestas 415 (algunos usan Accept, otros lo incluyen en el cuerpo de la respuesta). Content-Type común aceptados: application/json, application/xml, application/x-www-form-urlencoded, multipart/form-data, text/plain. Para uploads de archivos, el Content-Type debe coincidir con el tipo real del archivo. APIs RESTful modernas típicamente requieren application/json. La validación puede ser estricta (solo tipos específicos) o permisiva (cualquier tipo pero con advertencias).",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/415_tl94ln.png",
                "alt": "Imagen que representa el nombre del código 415 Unsupported Media Type"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753830/40-removebg-preview_it0wsn.png",
                "alt": "Imagen del código 415 Unsupported Media Type"
            }
        ]
    },
    {
        "code": 416,
        "status": "Range Not Satisfiable",
        "category": "Client Error",
        "description": "El código 416 Range Not Satisfiable indica que ninguno de los rangos especificados en el encabezado Range de la solicitud puede ser satisfecho. Este código se utiliza cuando un cliente solicita una porción específica de un recurso (usando el encabezado Range), pero el rango solicitado está fuera de los límites del recurso o es inválido de alguna manera. El servidor está diciendo: 'Entiendo que quieres una porción específica de este recurso, pero el rango que especificaste no es válido o está completamente fuera de los límites del contenido disponible'. El mecanismo de rangos en HTTP permite a los clientes solicitar solo partes de un recurso, lo cual es fundamental para: descargas resumibles (donde un cliente puede solicitar solo la porción restante después de una interrupción), streaming de video/audio (donde el cliente puede solicitar segmentos específicos para permitir seek/skip), descargas paralelas (donde múltiples conexiones descargan diferentes segmentos simultáneamente), y optimización de ancho de banda (solicitando solo las porciones necesarias de archivos grandes). El encabezado Range tiene el formato 'Range: bytes=start-end', por ejemplo 'Range: bytes=0-1023' solicita los primeros 1024 bytes, o 'Range: bytes=1000-' solicita desde el byte 1000 hasta el final. Los errores comunes que causan 416 incluyen: solicitar un rango que comienza más allá del final del archivo (por ejemplo, 'Range: bytes=5000-' cuando el archivo solo tiene 3000 bytes), especificar un rango de inicio mayor que el rango de fin (por ejemplo, 'Range: bytes=1000-500'), usar valores negativos inválidos, o solicitar rangos cuando el recurso ha cambiado de tamaño desde que se obtuvo la información inicial. La respuesta 416 DEBE incluir un encabezado Content-Range que especifique el tamaño actual del recurso en el formato 'Content-Range: bytes */size', donde 'size' es el tamaño total en bytes del recurso completo. Esto permite al cliente entender el tamaño real y reformular su solicitud con un rango válido.",
        "useCases": [
            "Reanudación de descarga con rango que excede el tamaño del archivo",
            "Solicitud de rango inválido (inicio > fin)",
            "Rango que comienza más allá del final del recurso",
            "Archivo cambió de tamaño entre solicitudes y el rango ya no es válido",
            "Streaming de video solicitando segmento más allá de la duración del contenido",
            "Descarga paralela con rango calculado incorrectamente",
            "Cliente con información desactualizada sobre tamaño de archivo",
            "Formato de rango mal formado o no soportado"
        ],
        "examples": [
            {
                "scenario": "Rango de inicio más allá del tamaño del archivo",
                "request": "GET /downloads/video.mp4 HTTP/1.1\nHost: media.example.com\nRange: bytes=500000000-",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */104857600\nContent-Type: application/json\n\n{\n  \"error\": \"range_not_satisfiable\",\n  \"message\": \"The requested range is outside the bounds of the resource\",\n  \"requested_range\": \"bytes=500000000-\",\n  \"requested_start\": 500000000,\n  \"requested_start_human\": \"500 MB\",\n  \"file_size\": 104857600,\n  \"file_size_human\": \"100 MB\",\n  \"issue\": \"Range start (500000000) is beyond the end of file (104857600)\",\n  \"explanation\": \"You requested data starting at byte 500,000,000 but the file is only 104,857,600 bytes (100 MB) in total\",\n  \"valid_range\": \"bytes=0-104857599\",\n  \"suggestions\": [\n    \"Request the entire file: GET /downloads/video.mp4 (no Range header)\",\n    \"Request from the beginning: Range: bytes=0-\",\n    \"Request the last portion: Range: bytes=104000000-104857599\"\n  ],\n  \"note\": \"The file may have been truncated or you may have outdated size information\"\n}",
                "explanation": "El cliente solicitó datos comenzando desde el byte 500,000,000, pero el archivo solo tiene 104,857,600 bytes en total. El rango está completamente fuera de los límites. El encabezado Content-Range indica que el tamaño total es 104,857,600 bytes."
            },
            {
                "scenario": "Rango inválido donde inicio > fin",
                "request": "GET /files/document.pdf HTTP/1.1\nHost: storage.example.com\nRange: bytes=1000-500\nAuthorization: Bearer valid_token",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */2097152\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_range_format\",\n  \"message\": \"The requested range has invalid values\",\n  \"requested_range\": \"bytes=1000-500\",\n  \"range_start\": 1000,\n  \"range_end\": 500,\n  \"file_size\": 2097152,\n  \"file_size_human\": \"2 MB\",\n  \"issue\": \"Range start (1000) is greater than range end (500)\",\n  \"explanation\": \"A valid byte range must have the start position less than or equal to the end position\",\n  \"correct_format\": \"Range: bytes=start-end where start <= end\",\n  \"examples_of_valid_ranges\": [\n    \"Range: bytes=0-1023 (first 1024 bytes)\",\n    \"Range: bytes=500-1000 (bytes 500 through 1000)\",\n    \"Range: bytes=1000- (from byte 1000 to end of file)\",\n    \"Range: bytes=-1024 (last 1024 bytes)\"\n  ],\n  \"did_you_mean\": \"Range: bytes=500-1000\",\n  \"documentation\": \"https://docs.storage.example.com/api/range-requests\"\n}",
                "explanation": "El cliente especificó un rango donde el inicio (1000) es mayor que el fin (500), lo cual es lógicamente inválido. El servidor responde con 416 y explica el formato correcto de rangos, sugiriendo que posiblemente quiso decir bytes=500-1000."
            },
            {
                "scenario": "Reanudación de descarga después de que el archivo fue modificado",
                "request": "GET /downloads/software-v2.zip HTTP/1.1\nHost: cdn.example.com\nRange: bytes=50000000-\nIf-Range: \"etag-old-version-abc123\"",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */45000000\nETag: \"etag-new-version-xyz789\"\nLast-Modified: Wed, 17 Jan 2024 10:00:00 GMT\nContent-Type: application/json\n\n{\n  \"error\": \"range_not_satisfiable\",\n  \"message\": \"Range request cannot be satisfied because the resource has changed\",\n  \"requested_range\": \"bytes=50000000-\",\n  \"requested_start\": 50000000,\n  \"requested_start_human\": \"50 MB\",\n  \"current_file_size\": 45000000,\n  \"current_file_size_human\": \"45 MB\",\n  \"previous_file_size_estimate\": \"~100 MB or more\",\n  \"issue\": \"The file was updated and is now smaller than your resume point\",\n  \"file_version_changed\": true,\n  \"your_etag\": \"etag-old-version-abc123\",\n  \"current_etag\": \"etag-new-version-xyz789\",\n  \"last_modified\": \"2024-01-17T10:00:00Z\",\n  \"explanation\": \"You were downloading an older version of the file. A new version (v2.1) was released that is smaller.\",\n  \"resolution\": [\n    \"Download the new version from the beginning\",\n    \"The new version may have different content or be more compressed\",\n    \"Previous partial download is incompatible with new version\"\n  ],\n  \"download_new_version\": \"GET /downloads/software-v2.zip (without Range header)\",\n  \"version_info\": {\n    \"old_version\": \"v2.0\",\n    \"new_version\": \"v2.1\",\n    \"changelog\": \"https://example.com/changelog/v2.1\"\n  }\n}",
                "explanation": "El cliente estaba descargando un archivo de ~100MB y había descargado 50MB. El archivo fue actualizado a una nueva versión que solo tiene 45MB. El rango solicitado (desde byte 50,000,000) ahora está más allá del final del archivo actualizado. Debe descargar la nueva versión desde el principio."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.4",
        "relatedHeaders": [
            "Range",
            "Content-Range",
            "Accept-Ranges",
            "If-Range",
            "ETag"
        ],
        "relatedCodes": [
            206
        ],
        "technicalNotes": "416 es la respuesta cuando un rango NO puede satisfacerse. Cuando un rango SÍ puede satisfacerse, el servidor responde 206 Partial Content. La respuesta 416 DEBE incluir Content-Range con el formato 'bytes */size' donde size es el tamaño total del recurso. El encabezado If-Range puede usarse para hacer requests de rango condicionales: si el recurso cambió, el servidor ignora el Range y envía 200 con el recurso completo en lugar de 416. Formato válido de Range: bytes=start-end (ambos inclusivos), bytes=start- (desde start hasta el final), bytes=-suffix (últimos suffix bytes). Los índices comienzan en 0. Un archivo de 1000 bytes va de 0 a 999. Múltiples rangos son soportados: Range: bytes=0-100,200-300.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/416_rsmaxq.png",
                "alt": "Imagen que representa el nombre del código 416 Range Not Satisfiable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753835/41-removebg-preview_trgi8w.png",
                "alt": "Imagen del código 416 Range Not Satisfiable"
            }
        ]
    },
    {
        "code": 417,
        "status": "Expectation Failed",
        "category": "Client Error",
        "description": "El código 417 Expectation Failed indica que la expectativa especificada en el encabezado Expect de la solicitud no puede ser cumplida por el servidor. El encabezado Expect permite al cliente indicar ciertos comportamientos que espera del servidor antes de enviar el cuerpo completo de la solicitud. El uso más común del encabezado Expect es 'Expect: 100-continue', que le dice al servidor: 'Voy a enviar un cuerpo de solicitud grande, pero primero verifica si puedes manejarlo'. Si el servidor puede procesar la solicitud, responde con '100 Continue' y el cliente entonces envía el cuerpo completo. Sin embargo, si el servidor determina que no puede cumplir con la expectativa (por ejemplo, porque rechazará la solicitud por razones de autenticación, autorización, o límites de tamaño), responde con 417 Expectation Failed en lugar de 100 Continue. Esto ahorra ancho de banda al prevenir que el cliente envíe un payload grande que será rechazado de todos modos. El código 417 es relativamente raro en la práctica web moderna porque: (1) el mecanismo Expect/100-continue no es ampliamente utilizado fuera de ciertos contextos específicos, (2) muchos servidores simplemente ignoran el encabezado Expect y procesan la solicitud normalmente, (3) algunos servidores no implementan completamente el manejo de expectativas. Los escenarios donde 417 es apropiado incluyen: cuando el servidor no soporta el esquema de expectativa solicitado (por ejemplo, expectativas personalizadas más allá de 100-continue), cuando el servidor determina por adelantado que la solicitud fallará incluso antes de recibir el cuerpo (autenticación inválida, permisos insuficientes, límites excedidos), o cuando el servidor está configurado para no aceptar solicitudes con ciertos tipos de expectativas. Es importante notar que 417 es específicamente para fallos relacionados con el encabezado Expect, no para otros tipos de fallos de validación o precondiciones.",
        "useCases": [
            "Servidor rechaza Expect: 100-continue debido a autenticación inválida",
            "Servidor no soporta el esquema de expectativa especificado",
            "Servidor determina que la solicitud fallará antes de recibir el cuerpo",
            "Expectativa personalizada no reconocida o no soportada por el servidor",
            "Servidor configurado para rechazar ciertos tipos de expectativas",
            "Prevención de upload de payload grande que será rechazado por otras razones",
            "Validación temprana que determina que la solicitud no puede proceder"
        ],
        "examples": [
            {
                "scenario": "Expect: 100-continue rechazado por autenticación inválida",
                "request": "POST /api/upload HTTP/1.1\nHost: storage.example.com\nExpect: 100-continue\nContent-Type: application/octet-stream\nContent-Length: 524288000\nAuthorization: Bearer expired_or_invalid_token",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Cannot fulfill the Expect: 100-continue request\",\n  \"expectation\": \"100-continue\",\n  \"reason\": \"Authentication token is invalid or expired\",\n  \"explanation\": \"The server will not accept the request body because authentication failed. Sending 417 to prevent uploading 500MB that would be rejected anyway.\",\n  \"authentication_error\": {\n    \"code\": \"token_expired\",\n    \"message\": \"The authorization token has expired\",\n    \"expired_at\": \"2024-01-16T12:00:00Z\",\n    \"current_time\": \"2024-01-17T15:30:00Z\"\n  },\n  \"next_steps\": [\n    \"Obtain a new authentication token\",\n    \"Retry the upload with valid credentials\"\n  ],\n  \"token_refresh_endpoint\": \"/auth/refresh\",\n  \"bandwidth_saved\": \"500 MB (by not uploading rejected content)\"\n}",
                "explanation": "El cliente envió Expect: 100-continue indicando que enviará 500MB de datos. El servidor verifica primero el token de autenticación y descubre que está expirado. En lugar de responder 100 Continue solo para luego rechazar con 401, responde inmediatamente con 417 ahorrando el envío innecesario de 500MB."
            },
            {
                "scenario": "Expectativa personalizada no soportada",
                "request": "POST /api/data HTTP/1.1\nHost: api.example.com\nExpect: custom-validation, 100-continue\nContent-Type: application/json\nContent-Length: 10485760",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Server cannot fulfill the specified expectations\",\n  \"received_expectations\": [\"custom-validation\", \"100-continue\"],\n  \"unsupported_expectations\": [\"custom-validation\"],\n  \"supported_expectations\": [\"100-continue\"],\n  \"reason\": \"The 'custom-validation' expectation is not recognized or supported by this server\",\n  \"explanation\": \"While 100-continue is supported, custom-validation is not a standard expectation and this server doesn't implement it\",\n  \"recommendation\": \"Remove unsupported expectations and retry with only: Expect: 100-continue\",\n  \"correct_request\": \"POST /api/data HTTP/1.1\\nExpect: 100-continue\\n...\",\n  \"documentation\": \"https://docs.api.example.com/http-expectations\"\n}",
                "explanation": "El cliente especificó múltiples expectativas incluyendo una personalizada ('custom-validation') que el servidor no reconoce o no soporta. El servidor responde con 417 indicando qué expectativa causó el problema y cuáles son soportadas."
            },
            {
                "scenario": "Servidor determina que límite será excedido",
                "request": "POST /api/process HTTP/1.1\nHost: api.example.com\nExpect: 100-continue\nContent-Type: application/json\nContent-Length: 52428800\nAuthorization: Bearer free_tier_user_token",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Cannot proceed with request due to quota limitations\",\n  \"expectation\": \"100-continue\",\n  \"reason\": \"Request would exceed user quota limits\",\n  \"request_size\": 52428800,\n  \"request_size_human\": \"50 MB\",\n  \"user_plan\": \"free\",\n  \"quota_limit\": 10485760,\n  \"quota_limit_human\": \"10 MB per request\",\n  \"quota_used_today\": 8388608,\n  \"quota_remaining_today\": 2097152,\n  \"quota_remaining_human\": \"2 MB\",\n  \"explanation\": \"Your free plan allows maximum 10 MB per request. This 50 MB request exceeds the limit. Responding with 417 to prevent sending data that would be rejected.\",\n  \"upgrade_options\": [\n    {\n      \"plan\": \"basic\",\n      \"limit\": \"100 MB per request\",\n      \"price\": \"$9.99/month\"\n    },\n    {\n      \"plan\": \"pro\",\n      \"limit\": \"1 GB per request\",\n      \"price\": \"$29.99/month\"\n    }\n  ],\n  \"suggestion\": \"Either reduce request size to under 10 MB or upgrade your plan\"\n}",
                "explanation": "El cliente con plan gratuito intentó enviar 50MB cuando su límite es 10MB. El servidor evalúa esto antes de enviar 100 Continue y responde 417 para evitar que el cliente desperdicie ancho de banda enviando datos que serán rechazados por 413 Payload Too Large."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.14",
        "relatedHeaders": [
            "Expect"
        ],
        "relatedCodes": [
            100
        ],
        "technicalNotes": "417 es específicamente para fallos relacionados con el encabezado Expect. El caso más común es Expect: 100-continue. Cuando un cliente envía Expect: 100-continue, el servidor tiene tres opciones: (1) responder 100 Continue si puede procesar la solicitud, (2) responder 417 Expectation Failed si no puede cumplir la expectativa, (3) responder directamente con código de error apropiado (401, 403, 413, etc.) si ya sabe que la solicitud fallará. El código 417 es raro en la práctica porque muchos servidores ignoran Expect o no lo implementan completamente. Si el servidor no entiende/soporta el encabezado Expect, puede ignorarlo y procesar normalmente. 417 NO debe usarse para otros tipos de validación o precondiciones - usar códigos apropiados como 400, 412, 428.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754171/417_kh1l57.png",
                "alt": "Imagen que representa el nombre del código 417 Expectation Failed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753835/42-removebg-preview_zp0aep.png",
                "alt": "Imagen del código 417 Expectation Failed"
            }
        ]
    },
    {
        "code": 418,
        "status": "I'm a teapot",
        "category": "Client Error",
        "description": "El código 418 I'm a teapot es uno de los códigos de estado HTTP más peculiares y únicos en toda la especificación. Fue definido originalmente en 1998 como parte del RFC 2324, que era una broma del April Fools' Day (Día de los Inocentes) llamada 'Hyper Text Coffee Pot Control Protocol' (HTCPCP). El RFC 2324 propuso un protocolo para controlar, monitorear y diagnosticar cafeteras a través de internet. El código 418 se define como la respuesta que debe dar una tetera cuando se le solicita preparar café: 'I'm a teapot' (Soy una tetera). El servidor está diciendo: 'Soy una tetera, no una cafetera, por lo tanto no puedo preparar café'. Aunque comenzó como una broma, el código 418 ha ganado un estatus de culto en la comunidad de desarrolladores y se ha vuelto un símbolo del humor geek en la cultura de internet. A pesar de su origen humorístico, el código 418 está oficialmente reservado en el registro de códigos de estado HTTP de IANA. En 2017, hubo una propuesta para eliminar 418 del registro oficial, pero la comunidad de desarrolladores se opuso fuertemente, argumentando que es parte de la cultura de internet y debe preservarse. Como resultado, 418 permanece oficialmente reservado. En la práctica moderna, algunos desarrolladores usan 418 de manera humorística en sus APIs como easter eggs, respuestas a solicitudes absurdas, o simplemente para agregar un toque de diversión. Sin embargo, NO debe usarse en aplicaciones de producción serias para indicar errores reales, ya que los clientes HTTP estándar no tienen lógica específica para manejarlo y puede causar confusión. El código 418 representa el lado divertido y humano del desarrollo de software, recordándonos que detrás de protocolos y especificaciones técnicas, hay personas con sentido del humor.",
        "useCases": [
            "Easter eggs en APIs como respuesta humorística",
            "Respuestas a solicitudes absurdas o imposibles de manera divertida",
            "Demostración de cultura de internet en proyectos educativos",
            "Indicador humorístico de que una API no hace lo que se solicita",
            "NOTA: NO debe usarse para errores reales en producción"
        ],
        "examples": [
            {
                "scenario": "Easter egg en API divertida",
                "request": "POST /api/brew-coffee HTTP/1.1\nHost: teapot.example.com\nContent-Type: application/json\n\n{\n  \"beverage\": \"coffee\",\n  \"size\": \"large\",\n  \"strength\": \"strong\"\n}",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: application/json\n\n{\n  \"error\": \"im_a_teapot\",\n  \"message\": \"I'm a teapot, not a coffee pot!\",\n  \"explanation\": \"This endpoint is a teapot and cannot brew coffee. Please try the tea endpoint instead.\",\n  \"requested_beverage\": \"coffee\",\n  \"what_i_can_do\": \"brew tea\",\n  \"alternative_endpoint\": \"/api/brew-tea\",\n  \"reference\": \"RFC 2324 - Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)\",\n  \"fun_fact\": \"This is a real HTTP status code from an April Fools' RFC!\",\n  \"teapot_status\": {\n    \"type\": \"ceramic\",\n    \"capacity\": \"1 liter\",\n    \"temperature\": \"hot\",\n    \"currently_brewing\": \"Earl Grey tea\"\n  },\n  \"suggestion\": \"Try: POST /api/brew-tea with beverage: 'earl-grey' or 'green-tea'\",\n  \"ascii_art\": \"\\n    _\\n   ( )\\n    )(_\\n  .-|:|-. \\n (_:===:_)\\n   |: I :|\\n   |: m :|\\n   |: a :|\\n   |:   :|\\n   |:tea|\\n   |: p :|\\n   |: o :|\\n   |: t :|\\n   '-----'\\n\"\n}",
                "explanation": "Una API divertida usa 418 como respuesta humorística cuando alguien intenta pedirle que prepare café. Incluye arte ASCII de una tetera, referencias al RFC original, y sugiere el endpoint correcto para té."
            },
            {
                "scenario": "Respuesta a solicitud imposible o absurda",
                "request": "DELETE /api/internet HTTP/1.1\nHost: silly-api.example.com\nAuthorization: Bearer curious_user_token",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: application/json\n\n{\n  \"error\": \"request_impossible\",\n  \"message\": \"I'm a teapot, and even if I weren't, I couldn't delete the internet\",\n  \"requested_action\": \"DELETE /api/internet\",\n  \"why_teapot\": \"Using HTTP 418 to indicate this request is as absurd as asking a teapot to make coffee\",\n  \"reality_check\": [\n    \"The internet is not a single deletable entity\",\n    \"No API has that kind of power (thankfully)\",\n    \"This endpoint doesn't exist for very good reasons\",\n    \"Please don't try to delete the internet\"\n  ],\n  \"what_you_can_actually_do\": [\n    \"View API documentation: GET /api/docs\",\n    \"Check service status: GET /api/status\",\n    \"Manage your account: GET /api/account\"\n  ],\n  \"philosophical_note\": \"The internet is a network of networks. To 'delete' it would require disconnecting every device worldwide. Also, I'm a teapot.\",\n  \"http_418_history\": \"https://tools.ietf.org/html/rfc2324\"\n}",
                "explanation": "Cuando alguien intenta hacer algo completamente absurdo como 'eliminar el internet', la API responde con 418 de manera humorística, explicando por qué la solicitud es imposible mientras mantiene el espíritu divertido del código."
            },
            {
                "scenario": "Implementación educativa mostrando RFC 2324",
                "request": "BREW /pot-0 HTTP/1.1\nHost: htcpcp.example.com\nContent-Type: application/coffee-pot-command\nAccept-Additions: cream, sugar\n\nstart",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: text/plain\n\nI'm a teapot!\n\nThis device is a teapot, not a coffee pot.\nAccording to RFC 2324 (HTCPCP/1.0), a teapot receiving\na request to brew coffee should respond with 418.\n\nHTCPCP/1.0 was an April Fools' RFC published in 1998.\nIt proposed a protocol for controlling coffee pots over HTTP.\n\nThe 418 status code has since become beloved by developers\nand is now permanently reserved, even though it started as a joke.\n\nFun facts:\n- The BREW method was proposed for making coffee\n- Accept-Additions header was for cream, sugar, etc.\n- There's even a 406 Not Acceptable for when you ask\n  for additions the pot doesn't have\n\nFor more information:\nhttps://tools.ietf.org/html/rfc2324\n\nP.S. I can make excellent tea though! Try:\nBREW /pot-0 HTTP/1.1\nContent-Type: message/teapot",
                "explanation": "Una implementación educativa que enseña sobre el origen humorístico del código 418, implementando el protocolo HTCPCP propuesto en el RFC 2324 y explicando la historia detrás del código de estado más divertido de HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2324 (April Fools' RFC), RFC 7168 (update)",
        "relatedHeaders": [
            "Accept-Additions",
            "Content-Type"
        ],
        "technicalNotes": "418 I'm a teapot es oficialmente un código reservado pero NO debe usarse para indicar errores reales en aplicaciones de producción. Origen: RFC 2324 (1998) como parte del protocolo HTCPCP para controlar cafeteras por internet (broma del April Fools'). A pesar de ser una broma, está oficialmente reservado en el registro IANA desde entonces. En 2017 hubo intento de eliminarlo (save418.com movement lo preservó). RFC 7168 (2014) actualizó HTCPCP pero mantuvo 418. Uso moderno: principalmente easter eggs y humor en APIs. Los clientes HTTP estándar no tienen lógica especial para 418. Es un símbolo de la cultura geek/developer y del lado humano de las especificaciones técnicas. NO usar en lugar de códigos apropiados como 400, 404, 501.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754171/418_sx9w7l.png",
                "alt": "Imagen que representa el nombre del código 418 I'm a teapot"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753832/43-removebg-preview_a0tody.png",
                "alt": "Imagen del código 418 I 'm a teapot"
            }
        ]
    },
    {
        "code": 419,
        "status": "Authentication Timeout / Page Expired",
        "category": "Client Error",
        "description": "El código 419 NO es un código de estado HTTP estándar oficial definido en ninguna RFC de IETF. Sin embargo, ha sido adoptado y utilizado de manera no estándar por algunos frameworks web, siendo Laravel (un popular framework PHP) el usuario más prominente. En Laravel, el código 419 se utiliza específicamente para indicar que un token CSRF (Cross-Site Request Forgery) ha expirado o es inválido, típicamente mostrando el mensaje 'Page Expired'. Este es un caso interesante de cómo los frameworks web a veces crean sus propios códigos de estado para necesidades específicas, aunque no estén en el estándar oficial HTTP. Cuando Laravel devuelve 419, está diciendo: 'Tu formulario o solicitud incluía un token CSRF que ya expiró, probablemente porque la página estuvo abierta demasiado tiempo antes de enviarla'. Los tokens CSRF son mecanismos de seguridad que previenen ataques donde un sitio malicioso intenta hacer que tu navegador envíe solicitudes no autorizadas a otro sitio donde estás autenticado. Laravel genera un token único por sesión y lo incluye en formularios; cuando el formulario se envía, valida que el token coincida. Si un usuario deja un formulario abierto por mucho tiempo (más allá del tiempo de vida del token, típicamente horas), el token expira, y al intentar enviar el formulario, Laravel responde con 419. Aunque 419 es específico de Laravel, otros frameworks han usado códigos en el rango 419-420 para propósitos similares no estándar. Algunos servidores proxy también han utilizado 419 para indicar timeouts de autenticación. Es importante notar que usar códigos de estado no estándar puede causar problemas de interoperabilidad, ya que clientes HTTP genéricos no tendrán lógica específica para manejarlos. Las mejores prácticas sugieren usar códigos estándar existentes (como 403 Forbidden o 401 Unauthorized con información adicional en el cuerpo) en lugar de inventar códigos nuevos, pero el uso de 419 por Laravel está tan extendido que es ampliamente reconocido en la comunidad PHP.",
        "useCases": [
            "Laravel: Token CSRF expirado en formularios (uso más común)",
            "Algunos frameworks PHP: Sesión expirada durante envío de formulario",
            "Uso no estándar: Timeout de autenticación en algunos servidores",
            "Indicar que una página debe ser recargada antes de reenviar",
            "NOTA: NO es un código HTTP oficial/estándar"
        ],
        "examples": [
            {
                "scenario": "Laravel - Token CSRF expirado en formulario",
                "request": "POST /profile/update HTTP/1.1\nHost: app.example.com\nContent-Type: application/x-www-form-urlencoded\nCookie: laravel_session=eyJpdiI6...\n\n_token=expired_csrf_token_abc123&name=John+Doe&email=john@example.com",
                "response": "HTTP/1.1 419 Page Expired\nContent-Type: text/html; charset=UTF-8\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>419 | Page Expired</title>\n    <style>\n        body { font-family: sans-serif; text-align: center; padding: 50px; }\n        h1 { color: #e74c3c; }\n    </style>\n</head>\n<body>\n    <h1>419</h1>\n    <h2>Page Expired</h2>\n    <p>The page has expired due to inactivity.</p>\n    <p>Please refresh and try again.</p>\n    <button onclick=\"window.location.reload()\">Refresh Page</button>\n    <hr>\n    <p><small>This happened because your CSRF token expired. Laravel generates tokens for security that expire after a period of inactivity.</small></p>\n</body>\n</html>",
                "explanation": "Este es el uso más común de 419: en Laravel, cuando un usuario deja un formulario abierto por mucho tiempo, el token CSRF expira. Al intentar enviar el formulario, Laravel detecta el token expirado y responde con 419, pidiendo al usuario que recargue la página para obtener un nuevo token."
            },
            {
                "scenario": "Laravel API - CSRF token inválido en JSON",
                "request": "POST /api/data HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nX-CSRF-TOKEN: invalid_or_expired_token\nCookie: XSRF-TOKEN=...\n\n{\n  \"action\": \"update\",\n  \"data\": {\n    \"field\": \"value\"\n  }\n}",
                "response": "HTTP/1.1 419 Page Expired\nContent-Type: application/json\n\n{\n  \"message\": \"CSRF token mismatch.\",\n  \"error\": \"TokenMismatchException\",\n  \"error_code\": 419,\n  \"explanation\": \"The CSRF token in your request is invalid or has expired\",\n  \"causes\": [\n    \"The token has expired due to session timeout\",\n    \"The session was cleared or regenerated\",\n    \"The token was not included in the request\",\n    \"The token doesn't match the session token\"\n  ],\n  \"resolution\": [\n    \"Obtain a fresh CSRF token from the server\",\n    \"Include the token in X-CSRF-TOKEN header or _token field\",\n    \"Ensure cookies are enabled for session management\"\n  ],\n  \"get_new_token\": \"GET /sanctum/csrf-cookie\",\n  \"documentation\": \"https://laravel.com/docs/csrf\",\n  \"note\": \"419 is a Laravel-specific status code, not part of official HTTP standards\"\n}",
                "explanation": "En una API Laravel, cuando el token CSRF en el encabezado X-CSRF-TOKEN no coincide o ha expirado, el servidor responde con 419 y proporciona información sobre cómo obtener un nuevo token."
            },
            {
                "scenario": "Alternativa estándar usando 403 Forbidden",
                "request": "POST /profile/update HTTP/1.1\nHost: standard-app.example.com\nContent-Type: application/x-www-form-urlencoded\n\n_token=expired_csrf_token&name=John+Doe",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"csrf_token_expired\",\n  \"message\": \"The CSRF token has expired\",\n  \"error_type\": \"security\",\n  \"reason\": \"Your session token is no longer valid\",\n  \"token_lifetime\": \"2 hours\",\n  \"token_expired_at\": \"2024-01-17T14:00:00Z\",\n  \"current_time\": \"2024-01-17T16:30:00Z\",\n  \"explanation\": \"For security reasons, form tokens expire after a period of inactivity. This prevents CSRF attacks.\",\n  \"action_required\": \"Refresh the page to get a new token and resubmit the form\",\n  \"best_practice\": \"Instead of non-standard 419, we use standard 403 Forbidden with descriptive error information\",\n  \"note\": \"Using standard HTTP codes ensures better client compatibility\"\n}",
                "explanation": "MEJOR PRÁCTICA: En lugar de usar el código no estándar 419, una aplicación puede usar el código estándar 403 Forbidden con información detallada en el cuerpo sobre el problema específico de CSRF. Esto mantiene compatibilidad con clientes HTTP estándar."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP oficial)",
        "specification": "No oficial - Usado principalmente por Laravel framework",
        "relatedHeaders": [
            "X-CSRF-TOKEN",
            "Cookie",
            "Set-Cookie"
        ],
        "relatedCodes": [
            401,
            403
        ],
        "technicalNotes": "419 NO es un código HTTP estándar oficial. No aparece en ninguna RFC de IETF. Es una extensión no estándar popularizada por Laravel framework para indicar tokens CSRF expirados. Otros frameworks/servidores a veces usan 419 para timeouts de autenticación similares. MEJOR PRÁCTICA: Usar códigos estándar como 403 Forbidden con error específico en el cuerpo en lugar de códigos inventados. Ventajas de códigos estándar: mejor interoperabilidad, clientes HTTP genéricos los entienden, no confunde herramientas de debugging. El uso de 419 por Laravel está tan extendido que es reconocido en la comunidad PHP, pero puede causar confusión fuera de ese ecosistema. Clientes HTTP estándar tratarán 419 como un error genérico 4xx.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783438/419_ou4ooa.png",
                "alt": "Imagen que representa el nombre del código 419 Authentication Timeout"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/44-removebg-preview_kkcvb3.png",
                "alt": "Imagen del código 419 Authentication Timeout"
            }
        ]
    },
    {
        "code": 420,
        "status": "Method Failure / Enhance Your Calm",
        "category": "Client Error",
        "description": "El código 420 NO es un código de estado HTTP oficial estándar, pero ha sido utilizado históricamente por diferentes servicios y frameworks con significados completamente distintos, lo que lo hace particularmente confuso. Existen al menos tres usos diferentes y contradictorios de 420: (1) Twitter (antes de X) utilizó '420 Enhance Your Calm' como respuesta cuando un cliente estaba siendo rate-limited por hacer demasiadas solicitudes. El mensaje humorístico 'Enhance Your Calm' (Mejora tu calma) era la forma de Twitter de decir 'relájate y deja de hacer tantas solicitudes'. (2) Spring Framework (Java) en versiones antiguas utilizó '420 Method Failure' para indicar que un método específico falló durante el procesamiento. (3) En la cultura de internet, 420 es un número asociado con la cultura del cannabis, lo que ha llevado a algunos desarrolladores a usarlo humorísticamente en contextos relacionados. La falta de estandarización del código 420 ilustra perfectamente por qué es importante que los desarrolladores se adhieran a los códigos de estado HTTP oficiales en lugar de inventar los suyos propios. Cada servicio que usa 420 le da un significado diferente, lo que causa confusión para los clientes que intentan manejar las respuestas. En la práctica moderna, el uso de 420 ha disminuido significativamente: Twitter migró a usar el código estándar 429 Too Many Requests para rate limiting, que es el código correcto y oficial para ese propósito. Spring Framework también dejó de usar 420 en favor de códigos más apropiados y estándar. Hoy en día, 420 ocasionalmente aparece como easter egg humorístico en APIs (especialmente el 20 de abril, '4/20' en formato de fecha estadounidense), pero NO debe usarse en aplicaciones de producción serias. Los desarrolladores deben usar códigos estándar como 429 para rate limiting, 500 para fallos de métodos del servidor, o códigos apropiados según el contexto específico.",
        "useCases": [
            "Twitter (deprecado): Rate limiting - 'Enhance Your Calm' (ahora usa 429)",
            "Spring Framework (antiguo): Fallo de método (deprecado)",
            "Easter eggs humorísticos (especialmente 4/20)",
            "Uso en cultura de internet relacionado con cannabis (humorístico)",
            "NOTA: NO es estándar y NO debe usarse en producción"
        ],
        "examples": [
            {
                "scenario": "Twitter legacy - Rate limiting (uso histórico)",
                "request": "GET /1.1/statuses/user_timeline.json?count=200 HTTP/1.1\nHost: api.twitter.com\nAuthorization: Bearer user_access_token\n\n[solicitud número 181 en la última hora, excediendo límite de 180]",
                "response": "HTTP/1.1 420 Enhance Your Calm\nX-Rate-Limit-Limit: 180\nX-Rate-Limit-Remaining: 0\nX-Rate-Limit-Reset: 1705512000\nRetry-After: 3600\nContent-Type: application/json\n\n{\n  \"errors\": [\n    {\n      \"code\": 88,\n      \"message\": \"Rate limit exceeded\"\n    }\n  ],\n  \"status\": 420,\n  \"status_text\": \"Enhance Your Calm\",\n  \"explanation\": \"You have exceeded the rate limit for this endpoint\",\n  \"limit\": 180,\n  \"remaining\": 0,\n  \"reset_time\": \"2024-01-17T20:00:00Z\",\n  \"retry_after_seconds\": 3600,\n  \"humorous_message\": \"Whoa there, partner! Slow down and enhance your calm. You've made too many requests.\",\n  \"note\": \"This is a deprecated Twitter-specific code. Modern APIs should use 429 Too Many Requests instead.\"\n}",
                "explanation": "USO HISTÓRICO: Twitter usaba 420 con el mensaje humorístico 'Enhance Your Calm' para rate limiting. Este código ya NO se usa; Twitter/X migró al estándar 429 Too Many Requests. Se muestra solo con propósitos históricos/educativos."
            },
            {
                "scenario": "Alternativa CORRECTA usando 429 Too Many Requests",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1705512000\nRetry-After: 3600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded the rate limit\",\n  \"limit\": 100,\n  \"limit_window\": \"1 hour\",\n  \"remaining\": 0,\n  \"reset_at\": \"2024-01-17T20:00:00Z\",\n  \"retry_after_seconds\": 3600,\n  \"current_plan\": \"free\",\n  \"upgrade_info\": {\n    \"basic_plan\": \"500 requests/hour for $9.99/month\",\n    \"pro_plan\": \"5,000 requests/hour for $29.99/month\"\n  },\n  \"best_practice\": \"This uses standard HTTP 429, not non-standard 420\",\n  \"documentation\": \"https://api.example.com/docs/rate-limits\"\n}",
                "explanation": "MEJOR PRÁCTICA: Usar el código estándar 429 Too Many Requests para rate limiting en lugar del no estándar 420. Esto garantiza compatibilidad con todos los clientes HTTP y herramientas."
            },
            {
                "scenario": "Easter egg humorístico (4/20 reference)",
                "request": "GET /api/secret-endpoint HTTP/1.1\nHost: fun-api.example.com\nX-Special-Date: 2024-04-20",
                "response": "HTTP/1.1 420 Enhance Your Calm\nContent-Type: application/json\nX-Easter-Egg: true\n\n{\n  \"status\": 420,\n  \"message\": \"Enhance Your Calm\",\n  \"special_message\": \"Happy 4/20! 🌿\",\n  \"easter_egg\": true,\n  \"fun_facts\": [\n    \"420 is not an official HTTP status code\",\n    \"Twitter used it for rate limiting (now uses 429)\",\n    \"In internet culture, 420 has... other meanings\",\n    \"This is just a fun easter egg, not a real error!\"\n  ],\n  \"actual_response\": {\n    \"status\": 200,\n    \"data\": \"Your actual data here\",\n    \"message\": \"Everything is fine, this was just a playful response\"\n  },\n  \"note\": \"This is purely for entertainment. In production, always use standard HTTP codes.\",\n  \"seriously_though\": \"Don't use 420 in real APIs. Use proper codes like 429, 500, etc.\"\n}",
                "explanation": "Algunos desarrolladores usan 420 como easter egg humorístico, especialmente el 20 de abril (4/20). Aunque divertido, NO debe usarse para errores reales en producción. Este ejemplo es puramente educativo sobre el uso cultural del código."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP oficial)",
        "specification": "No oficial - Múltiples usos conflictivos no estandarizados",
        "relatedHeaders": [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset",
            "Retry-After"
        ],
        "relatedCodes": [
            429,
            500
        ],
        "technicalNotes": "420 NO es un código HTTP estándar oficial. Múltiples usos conflictivos: (1) Twitter: 'Enhance Your Calm' para rate limiting (DEPRECADO, ahora usa 429), (2) Spring Framework: 'Method Failure' (DEPRECADO), (3) Referencias culturales de internet (4/20). NUNCA usar en producción. Para rate limiting: usa 429 Too Many Requests (estándar oficial desde RFC 6585). Para fallos de método del servidor: usa 500 Internal Server Error o códigos 5xx apropiados. El uso de códigos no estándar causa: problemas de interoperabilidad, confusión en clientes HTTP, dificultades de debugging, incompatibilidad con herramientas de monitoreo. La historia de 420 es un ejemplo perfecto de por qué NO inventar códigos propios. Twitter eventualmente migró a 429 estándar, demostrando que los estándares existen por buenas razones.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783438/420_m0ml53.png",
                "alt": "Imagen que representa el nombre del código 420 Method Failure"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/45-removebg-preview_ehbtbc.png",
                "alt": "Imagen del código 420 Method Failure"
            }
        ]
    },
    {
        "code": 421,
        "status": "Misdirected Request",
        "category": "Client Error",
        "description": "El código 421 Misdirected Request indica que la solicitud fue dirigida a un servidor que no es capaz de producir una respuesta. Este código fue introducido específicamente para HTTP/2 y está relacionado con la característica de multiplexación de conexiones de HTTP/2, donde múltiples nombres de host pueden compartir la misma conexión TCP. El servidor está diciendo: 'Recibí tu solicitud, pero está dirigida al nombre de host o esquema incorrecto para este servidor, y no puedo procesarla'. Este código es particularmente relevante en escenarios de HTTP/2 donde un cliente puede reutilizar una conexión existente para hacer solicitudes a diferentes hosts que comparten la misma dirección IP (algo común con CDNs, hosting compartido, o cuando múltiples dominios están detrás del mismo servidor). El problema surge cuando el cliente asume incorrectamente que el servidor puede manejar solicitudes para un host específico solo porque comparte la misma conexión o IP. Por ejemplo, imagine que un cliente establece una conexión HTTP/2 con 'www.example.com' (IP: 192.0.2.1). Luego descubre que 'api.example.com' también apunta a 192.0.2.1. El cliente podría intentar reutilizar la conexión existente para hacer solicitudes a 'api.example.com'. Si el servidor en esa conexión no está configurado para manejar 'api.example.com', responderá con 421. Las causas comunes incluyen: certificado TLS/SSL que no incluye el nombre de host solicitado en su Subject Alternative Name (SAN), servidor configurado para solo responder a ciertos nombres de host específicos, proxy o CDN que no puede enrutar la solicitud al backend correcto, o configuración de virtual host que no incluye el dominio solicitado. Cuando un cliente recibe 421, debe reintentar la solicitud en una nueva conexión directamente al host correcto, sin intentar reutilizar la conexión existente. El código 421 es fundamental para la seguridad en HTTP/2, ya que previene que los clientes hagan suposiciones incorrectas sobre qué hosts puede manejar una conexión compartida.",
        "useCases": [
            "HTTP/2: Solicitud a host incorrecto en conexión compartida/multiplexada",
            "Certificado TLS no incluye el dominio solicitado en SAN",
            "Virtual host no configurado para el nombre de host solicitado",
            "CDN o proxy no puede enrutar solicitud al backend apropiado",
            "Cliente intenta reutilizar conexión para host no autorizado",
            "Mismatch entre SNI (Server Name Indication) y Host header",
            "Configuración de servidor que restringe hosts permitidos por conexión"
        ],
        "examples": [
            {
                "scenario": "HTTP/2 - Reutilización incorrecta de conexión para diferente host",
                "request": "GET /api/data HTTP/2\nHost: api.example.com\nUser-Agent: HTTP2-Client/1.0\n\n[Esta solicitud se envió por una conexión HTTP/2 existente que fue establecida originalmente para www.example.com]",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"This server cannot produce a response for the requested host\",\n  \"requested_host\": \"api.example.com\",\n  \"connection_established_for\": \"www.example.com\",\n  \"issue\": \"Connection was established for www.example.com but request is for api.example.com\",\n  \"explanation\": \"While both domains may share the same IP address, this server is not configured to handle requests for api.example.com on this connection\",\n  \"http_version\": \"HTTP/2\",\n  \"reason\": \"The TLS certificate or virtual host configuration does not include api.example.com\",\n  \"action_required\": \"Establish a new connection specifically to api.example.com and retry the request\",\n  \"technical_details\": {\n    \"connection_reuse_attempted\": true,\n    \"tls_sni\": \"www.example.com\",\n    \"requested_authority\": \"api.example.com\",\n    \"certificate_sans\": [\"www.example.com\", \"example.com\"],\n    \"api_example_com_in_certificate\": false\n  },\n  \"recommendation\": \"Do not reuse this connection for api.example.com. Open a new connection.\",\n  \"rfc_reference\": \"RFC 7540, Section 9.1.2\"\n}",
                "explanation": "El cliente intentó reutilizar una conexión HTTP/2 existente (establecida para www.example.com) para hacer una solicitud a api.example.com. Sin embargo, el certificado TLS del servidor no incluye api.example.com en sus Subject Alternative Names, por lo que responde con 421 indicando que esta solicitud está mal dirigida."
            },
            {
                "scenario": "Certificado TLS sin el dominio solicitado",
                "request": ":method: GET\n:scheme: https\n:authority: subdomain.example.com\n:path: /resource\nuser-agent: Mozilla/5.0",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"TLS certificate does not cover the requested hostname\",\n  \"requested_hostname\": \"subdomain.example.com\",\n  \"tls_certificate_info\": {\n    \"common_name\": \"example.com\",\n    \"subject_alternative_names\": [\n      \"example.com\",\n      \"www.example.com\",\n      \"*.apps.example.com\"\n    ],\n    \"subdomain_covered\": false,\n    \"wildcard_match\": false\n  },\n  \"issue\": \"The SSL/TLS certificate presented during connection establishment does not include subdomain.example.com\",\n  \"security_concern\": \"Serving content for a hostname not in the certificate would be a security violation\",\n  \"resolution\": [\n    \"Establish a new HTTPS connection directly to subdomain.example.com\",\n    \"Verify that subdomain.example.com has a valid certificate\",\n    \"Do not attempt to reuse connections established for other domains\"\n  ],\n  \"note\": \"HTTP/2 connection multiplexing is limited to hosts covered by the TLS certificate\",\n  \"correct_hosts_for_this_connection\": [\n    \"example.com\",\n    \"www.example.com\",\n    \"*.apps.example.com\"\n  ]\n}",
                "explanation": "El certificado TLS de la conexión no incluye 'subdomain.example.com' en su lista de nombres alternativos. Por razones de seguridad, el servidor no puede servir contenido para un hostname que no está en el certificado, por lo que responde 421."
            },
            {
                "scenario": "Virtual host no configurado para el dominio solicitado",
                "request": "GET /home HTTP/2\nHost: newdomain.example.com",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"Server is not configured to handle this hostname\",\n  \"requested_host\": \"newdomain.example.com\",\n  \"server_ip\": \"203.0.113.50\",\n  \"configured_virtual_hosts\": [\n    \"example.com\",\n    \"www.example.com\",\n    \"blog.example.com\",\n    \"shop.example.com\"\n  ],\n  \"issue\": \"This server does not have a virtual host configuration for newdomain.example.com\",\n  \"explanation\": \"While newdomain.example.com may DNS-resolve to this server's IP, the server is not configured to serve content for this domain\",\n  \"possible_causes\": [\n    \"The domain was recently added but server config not updated\",\n    \"DNS was updated but points to wrong server\",\n    \"Virtual host configuration is missing or incomplete\"\n  ],\n  \"action_for_client\": \"Do not retry on this connection. Verify the correct server for newdomain.example.com\",\n  \"action_for_admin\": \"If newdomain.example.com should be served from this server, add virtual host configuration and reload server\",\n  \"dns_info\": \"Verify that newdomain.example.com DNS points to the correct server\"\n}",
                "explanation": "Aunque newdomain.example.com puede resolver a la misma IP que esta conexión, el servidor no tiene una configuración de virtual host para ese dominio. El servidor responde 421 indicando que no puede manejar solicitudes para ese hostname."
            }
        ],
        "httpVersion": "HTTP/2, HTTP/3",
        "specification": "RFC 7540, Section 9.1.2 (HTTP/2)",
        "relatedHeaders": [
            "Host",
            ":authority (HTTP/2 pseudo-header)"
        ],
        "relatedCodes": [
            400,
            404
        ],
        "technicalNotes": "421 fue introducido específicamente para HTTP/2 para manejar problemas de multiplexación de conexiones. En HTTP/2, múltiples requests a diferentes hosts pueden compartir la misma conexión TCP si los hosts comparten la misma IP. Sin embargo, esto está limitado por: (1) el certificado TLS debe cubrir todos los hosts (via SAN), (2) el servidor debe estar configurado para manejar esos hosts. Cuando un cliente recibe 421, DEBE reintentar la solicitud en una nueva conexión, no puede seguir usando la conexión actual para ese host. Esto previene problemas de seguridad donde un servidor podría servir contenido para un host que no está autorizado a manejar. 421 es diferente de 404: 404 significa que el recurso no existe en el host correcto; 421 significa que el host en sí es incorrecto para esta conexión. En HTTP/1.1, 421 es raro porque cada conexión típicamente va a un solo host.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783439/421_w2uwvz.png",
                "alt": "Imagen que representa el nombre del código 421 Misdirected Request"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/46-removebg-preview_fc6zow.png",
                "alt": "Imagen del código 421 Misdirected Request"
            }
        ]
    },
    {
        "code": 422,
        "status": "Unprocessable Entity",
        "category": "Client Error",
        "description": "El código 422 Unprocessable Entity indica que el servidor entiende el tipo de contenido de la solicitud (el formato es correcto), y la sintaxis de la entidad de la solicitud es correcta, pero fue incapaz de procesar las instrucciones contenidas debido a errores de validación semántica o lógica de negocio. Este código es fundamental para distinguir entre diferentes tipos de errores de validación. La diferencia clave con otros códigos similares es: 400 Bad Request se usa para errores de sintaxis o formato (JSON malformado, parámetros faltantes), 409 Conflict se usa cuando hay un conflicto con el estado actual del recurso (email duplicado, versión incorrecta), mientras que 422 se usa específicamente cuando la sintaxis es correcta pero los datos no tienen sentido semántico o violan reglas de negocio. El servidor está diciendo: 'Entiendo tu solicitud perfectamente en términos de formato, pero los datos que enviaste no son válidos según las reglas de mi lógica de negocio'. El código 422 fue originalmente definido en WebDAV (RFC 4918) pero ha sido ampliamente adoptado por APIs RESTful modernas porque llena un vacío importante: proporciona un código específico para errores de validación semántica. Los ejemplos típicos incluyen: una fecha de nacimiento en el futuro (sintácticamente es una fecha válida, pero semánticamente no tiene sentido), un número de teléfono con formato correcto pero con longitud inválida para el país especificado, un precio negativo donde solo se permiten valores positivos, un enum con valor sintácticamente válido pero que no existe en el sistema, o reglas de negocio complejas como 'la fecha de fin debe ser posterior a la fecha de inicio'. Las respuestas 422 bien diseñadas deben incluir información detallada sobre qué campos específicos fallaron la validación, qué regla fue violada, y cómo corregir el problema. Esto hace que las APIs sean más fáciles de usar y debuggear.",
        "useCases": [
            "Errores de validación semántica (datos bien formados pero inválidos)",
            "Violación de reglas de negocio en los datos enviados",
            "Valores fuera de rango permitido (edad negativa, precio negativo)",
            "Fechas lógicamente inválidas (fecha de nacimiento en el futuro)",
            "Relaciones de datos inconsistentes (fecha fin antes de fecha inicio)",
            "Enums o valores de lista que no existen en el sistema",
            "Campos que no cumplen reglas de formato específicas del negocio",
            "Validaciones que dependen del contexto o estado del sistema"
        ],
        "examples": [
            {
                "scenario": "Validación semántica - Fecha de nacimiento en el futuro",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"birth_date\": \"2030-05-15\",\n  \"country\": \"US\"\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"The request contains semantically invalid data\",\n  \"errors\": [\n    {\n      \"field\": \"birth_date\",\n      \"value\": \"2030-05-15\",\n      \"error_code\": \"date_in_future\",\n      \"message\": \"Birth date cannot be in the future\",\n      \"current_date\": \"2024-01-17\",\n      \"validation_rule\": \"birth_date must be <= current_date\",\n      \"suggestion\": \"Please provide a valid birth date in the past\"\n    }\n  ],\n  \"note\": \"The JSON syntax is correct and the date format is valid, but the value doesn't make semantic sense\",\n  \"documentation\": \"https://api.example.com/docs/validation-rules\"\n}",
                "explanation": "El JSON está bien formado y la fecha tiene el formato correcto (YYYY-MM-DD), pero semánticamente no tiene sentido tener una fecha de nacimiento en el futuro. Este es un error de validación lógica, no sintáctica, por lo que se usa 422."
            },
            {
                "scenario": "Violación de reglas de negocio - Relaciones de datos inconsistentes",
                "request": "POST /api/events HTTP/1.1\nHost: calendar.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"title\": \"Project Meeting\",\n  \"start_date\": \"2024-02-15T14:00:00Z\",\n  \"end_date\": \"2024-02-15T13:00:00Z\",\n  \"location\": \"Conference Room A\",\n  \"attendees\": [\"user1@example.com\", \"user2@example.com\"]\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Event data violates business rules\",\n  \"errors\": [\n    {\n      \"field\": \"end_date\",\n      \"error_code\": \"invalid_date_range\",\n      \"message\": \"End date must be after start date\",\n      \"start_date\": \"2024-02-15T14:00:00Z\",\n      \"end_date\": \"2024-02-15T13:00:00Z\",\n      \"issue\": \"End date (13:00) is before start date (14:00)\",\n      \"business_rule\": \"end_date > start_date\",\n      \"suggestion\": \"Ensure the end time is later than the start time\"\n    }\n  ],\n  \"fields_validated\": {\n    \"title\": \"valid\",\n    \"start_date\": \"valid format\",\n    \"end_date\": \"valid format, but violates business rule\",\n    \"location\": \"valid\",\n    \"attendees\": \"valid\"\n  },\n  \"note\": \"All fields have correct syntax and format, but the relationship between start_date and end_date is logically invalid\"\n}",
                "explanation": "Ambas fechas tienen formato correcto (ISO 8601), pero la lógica de negocio requiere que end_date sea posterior a start_date. Esta es una validación semántica que requiere 422, no 400 (que sería para formato inválido)."
            },
            {
                "scenario": "Múltiples errores de validación semántica",
                "request": "POST /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"AB\",\n  \"price\": -25.99,\n  \"stock\": 150,\n  \"category\": \"invalid_category_xyz\",\n  \"discount_percentage\": 105,\n  \"weight\": 0,\n  \"dimensions\": {\n    \"length\": 10,\n    \"width\": -5,\n    \"height\": 8\n  }\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Multiple validation errors in product data\",\n  \"total_errors\": 5,\n  \"errors\": [\n    {\n      \"field\": \"name\",\n      \"value\": \"AB\",\n      \"error_code\": \"min_length\",\n      \"message\": \"Product name must be at least 3 characters long\",\n      \"current_length\": 2,\n      \"required_length\": 3\n    },\n    {\n      \"field\": \"price\",\n      \"value\": -25.99,\n      \"error_code\": \"negative_value\",\n      \"message\": \"Price cannot be negative\",\n      \"constraint\": \"price >= 0\"\n    },\n    {\n      \"field\": \"category\",\n      \"value\": \"invalid_category_xyz\",\n      \"error_code\": \"invalid_enum\",\n      \"message\": \"Category is not valid\",\n      \"valid_categories\": [\"electronics\", \"clothing\", \"books\", \"food\", \"toys\"],\n      \"suggestion\": \"Choose from the list of valid categories\"\n    },\n    {\n      \"field\": \"discount_percentage\",\n      \"value\": 105,\n      \"error_code\": \"out_of_range\",\n      \"message\": \"Discount percentage must be between 0 and 100\",\n      \"min\": 0,\n      \"max\": 100\n    },\n    {\n      \"field\": \"dimensions.width\",\n      \"value\": -5,\n      \"error_code\": \"negative_dimension\",\n      \"message\": \"Width cannot be negative\",\n      \"constraint\": \"width > 0\"\n    }\n  ],\n  \"note\": \"All fields are syntactically correct (proper types, valid JSON), but fail semantic/business validation\"\n}",
                "explanation": "El JSON está perfectamente formado y todos los tipos de datos son correctos, pero múltiples campos fallan validaciones de lógica de negocio: nombre muy corto, precio negativo, categoría inexistente, descuento mayor a 100%, dimensión negativa. Todos son errores semánticos, no sintácticos."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), adoptado ampliamente por APIs REST",
        "relatedHeaders": [
            "Content-Type"
        ],
        "relatedCodes": [
            400,
            409
        ],
        "technicalNotes": "422 es para errores de VALIDACIÓN SEMÁNTICA/LÓGICA, no sintáctica. Diferencias clave: 400 Bad Request = sintaxis incorrecta, JSON malformado, tipos incorrectos; 422 Unprocessable Entity = sintaxis correcta, pero datos semánticamente inválidos o violan reglas de negocio; 409 Conflict = datos válidos pero conflicto con estado actual del recurso. Originalmente de WebDAV (RFC 4918) pero ampliamente adoptado por APIs REST modernas. Las mejores prácticas para respuestas 422: incluir array detallado de errores, especificar qué campo falló, explicar qué regla fue violada, proporcionar valores aceptables/rangos, sugerir cómo corregir. 422 hace APIs más usables al distinguir claramente entre errores de sintaxis vs semántica.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783439/422_auwvoq.png",
                "alt": "Imagen que representa el nombre del código 422 Unprocessable Entity"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/47-removebg-preview_oj0vvy.png",
                "alt": "Imagen del código 422 Unprocessable Entity"
            }
        ]
    },
    {
        "code": 423,
        "status": "Locked",
        "category": "Client Error",
        "description": "El código 423 Locked indica que el recurso al que se está intentando acceder está bloqueado (locked). Este código fue definido originalmente como parte de la extensión WebDAV (Web Distributed Authoring and Versioning) del protocolo HTTP, que permite a los usuarios editar y gestionar archivos en servidores web remotos de forma colaborativa. El concepto de 'locking' es fundamental en sistemas de edición colaborativa para prevenir conflictos cuando múltiples usuarios intentan modificar el mismo recurso simultáneamente. El servidor está diciendo: 'Este recurso está bloqueado actualmente y no puede ser modificado hasta que se libere el bloqueo'. Los bloqueos en WebDAV pueden ser de dos tipos: (1) bloqueos exclusivos (exclusive locks) donde solo el propietario del bloqueo puede modificar el recurso, y (2) bloqueos compartidos (shared locks) donde múltiples usuarios pueden leer pero ninguno puede modificar hasta que todos los bloqueos se liberen. Cuando un recurso está bloqueado, las operaciones que intentan modificarlo (PUT, PATCH, DELETE, MOVE, COPY) fallarán con 423. Sin embargo, las operaciones de solo lectura (GET, HEAD) generalmente siguen siendo permitidas. Los bloqueos típicamente incluyen: un token de bloqueo único que identifica el bloqueo, información sobre quién tiene el bloqueo, un timeout después del cual el bloqueo expira automáticamente si no se renueva, y el alcance del bloqueo (el recurso específico o una colección completa). Aunque 423 se originó en WebDAV, también puede ser útil en APIs REST modernas que implementan mecanismos de bloqueo pesimista para gestionar concurrencia. Por ejemplo, un sistema de gestión de documentos podría bloquear un documento cuando un usuario comienza a editarlo, respondiendo con 423 a otros usuarios que intenten modificarlo simultáneamente. El código 423 es diferente de 409 Conflict: 409 se usa para conflictos de concurrencia optimista (donde detectas el conflicto después de que ocurrió), mientras que 423 se usa para concurrencia pesimista (donde previenes el conflicto bloqueando el recurso por adelantado).",
        "useCases": [
            "WebDAV: Recurso bloqueado durante edición colaborativa de archivos",
            "Documentos bloqueados mientras un usuario los está editando",
            "Recursos administrativos bloqueados durante operaciones de mantenimiento",
            "Archivos en proceso de revisión o aprobación que no pueden modificarse",
            "Registros de base de datos bloqueados para prevenir modificaciones concurrentes",
            "Recursos en workflow que requieren completar pasos antes de modificación",
            "Contenido bloqueado por razones legales o de cumplimiento",
            "Sistemas de checkout/checkin donde el recurso está 'checked out' por otro usuario"
        ],
        "examples": [
            {
                "scenario": "WebDAV - Intento de modificar archivo bloqueado",
                "request": "PUT /documents/quarterly-report.docx HTTP/1.1\nHost: webdav.example.com\nContent-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document\nAuthorization: Bearer user_token_jane\nContent-Length: 524288\n\n[binary document data]",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:error xmlns:D=\"DAV:\">\n  <D:lock-token-submitted>\n    <D:href>/documents/quarterly-report.docx</D:href>\n  </D:lock-token-submitted>\n  <D:resource-locked>\n    <D:message>The resource is locked and cannot be modified</D:message>\n    <D:lock-owner>john.smith@example.com</D:lock-owner>\n    <D:lock-type>exclusive write</D:lock-type>\n    <D:lock-scope>exclusive</D:lock-scope>\n    <D:lock-token>opaquelocktoken:f81d4fae-7dec-11d0-a765-00a0c91e6bf6</D:lock-token>\n    <D:lock-created>2024-01-17T14:30:00Z</D:lock-created>\n    <D:lock-timeout>Second-7200</D:lock-timeout>\n    <D:lock-expires>2024-01-17T16:30:00Z</D:lock-expires>\n  </D:resource-locked>\n</D:error>",
                "explanation": "El usuario Jane intenta modificar un documento, pero está bloqueado exclusivamente por John Smith quien lo está editando. El servidor responde con 423 proporcionando información sobre quién tiene el bloqueo y cuándo expira."
            },
            {
                "scenario": "API REST moderna - Documento en edición",
                "request": "PATCH /api/documents/789 HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\nAuthorization: Bearer user_b_token\n\n{\n  \"title\": \"Updated Title\",\n  \"content\": \"Updated content...\"\n}",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/json\n\n{\n  \"error\": \"resource_locked\",\n  \"message\": \"This document is currently locked by another user\",\n  \"resource_id\": 789,\n  \"resource_type\": \"document\",\n  \"resource_title\": \"Project Proposal Q1 2024\",\n  \"lock_info\": {\n    \"locked\": true,\n    \"lock_type\": \"exclusive\",\n    \"locked_by\": {\n      \"user_id\": \"user_a_123\",\n      \"name\": \"Alice Johnson\",\n      \"email\": \"alice.johnson@example.com\"\n    },\n    \"locked_at\": \"2024-01-17T15:00:00Z\",\n    \"lock_duration\": \"30 minutes\",\n    \"lock_expires_at\": \"2024-01-17T15:30:00Z\",\n    \"time_remaining\": \"15 minutes\",\n    \"reason\": \"User is actively editing the document\"\n  },\n  \"allowed_operations\": [\n    \"GET /api/documents/789 (view document)\",\n    \"GET /api/documents/789/history (view history)\",\n    \"POST /api/documents/789/comments (add comments)\"\n  ],\n  \"suggestions\": [\n    \"Wait until the lock expires (15 minutes remaining)\",\n    \"Contact alice.johnson@example.com to request they release the lock\",\n    \"Subscribe to lock release notifications: POST /api/documents/789/watch\"\n  ],\n  \"note\": \"The document can still be viewed but cannot be modified while locked\"\n}",
                "explanation": "En una API REST moderna, el usuario B intenta modificar un documento que está siendo editado por el usuario A. El sistema usa bloqueo pesimista (423) en lugar de control de concurrencia optimista (409) para prevenir conflictos antes de que ocurran."
            },
            {
                "scenario": "Recurso bloqueado administrativamente",
                "request": "DELETE /api/products/critical-item-001 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer regular_user_token",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/json\n\n{\n  \"error\": \"resource_locked\",\n  \"message\": \"This product is locked and cannot be deleted\",\n  \"resource_id\": \"critical-item-001\",\n  \"resource_name\": \"Legacy System Integration Component\",\n  \"lock_info\": {\n    \"locked\": true,\n    \"lock_type\": \"administrative\",\n    \"locked_by\": \"system_administrator\",\n    \"locked_at\": \"2024-01-10T09:00:00Z\",\n    \"lock_reason\": \"Critical component required for legacy system integration. Deletion would break production systems.\",\n    \"lock_permanent\": true,\n    \"unlock_requires\": \"System administrator approval and impact assessment\"\n  },\n  \"impact_warning\": {\n    \"dependent_systems\": 15,\n    \"active_integrations\": 23,\n    \"estimated_downtime_if_deleted\": \"4-8 hours\",\n    \"affected_users\": \"approximately 5,000\"\n  },\n  \"alternative_actions\": [\n    \"Mark as deprecated instead: PATCH /api/products/critical-item-001/deprecate\",\n    \"Create replacement: POST /api/products (then migrate integrations)\",\n    \"Request administrative unlock: POST /api/admin/unlock-requests\"\n  ],\n  \"contact\": \"For unlock requests, contact: admin-team@example.com\",\n  \"documentation\": \"https://docs.example.com/critical-resources\"\n}",
                "explanation": "Un producto crítico está bloqueado administrativamente para prevenir eliminación accidental que causaría problemas en producción. El bloqueo es permanente y requiere aprobación administrativa para removerse. Se proporcionan alternativas y contexto sobre el impacto."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.3",
        "relatedHeaders": [
            "Lock-Token",
            "If",
            "Timeout"
        ],
        "relatedCodes": [
            409
        ],
        "technicalNotes": "423 es específico de WebDAV pero puede usarse en APIs REST para bloqueo pesimista. Diferencias clave: 423 Locked = recurso activamente bloqueado, prevención proactiva de conflictos (concurrencia pesimista); 409 Conflict = conflicto detectado después de ocurrir (concurrencia optimista). En WebDAV, los bloqueos se crean con LOCK method, se liberan con UNLOCK method. Los bloqueos incluyen: lock token (identificador único), owner (quién tiene el bloqueo), timeout (cuándo expira), scope (exclusive o shared), depth (recurso individual o colección). Las operaciones de lectura (GET) generalmente están permitidas en recursos bloqueados. Los bloqueos pueden ser: temporales (con timeout) o indefinidos. La respuesta 423 debe incluir información sobre el bloqueo para ayudar al usuario a entender cuándo/cómo proceder. En APIs modernas, considerar si bloqueo pesimista (423) o optimista (409 con ETags) es más apropiado.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783439/423_vqb1x2.png",
                "alt": "Imagen que representa el nombre del código 423 Locked"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/48-removebg-preview_wrwpey.png",
                "alt": "Imagen del código 423 Locked"
            }
        ]
    },
    {
        "code": 424,
        "status": "Failed Dependency",
        "category": "Client Error",
        "description": "El código 424 Failed Dependency indica que la solicitud falló debido a que una solicitud previa ha fallado. Este código fue definido originalmente en la extensión WebDAV (RFC 4918) y se utiliza principalmente en contexto de solicitudes que dependen de otras solicitudes previas para tener éxito. El servidor está diciendo: 'No puedo procesar tu solicitud porque depende de otra operación que falló anteriormente'. Este código es especialmente relevante en operaciones batch o transaccionales donde múltiples acciones están relacionadas y el fallo de una causa que las subsecuentes también fallen. En el contexto WebDAV original, esto ocurre típicamente con el método PROPPATCH (que modifica propiedades de recursos) o en operaciones complejas que involucran múltiples recursos. Por ejemplo, si intentas copiar una estructura completa de directorios pero una de las carpetas intermedias no puede ser creada, las operaciones subsecuentes que dependían de esa carpeta fallarán con 424. El código 424 comunica que el fallo no es culpa de la solicitud actual en sí misma, sino de una dependencia que no se cumplió. Aunque 424 se originó en WebDAV, también puede ser útil en APIs REST modernas que implementan operaciones transaccionales o en cadena. Por ejemplo, en una API que procesa un flujo de trabajo de múltiples pasos, si el paso 2 falla, el paso 3 podría fallar con 424 indicando que no pudo proceder debido a la falla del paso 2. Es importante distinguir 424 de otros códigos similares: 412 Precondition Failed se usa cuando una precondición especificada en headers no se cumple, 422 Unprocessable Entity se usa para errores de validación semántica de la solicitud actual, mientras que 424 se usa específicamente cuando el fallo es debido a una dependencia externa o previa que falló. El código 424 es relativamente raro en APIs web modernas porque muchos sistemas prefieren manejar dependencias de manera diferente, como transacciones all-or-nothing o respuestas parciales con códigos de éxito/error individuales.",
        "useCases": [
            "WebDAV: Operación que depende de otra operación que falló",
            "APIs batch donde una operación falla y causa que dependencias fallen",
            "Workflows de múltiples pasos donde paso anterior falló",
            "Operaciones transaccionales en cadena con dependencias",
            "Creación de recursos jerárquicos donde padre no pudo crearse",
            "Procesamiento de solicitudes compuestas donde componentes dependen entre sí",
            "Operaciones que requieren recursos previos que no se pudieron crear"
        ],
        "examples": [
            {
                "scenario": "WebDAV - Copia de estructura con dependencias fallidas",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup/source-folder/\nDepth: infinity\nOverwrite: F",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n  <D:response>\n    <D:href>/source-folder/</D:href>\n    <D:status>HTTP/1.1 201 Created</D:status>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/</D:href>\n    <D:status>HTTP/1.1 403 Forbidden</D:status>\n    <D:error>\n      <D:message>Insufficient permissions to create this folder</D:message>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/document.txt</D:href>\n    <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n    <D:error>\n      <D:message>Cannot copy file because parent folder creation failed</D:message>\n      <D:failed-dependency>/source-folder/subfolder1/</D:failed-dependency>\n      <D:dependency-error>403 Forbidden</D:dependency-error>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/image.jpg</D:href>\n    <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n    <D:error>\n      <D:message>Cannot copy file because parent folder creation failed</D:message>\n      <D:failed-dependency>/source-folder/subfolder1/</D:failed-dependency>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/readme.txt</D:href>\n    <D:status>HTTP/1.1 201 Created</D:status>\n  </D:response>\n</D:multistatus>",
                "explanation": "Se intentó copiar una estructura de carpetas completa. La carpeta raíz se creó exitosamente (201), pero subfolder1 falló con 403 por permisos insuficientes. Como resultado, los archivos dentro de subfolder1 (document.txt, image.jpg) no pudieron copiarse y reciben 424 Failed Dependency porque dependen de que la carpeta padre exista, lo cual falló."
            },
            {
                "scenario": "API REST - Workflow de múltiples pasos con dependencia fallida",
                "request": "POST /api/workflows/order-processing HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"order_id\": \"ORD-12345\",\n  \"steps\": [\n    {\"step\": \"validate_inventory\"},\n    {\"step\": \"reserve_items\"},\n    {\"step\": \"process_payment\"},\n    {\"step\": \"create_shipment\"},\n    {\"step\": \"send_confirmation\"}\n  ]\n}",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/json\n\n{\n  \"workflow_id\": \"WF-67890\",\n  \"order_id\": \"ORD-12345\",\n  \"overall_status\": \"partially_failed\",\n  \"steps_results\": [\n    {\n      \"step\": \"validate_inventory\",\n      \"status\": 200,\n      \"result\": \"success\",\n      \"message\": \"All items available in inventory\",\n      \"timestamp\": \"2024-01-17T16:00:00Z\"\n    },\n    {\n      \"step\": \"reserve_items\",\n      \"status\": 200,\n      \"result\": \"success\",\n      \"message\": \"Items reserved successfully\",\n      \"reservation_id\": \"RES-11111\",\n      \"timestamp\": \"2024-01-17T16:00:01Z\"\n    },\n    {\n      \"step\": \"process_payment\",\n      \"status\": 402,\n      \"result\": \"failed\",\n      \"error\": \"payment_declined\",\n      \"message\": \"Payment method declined by bank\",\n      \"decline_reason\": \"Insufficient funds\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    },\n    {\n      \"step\": \"create_shipment\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"dependency_failed\",\n      \"message\": \"Cannot create shipment because payment processing failed\",\n      \"failed_dependency\": \"process_payment\",\n      \"dependency_error\": \"payment_declined\",\n      \"explanation\": \"Shipment creation requires successful payment\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    },\n    {\n      \"step\": \"send_confirmation\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"dependency_failed\",\n      \"message\": \"Cannot send confirmation because payment failed\",\n      \"failed_dependency\": \"process_payment\",\n      \"explanation\": \"Confirmation can only be sent for successful orders\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    }\n  ],\n  \"successful_steps\": 2,\n  \"failed_steps\": 1,\n  \"failed_dependency_steps\": 2,\n  \"rollback_actions\": [\n    {\n      \"action\": \"release_reservation\",\n      \"reservation_id\": \"RES-11111\",\n      \"status\": \"completed\",\n      \"message\": \"Items returned to available inventory\"\n    }\n  ],\n  \"next_actions\": [\n    \"Update payment method\",\n    \"Retry workflow with valid payment\"\n  ]\n}",
                "explanation": "Un workflow de procesamiento de orden ejecuta múltiples pasos secuenciales. Los pasos 1 y 2 tienen éxito, pero el paso 3 (process_payment) falla con 402 porque la tarjeta fue declinada. Los pasos 4 y 5 (create_shipment, send_confirmation) no pueden proceder porque dependen de un pago exitoso, por lo que reciben 424 Failed Dependency. El sistema automáticamente revierte las reservaciones exitosas."
            },
            {
                "scenario": "Operación batch con dependencias entre items",
                "request": "POST /api/batch/create-project-structure HTTP/1.1\nHost: pm.example.com\nContent-Type: application/json\n\n{\n  \"project_name\": \"New Website Redesign\",\n  \"operations\": [\n    {\"type\": \"create_project\", \"name\": \"Website Redesign\"},\n    {\"type\": \"create_team\", \"project_ref\": \"@project\", \"name\": \"Design Team\"},\n    {\"type\": \"create_milestone\", \"project_ref\": \"@project\", \"name\": \"Design Phase\"},\n    {\"type\": \"assign_team_to_milestone\", \"team_ref\": \"@team\", \"milestone_ref\": \"@milestone\"}\n  ]\n}",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/json\n\n{\n  \"batch_id\": \"BATCH-999\",\n  \"operations_result\": [\n    {\n      \"operation\": 1,\n      \"type\": \"create_project\",\n      \"status\": 201,\n      \"result\": \"success\",\n      \"project_id\": \"PROJ-456\",\n      \"message\": \"Project created successfully\"\n    },\n    {\n      \"operation\": 2,\n      \"type\": \"create_team\",\n      \"status\": 409,\n      \"result\": \"failed\",\n      \"error\": \"team_name_conflict\",\n      \"message\": \"A team with name 'Design Team' already exists\",\n      \"existing_team_id\": \"TEAM-123\"\n    },\n    {\n      \"operation\": 3,\n      \"type\": \"create_milestone\",\n      \"status\": 201,\n      \"result\": \"success\",\n      \"milestone_id\": \"MILE-789\",\n      \"message\": \"Milestone created successfully\"\n    },\n    {\n      \"operation\": 4,\n      \"type\": \"assign_team_to_milestone\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"team_creation_failed\",\n      \"message\": \"Cannot assign team to milestone because team creation failed\",\n      \"failed_dependency\": \"create_team (operation 2)\",\n      \"dependency_error\": \"team_name_conflict\",\n      \"explanation\": \"This operation requires a newly created team, but team creation failed due to name conflict\"\n    }\n  ],\n  \"summary\": {\n    \"total_operations\": 4,\n    \"successful\": 2,\n    \"failed\": 1,\n    \"failed_dependencies\": 1\n  },\n  \"partial_success\": true,\n  \"created_resources\": [\n    {\"type\": \"project\", \"id\": \"PROJ-456\"},\n    {\"type\": \"milestone\", \"id\": \"MILE-789\"}\n  ],\n  \"resolution\": \"Use existing team TEAM-123 or rename the new team and retry operation 4\"\n}",
                "explanation": "Una operación batch intenta crear una estructura de proyecto completa. La creación de proyecto y milestone tienen éxito, pero la creación de equipo falla porque ya existe un equipo con ese nombre (409). La operación final de asignar el equipo al milestone recibe 424 Failed Dependency porque depende de la creación exitosa del nuevo equipo, que falló."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.4",
        "relatedHeaders": [],
        "relatedCodes": [
            207,
            412,
            422
        ],
        "technicalNotes": "424 indica que la solicitud actual falló debido a fallo de DEPENDENCIA PREVIA, no por error en la solicitud misma. Diferencias clave: 412 Precondition Failed = precondición en headers no cumplida; 422 Unprocessable Entity = error de validación en la solicitud actual; 424 Failed Dependency = fallo debido a dependencia externa/previa. Originalmente de WebDAV pero aplicable a APIs REST con operaciones dependientes. Típicamente aparece en respuestas 207 Multi-Status donde algunas operaciones tienen éxito y otras fallan. La respuesta debe indicar claramente QUÉ dependencia falló y POR QUÉ. Útil en: operaciones batch, workflows, transacciones complejas, jerarquías de recursos. Alternativas: algunas APIs prefieren all-or-nothing transactions con rollback completo en lugar de permitir fallos parciales con 424.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768783444/424_ghhg82.png",
                "alt": "Imagen que representa el nombre del código 424 Failed Dependency"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768775597/49-removebg-preview_ev4bvj.png",
                "alt": "Imagen del código 424 Failed Dependency"
            }
        ]
    },
    {
        "code": 425,
        "status": "Too Early",
        "category": "Client Error",
        "description": "El código 425 Too Early es un código de estado HTTP relativamente nuevo (estandarizado en RFC 8470 en 2018) que indica que el servidor no está dispuesto a arriesgarse a procesar una solicitud que podría ser reproducida (replayed). Este código está específicamente relacionado con la característica TLS 1.3 llamada '0-RTT' (Zero Round Trip Time resumption) o 'early data'. El concepto de 0-RTT permite que un cliente que previamente estableció una conexión TLS con un servidor pueda enviar datos de aplicación en el primer mensaje de la nueva conexión, antes de que el handshake TLS completo se haya completado. Esto reduce la latencia significativamente, pero introduce un riesgo de seguridad importante: los ataques de replay. En un ataque de replay, un atacante intercepta datos early data legítimos y los reenvía al servidor múltiples veces, potencialmente causando que la misma operación se ejecute repetidamente. El servidor está diciendo: 'Recibí tu solicitud en early data (0-RTT), pero esta operación no es segura para procesar en ese contexto porque podría ser reproducida, así que necesitas reenviarla en una conexión completamente establecida'. El código 425 es particularmente importante para operaciones no-idempotentes (aquellas que tienen efectos secundarios si se ejecutan múltiples veces), como crear recursos (POST), procesar pagos, o modificar estado del servidor. Las operaciones idempotentes (como GET, que puede ejecutarse múltiples veces con el mismo resultado) generalmente son seguras para procesar en early data. Cuando un servidor responde con 425, el cliente debe automáticamente reintentar la solicitud en una conexión TLS completamente establecida (no en early data). Este código es específico para escenarios donde TLS 1.3 con 0-RTT está en uso, por lo que es relativamente raro en comparación con códigos de error más tradicionales.",
        "useCases": [
            "TLS 1.3 0-RTT: Operaciones no-idempotentes enviadas en early data",
            "Prevención de ataques de replay en conexiones TLS con 0-RTT habilitado",
            "POST, PUT, DELETE u otras operaciones de modificación en early data",
            "Procesamiento de pagos o transacciones sensibles que no deben duplicarse",
            "Operaciones que tienen efectos secundarios y no son seguras para replay",
            "Cualquier solicitud no-idempotente recibida antes del handshake TLS completo"
        ],
        "examples": [
            {
                "scenario": "POST no-idempotente enviado en TLS 0-RTT early data",
                "request": "POST /api/orders HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\nAuthorization: Bearer user_token\n\n{\n  \"product_id\": \"PROD-789\",\n  \"quantity\": 2,\n  \"payment_method\": \"credit_card_ending_1234\"\n}\n\n[Esta solicitud fue enviada en TLS 1.3 0-RTT early data]",
                "response": "HTTP/1.1 425 Too Early\nContent-Type: application/json\n\n{\n  \"error\": \"too_early\",\n  \"message\": \"Request sent in TLS early data cannot be safely processed\",\n  \"reason\": \"This operation is not idempotent and could have dangerous side effects if replayed\",\n  \"tls_version\": \"TLS 1.3\",\n  \"early_data\": true,\n  \"operation_type\": \"POST\",\n  \"security_concern\": \"Replay attack risk\",\n  \"explanation\": \"Creating an order is a non-idempotent operation. If this request were replayed by an attacker, it would create duplicate orders and charge the customer multiple times.\",\n  \"what_to_do\": {\n    \"action\": \"Automatic retry required\",\n    \"description\": \"Your client should automatically retry this request on a fully established TLS connection (not in early data)\",\n    \"client_behavior\": \"Most modern HTTP clients handle this automatically\"\n  },\n  \"technical_details\": {\n    \"0_rtt_enabled\": true,\n    \"request_in_early_data\": true,\n    \"handshake_complete\": false,\n    \"safe_to_retry\": true,\n    \"retry_mechanism\": \"Establish full TLS handshake and resend\"\n  },\n  \"note\": \"This is a security feature to prevent replay attacks in TLS 1.3 0-RTT connections\",\n  \"documentation\": \"https://tools.ietf.org/html/rfc8470\"\n}",
                "explanation": "El cliente envió una solicitud POST para crear una orden en TLS 1.3 early data (0-RTT) para reducir latencia. Sin embargo, crear una orden no es idempotente - si se reproduce, crearía múltiples órdenes y cargos. El servidor responde 425 rechazando procesar la solicitud en early data. El cliente debe reintentarla automáticamente en una conexión TLS completamente establecida."
            },
            {
                "scenario": "Procesamiento de pago en early data rechazado",
                "request": "POST /api/payments/process HTTP/1.1\nHost: payments.example.com\nContent-Type: application/json\nIdempotency-Key: missing-or-ignored\n\n{\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"card_token\": \"tok_visa_4242\",\n  \"description\": \"Purchase of premium subscription\"\n}\n\n[Enviado en TLS 1.3 0-RTT early data]",
                "response": "HTTP/1.1 425 Too Early\nContent-Type: application/json\n\n{\n  \"error\": \"too_early\",\n  \"message\": \"Payment processing cannot be performed in TLS early data\",\n  \"operation\": \"payment_processing\",\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"security_risk\": \"replay_attack\",\n  \"risk_description\": \"If this payment request were replayed, the customer could be charged multiple times\",\n  \"severity\": \"critical\",\n  \"tls_context\": {\n    \"version\": \"TLS 1.3\",\n    \"0_rtt_used\": true,\n    \"early_data\": true,\n    \"handshake_state\": \"incomplete\"\n  },\n  \"client_action_required\": {\n    \"instruction\": \"Retry on fully established connection\",\n    \"automatic\": true,\n    \"note\": \"Modern HTTP/2 and HTTP/3 clients handle this automatically\"\n  },\n  \"prevention_mechanism\": \"Server policy: All payment operations require full TLS handshake completion\",\n  \"idempotency_note\": \"Even with Idempotency-Key header, we don't process payments in early data as an additional security layer\",\n  \"compliance\": \"PCI-DSS requires protection against replay attacks for payment processing\",\n  \"alternative\": \"Ensure your client waits for full TLS handshake before sending payment requests\"\n}",
                "explanation": "Un cliente intentó procesar un pago en TLS early data. Procesar pagos en early data es extremadamente peligroso porque un ataque de replay podría causar cargos duplicados al cliente. El servidor tiene una política estricta de rechazar TODAS las operaciones de pago en early data con 425, requiriendo que se reenvíen en una conexión completamente establecida."
            },
            {
                "scenario": "GET idempotente permitido en early data (contraste)",
                "request": "GET /api/products/123 HTTP/1.1\nHost: shop.example.com\nAccept: application/json\n\n[Enviado en TLS 1.3 0-RTT early data]",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nEarly-Data: 1\n\n{\n  \"product_id\": 123,\n  \"name\": \"Wireless Headphones\",\n  \"price\": 79.99,\n  \"in_stock\": true,\n  \"description\": \"High-quality wireless headphones with noise cancellation\",\n  \"note\": \"This GET request was safely processed in TLS 1.3 early data because it is idempotent and has no side effects. Reading data can be replayed safely.\"\n}",
                "explanation": "CONTRASTE: Un GET request es idempotente (puede ejecutarse múltiples veces sin efectos secundarios), por lo que es seguro procesarlo en early data incluso si fuera replicado. El servidor lo procesa normalmente con 200 OK. El encabezado Early-Data: 1 indica que fue procesado en early data. Las operaciones de solo lectura típicamente NO reciben 425."
            }
        ],
        "httpVersion": "HTTP/1.1, HTTP/2, HTTP/3 (con TLS 1.3)",
        "specification": "RFC 8470 (2018)",
        "relatedHeaders": [
            "Early-Data"
        ],
        "relatedCodes": [
            429
        ],
        "technicalNotes": "425 Too Early es ESPECÍFICO para TLS 1.3 con 0-RTT (early data) habilitado. 0-RTT permite enviar datos de aplicación en el primer mensaje para reducir latencia, pero crea riesgo de ataques de replay. El servidor debe rechazar operaciones NO IDEMPOTENTES en early data. Operaciones idempotentes (GET, HEAD, OPTIONS, algunos PUT idempotentes) generalmente son seguras en early data. Los clientes que reciben 425 deben automáticamente reintentar en conexión completamente establecida. El encabezado Early-Data: 1 en respuestas indica que la solicitud fue procesada en early data. Servidores pueden: (1) rechazar TODO early data, (2) rechazar solo operaciones no-idempotentes, (3) aceptar todo con mitigaciones. 425 es relativamente raro porque requiere TLS 1.3 + 0-RTT habilitado + operación no-idempotente. Importante para APIs que procesan transacciones, pagos, o modificaciones de estado.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784551/425_rc7ely.png",
                "alt": "Imagen que representa el nombre del código 425 Too Early"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784180/50-removebg-preview_ayb5gz.png",
                "alt": "Imagen del código 425 Too Early"
            }
        ]
    },
    {
        "code": 426,
        "status": "Upgrade Required",
        "category": "Client Error",
        "description": "El código 426 Upgrade Required indica que el servidor se niega a procesar la solicitud usando el protocolo actual, pero está dispuesto a hacerlo si el cliente actualiza a un protocolo diferente. El servidor está diciendo: 'No puedo procesar tu solicitud con el protocolo que estás usando actualmente, pero puedo hacerlo si cambias a otro protocolo que especifico en mi respuesta'. Este código fue estandarizado en RFC 7231 y su propósito principal es facilitar la transición de protocolos, especialmente en escenarios donde se requiere o se prefiere fuertemente un protocolo más nuevo o más seguro. La respuesta 426 DEBE incluir un encabezado Upgrade que especifica los protocolos a los que el cliente debe actualizar para que el servidor procese la solicitud. Los casos de uso más comunes incluyen: forzar la actualización de HTTP/1.1 a HTTP/2 para mejor rendimiento, requerir la actualización de conexiones HTTP a HTTPS por razones de seguridad, exigir el uso de versiones más nuevas de protocolos de aplicación (como actualizar de WebSocket antiguo a WebSocket moderno), o forzar el cambio a protocolos con mejores características de seguridad o rendimiento. Es importante distinguir 426 de otros códigos relacionados: 101 Switching Protocols se usa cuando el servidor ACEPTA cambiar de protocolo (respuesta exitosa), mientras que 426 se usa cuando el servidor REQUIERE que el cliente actualice antes de que pueda procesar la solicitud (respuesta de error). El código 426 es relativamente raro en la web moderna porque la mayoría de los upgrades de protocolo se manejan de manera más suave (como la negociación automática HTTP/2 via ALPN, o redirecciones 301/302 de HTTP a HTTPS). Sin embargo, sigue siendo útil en APIs o servicios que tienen requisitos estrictos de protocolo y quieren comunicar claramente qué actualización se necesita.",
        "useCases": [
            "Requerir actualización de HTTP/1.1 a HTTP/2 o HTTP/3",
            "Forzar upgrade de HTTP a HTTPS por política de seguridad",
            "Exigir versiones más nuevas de protocolos de aplicación",
            "Requerir actualización a WebSocket para funcionalidad en tiempo real",
            "Forzar uso de protocolos con mejor encriptación o seguridad",
            "APIs que deprecan protocolos antiguos y requieren modernización",
            "Servicios que necesitan características específicas de protocolos nuevos"
        ],
        "examples": [
            {
                "scenario": "Servidor requiere actualización a HTTP/2",
                "request": "GET /api/streaming-data HTTP/1.1\nHost: api.example.com\nUser-Agent: OldClient/1.0",
                "response": "HTTP/1.1 426 Upgrade Required\nUpgrade: h2c\nConnection: Upgrade\nContent-Type: application/json\n\n{\n  \"error\": \"upgrade_required\",\n  \"message\": \"This endpoint requires HTTP/2 protocol\",\n  \"current_protocol\": \"HTTP/1.1\",\n  \"required_protocol\": \"HTTP/2\",\n  \"reason\": \"Streaming endpoints require HTTP/2 multiplexing and server push features\",\n  \"upgrade_header\": \"h2c (HTTP/2 over cleartext)\",\n  \"how_to_upgrade\": {\n    \"step_1\": \"Client must support HTTP/2 protocol\",\n    \"step_2\": \"Send request with 'Upgrade: h2c' header\",\n    \"step_3\": \"Server will respond with 101 Switching Protocols\",\n    \"step_4\": \"Connection will upgrade to HTTP/2\"\n  },\n  \"benefits_of_http2\": [\n    \"Multiplexing: Multiple requests over single connection\",\n    \"Server push: Server can send resources proactively\",\n    \"Header compression: Reduced overhead\",\n    \"Binary protocol: More efficient parsing\"\n  ],\n  \"client_requirements\": \"HTTP/2 capable client (most modern browsers and HTTP libraries support this)\",\n  \"alternative\": \"For non-streaming data, use /api/batch-data endpoint which supports HTTP/1.1\",\n  \"documentation\": \"https://api.example.com/docs/http2-migration\"\n}",
                "explanation": "El cliente intentó acceder a un endpoint de streaming usando HTTP/1.1, pero el servidor requiere HTTP/2 porque necesita características como multiplexing y server push que solo HTTP/2 proporciona. El servidor responde con 426 indicando que debe actualizar a h2c (HTTP/2)."
            },
            {
                "scenario": "Forzar upgrade de HTTP a HTTPS",
                "request": "GET /api/sensitive-data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_token",
                "response": "HTTP/1.1 426 Upgrade Required\nUpgrade: TLS/1.3, TLS/1.2\nConnection: Upgrade\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\nContent-Type: application/json\n\n{\n  \"error\": \"upgrade_required\",\n  \"message\": \"HTTPS is required for this endpoint\",\n  \"current_protocol\": \"HTTP (unencrypted)\",\n  \"required_protocol\": \"HTTPS (TLS 1.2 or higher)\",\n  \"security_reason\": \"This endpoint handles sensitive data that must be encrypted in transit\",\n  \"upgrade_instructions\": {\n    \"immediate_action\": \"Change URL scheme from 'http://' to 'https://'\",\n    \"correct_url\": \"https://api.example.com/api/sensitive-data\",\n    \"supported_tls_versions\": [\"TLS 1.2\", \"TLS 1.3\"],\n    \"deprecated_versions\": [\"TLS 1.0\", \"TLS 1.1\", \"SSL 3.0\"]\n  },\n  \"security_policy\": {\n    \"enforcement_date\": \"2024-01-01\",\n    \"reason\": \"Compliance with data protection regulations (GDPR, HIPAA, PCI-DSS)\",\n    \"all_http_endpoints\": \"Will redirect or return 426\"\n  },\n  \"hsts_enabled\": true,\n  \"hsts_explanation\": \"Strict-Transport-Security header will force HTTPS for future requests\",\n  \"note\": \"For better security, we recommend using TLS 1.3 where supported\",\n  \"compliance\": \"This policy ensures compliance with industry security standards\"\n}",
                "explanation": "El cliente intentó acceder a un endpoint que maneja datos sensibles usando HTTP sin encriptación. Por razones de seguridad y cumplimiento, el servidor requiere HTTPS (TLS) y responde con 426 indicando que debe actualizar el protocolo. También envía HSTS header para forzar HTTPS en futuras solicitudes."
            },
            {
                "scenario": "Requerir actualización a WebSocket para funcionalidad en tiempo real",
                "request": "GET /api/live-notifications HTTP/1.1\nHost: notifications.example.com\nAuthorization: Bearer user_token",
                "response": "HTTP/1.1 426 Upgrade Required\nUpgrade: websocket\nConnection: Upgrade\nContent-Type: application/json\n\n{\n  \"error\": \"upgrade_required\",\n  \"message\": \"This endpoint requires WebSocket protocol for real-time communication\",\n  \"current_protocol\": \"HTTP/1.1\",\n  \"required_protocol\": \"WebSocket\",\n  \"reason\": \"Real-time notifications require bidirectional, full-duplex communication that HTTP request-response doesn't provide\",\n  \"websocket_upgrade_process\": {\n    \"step_1\": \"Send GET request to this endpoint with upgrade headers\",\n    \"required_headers\": {\n      \"Upgrade\": \"websocket\",\n      \"Connection\": \"Upgrade\",\n      \"Sec-WebSocket-Key\": \"<base64-encoded-random-16-bytes>\",\n      \"Sec-WebSocket-Version\": \"13\"\n    },\n    \"step_2\": \"Server will respond with 101 Switching Protocols\",\n    \"step_3\": \"Connection upgrades to WebSocket\",\n    \"step_4\": \"Bidirectional real-time communication begins\"\n  },\n  \"websocket_url\": \"wss://notifications.example.com/api/live-notifications\",\n  \"example_client_code\": {\n    \"javascript\": \"const ws = new WebSocket('wss://notifications.example.com/api/live-notifications');\",\n    \"python\": \"import websockets; ws = await websockets.connect('wss://notifications.example.com/api/live-notifications')\"\n  },\n  \"alternative_for_http_clients\": {\n    \"endpoint\": \"/api/notifications/poll\",\n    \"method\": \"GET\",\n    \"description\": \"HTTP polling endpoint (less efficient, not real-time)\",\n    \"limitation\": \"Requires repeated requests, higher latency, more server load\"\n  },\n  \"documentation\": \"https://notifications.example.com/docs/websocket-api\"\n}",
                "explanation": "El cliente intentó acceder a un endpoint de notificaciones en vivo usando HTTP simple, pero las notificaciones en tiempo real requieren WebSocket para comunicación bidireccional. El servidor responde con 426 explicando cómo actualizar a WebSocket y proporcionando una alternativa HTTP menos eficiente para clientes que no pueden usar WebSocket."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.15",
        "relatedHeaders": [
            "Upgrade",
            "Connection"
        ],
        "relatedCodes": [
            101,
            301,
            302
        ],
        "technicalNotes": "426 requiere que el servidor incluya el encabezado Upgrade especificando los protocolos aceptables. Diferencias con códigos similares: 101 Switching Protocols = respuesta EXITOSA cuando el servidor acepta cambiar de protocolo; 426 Upgrade Required = respuesta de ERROR cuando el servidor REQUIERE que el cliente actualice; 301/302 = redirecciones, no cambios de protocolo. Los casos comunes de upgrade: HTTP/1.1 → HTTP/2 (h2, h2c), HTTP → HTTPS (TLS/1.2, TLS/1.3), HTTP → WebSocket (websocket). El cliente que recibe 426 debe: (1) verificar protocolos en Upgrade header, (2) si soporta uno, reintentar con headers de upgrade apropiados, (3) si no soporta ninguno, informar al usuario. 426 es raro en práctica porque: HTTP/2 se negocia via ALPN en TLS, HTTP→HTTPS usa redirecciones 301/302, WebSocket usa 101 directamente. Útil para APIs con requisitos estrictos de protocolo.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784555/426_oaey6d.png",
                "alt": "Imagen que representa el nombre del código 426 Upgrade Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784186/51-removebg-preview_n4dmbp.png",
                "alt": "Imagen del código 426 Upgrade Required"
            }
        ]
    },
    {
        "code": 428,
        "status": "Precondition Required",
        "category": "Client Error",
        "description": "El código 428 Precondition Required indica que el servidor requiere que la solicitud sea condicional. Este código fue estandarizado en RFC 6585 (2012) y su propósito es exigir que los clientes incluyan encabezados de precondición antes de que el servidor procese ciertas operaciones, especialmente aquellas que modifican recursos. El servidor está diciendo: 'Necesito que me envíes condiciones de validación (como If-Match, If-Unmodified-Since) antes de que pueda procesar esta solicitud de modificación'. El código 428 es fundamental para implementar control de concurrencia y prevenir el problema conocido como 'lost update' (actualización perdida), donde dos clientes leen el mismo recurso, ambos lo modifican basándose en lo que leyeron, y uno sobrescribe los cambios del otro sin darse cuenta. Al requerir precondiciones, el servidor fuerza a los clientes a usar control de concurrencia optimista: el cliente debe primero obtener el estado actual del recurso (incluyendo su ETag o Last-Modified), luego al actualizarlo debe incluir ese valor en un encabezado de precondición (If-Match o If-Unmodified-Since). Si otro cliente modificó el recurso mientras tanto, la precondición fallará y el servidor responderá con 412 Precondition Failed, alertando al cliente del conflicto. El código 428 se usa cuando el cliente NO proporcionó ninguna precondición pero el servidor las requiere. Es diferente de 412 Precondition Failed, que se usa cuando el cliente SÍ proporcionó una precondición pero FALLÓ la evaluación. Los casos de uso típicos incluyen: APIs que requieren ETags para actualizaciones, sistemas que implementan control de concurrencia estricto, operaciones críticas donde sobrescrituras accidentales serían problemáticas, o recursos compartidos donde múltiples usuarios pueden editar simultáneamente.",
        "useCases": [
            "APIs que requieren ETags para operaciones de actualización",
            "Control de concurrencia optimista obligatorio para prevenir lost updates",
            "Recursos críticos donde sobrescrituras accidentales deben prevenirse",
            "Sistemas de edición colaborativa con múltiples usuarios simultáneos",
            "Operaciones DELETE que requieren confirmación del estado actual",
            "APIs que implementan políticas de seguridad estrictas para modificaciones",
            "Recursos compartidos donde el versionado es mandatorio"
        ],
        "examples": [
            {
                "scenario": "Update sin ETag requerido",
                "request": "PUT /api/documents/456 HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"title\": \"Updated Document Title\",\n  \"content\": \"Updated content...\",\n  \"status\": \"published\"\n}",
                "response": "HTTP/1.1 428 Precondition Required\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_required\",\n  \"message\": \"This request requires a precondition to be specified\",\n  \"required_headers\": [\"If-Match\"],\n  \"reason\": \"To prevent lost updates, you must specify the version of the document you're updating\",\n  \"explanation\": \"This API implements optimistic concurrency control. You must first GET the document to obtain its current ETag, then include that ETag in the If-Match header when updating.\",\n  \"how_to_fix\": {\n    \"step_1\": {\n      \"action\": \"First, retrieve the current document\",\n      \"request\": \"GET /api/documents/456\",\n      \"response_includes\": \"ETag header with current version\"\n    },\n    \"step_2\": {\n      \"action\": \"Include the ETag in your update request\",\n      \"header\": \"If-Match: \\\"etag-value-from-step-1\\\"\",\n      \"request\": \"PUT /api/documents/456\\nIf-Match: \\\"abc123xyz\\\"\\n\\n{...}\"\n    }\n  },\n  \"what_this_prevents\": {\n    \"scenario\": \"Lost update problem\",\n    \"description\": \"Without preconditions, if two users read the same document and both update it, the second update would silently overwrite the first user's changes\",\n    \"with_precondition\": \"If the document changed between read and update, you'll receive 412 Precondition Failed, alerting you to the conflict\"\n  },\n  \"current_document_state\": {\n    \"etag\": \"\\\"version-xyz789\\\"\",\n    \"last_modified\": \"2024-01-17T14:30:00Z\",\n    \"get_endpoint\": \"/api/documents/456\"\n  },\n  \"documentation\": \"https://api.example.com/docs/concurrency-control\"\n}",
                "explanation": "El cliente intentó actualizar un documento sin incluir un encabezado If-Match. La API requiere control de concurrencia optimista para prevenir actualizaciones perdidas, por lo que responde con 428. El cliente debe primero hacer GET para obtener el ETag actual, luego incluirlo en If-Match al hacer PUT."
            },
            {
                "scenario": "DELETE sin precondición en recurso crítico",
                "request": "DELETE /api/production/databases/critical-db-01 HTTP/1.1\nHost: admin.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 428 Precondition Required\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_required\",\n  \"message\": \"Deleting this critical resource requires explicit preconditions\",\n  \"resource_type\": \"production_database\",\n  \"resource_id\": \"critical-db-01\",\n  \"criticality_level\": \"high\",\n  \"required_preconditions\": [\n    \"If-Match: <current-etag>\",\n    \"X-Confirm-Delete: true\"\n  ],\n  \"reason\": \"This is a critical production resource. Deletion requires you to confirm you have the current state\",\n  \"safety_mechanism\": {\n    \"purpose\": \"Prevent accidental deletion of wrong resource or outdated state\",\n    \"example_scenario\": \"If this database was recently modified or replaced, the ETag would differ, preventing deletion of the wrong version\"\n  },\n  \"how_to_proceed\": {\n    \"step_1\": \"GET /api/production/databases/critical-db-01 to retrieve current ETag\",\n    \"step_2\": \"Review the database details to confirm this is what you want to delete\",\n    \"step_3\": \"Send DELETE with If-Match header containing the ETag\",\n    \"step_4\": \"Also include X-Confirm-Delete: true header as additional safety measure\",\n    \"example\": \"DELETE /api/production/databases/critical-db-01\\nIf-Match: \\\"db-v42\\\"\\nX-Confirm-Delete: true\"\n  },\n  \"current_state\": {\n    \"database_name\": \"critical-db-01\",\n    \"etag\": \"\\\"db-state-v42\\\"\",\n    \"size\": \"250 GB\",\n    \"active_connections\": 127,\n    \"last_backup\": \"2024-01-17T12:00:00Z\",\n    \"warning\": \"This database has active connections and recent data\"\n  },\n  \"impact_assessment\": {\n    \"dependent_services\": 8,\n    \"estimated_downtime\": \"Immediate for dependent services\",\n    \"data_loss\": \"Permanent if no recent backup\"\n  },\n  \"alternative\": \"Consider archiving instead: POST /api/production/databases/critical-db-01/archive\"\n}",
                "explanation": "El administrador intentó eliminar una base de datos crítica de producción sin precondiciones. Por seguridad, el servidor requiere que el administrador primero obtenga el estado actual (ETag) y lo incluya en la solicitud de eliminación, forzando confirmación de que conocen el estado actual del recurso que están eliminando."
            },
            {
                "scenario": "PATCH sin If-Unmodified-Since para recurso colaborativo",
                "request": "PATCH /api/wiki/articles/123 HTTP/1.1\nHost: wiki.example.com\nContent-Type: application/json\n\n{\n  \"section\": \"introduction\",\n  \"content\": \"Updated introduction text...\"\n}",
                "response": "HTTP/1.1 428 Precondition Required\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_required\",\n  \"message\": \"Collaborative editing requires preconditions to prevent edit conflicts\",\n  \"resource\": \"wiki article\",\n  \"article_id\": 123,\n  \"article_title\": \"HTTP Status Codes Guide\",\n  \"required_headers\": [\n    \"If-Match (preferred)\",\n    \"If-Unmodified-Since (alternative)\"\n  ],\n  \"collaborative_editing_context\": {\n    \"current_editors\": 3,\n    \"recent_edits\": 7,\n    \"last_edit\": \"2 minutes ago by user alice.johnson\",\n    \"edit_frequency\": \"High - multiple edits per minute\"\n  },\n  \"why_precondition_needed\": {\n    \"problem\": \"Edit conflict / lost updates\",\n    \"scenario\": \"User A reads article, User B edits section 1, User A edits section 2, User A's edit might overwrite User B's changes if no precondition is used\",\n    \"solution\": \"Preconditions detect when the article changed since you last read it\"\n  },\n  \"how_to_edit_safely\": {\n    \"step_1\": \"GET /api/wiki/articles/123 to get current version and ETag\",\n    \"step_2\": \"Make your changes locally\",\n    \"step_3\": \"PATCH with If-Match header containing the ETag from step 1\",\n    \"step_4a_success\": \"If no one edited meanwhile, you get 200 OK\",\n    \"step_4b_conflict\": \"If someone edited, you get 412 Precondition Failed\",\n    \"step_5_on_conflict\": \"GET latest version, merge your changes, retry with new ETag\"\n  },\n  \"current_state\": {\n    \"etag\": \"\\\"article-v47\\\"\",\n    \"last_modified\": \"2024-01-17T16:28:00Z\",\n    \"version\": 47,\n    \"last_editor\": \"alice.johnson@example.com\"\n  },\n  \"documentation\": \"https://wiki.example.com/docs/collaborative-editing\"\n}",
                "explanation": "Un wiki con edición colaborativa requiere precondiciones para evitar que los editores sobrescriban los cambios de otros sin darse cuenta. El servidor responde con 428 cuando alguien intenta editar sin especificar qué versión están modificando."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 6585, Section 3",
        "relatedHeaders": [
            "If-Match",
            "If-Unmodified-Since",
            "If-None-Match",
            "ETag",
            "Last-Modified"
        ],
        "relatedCodes": [
            412
        ],
        "technicalNotes": "428 indica que se REQUIERE una precondición pero NO fue proporcionada. 412 indica que una precondición FUE proporcionada pero FALLÓ. Precondiciones comunes: If-Match (requiere que ETag coincida), If-Unmodified-Since (requiere que no haya sido modificado desde fecha), If-None-Match (requiere que ETag NO coincida). El propósito principal es prevenir el 'lost update problem' forzando control de concurrencia optimista. Flujo típico: (1) cliente hace GET, obtiene ETag, (2) cliente hace PUT/PATCH/DELETE con If-Match, (3a) si ETag coincide → 200 OK, (3b) si ETag cambió → 412 Precondition Failed, (3c) si falta precondición → 428 Precondition Required. Mejor práctica: usar 428 para endpoints críticos donde sobrescrituras accidentales serían problemáticas. No todos los endpoints necesitan precondiciones obligatorias.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784551/428_qsvwzu.png",
                "alt": "Imagen que representa el nombre del código 428 Precondition Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784184/52-removebg-preview_m4e2fe.png",
                "alt": "Imagen del código 428 Precondition Required"
            }
        ]
    },
    {
        "code": 429,
        "status": "Too Many Requests",
        "category": "Client Error",
        "description": "El código 429 Too Many Requests indica que el cliente ha enviado demasiadas solicitudes en un período de tiempo determinado, excediendo los límites de rate limiting (limitación de velocidad) impuestos por el servidor. Este código fue estandarizado en RFC 6585 (2012) y es fundamental para la gestión de recursos del servidor, prevención de abuso, y protección contra ataques de denegación de servicio. El servidor está diciendo: 'Has hecho demasiadas solicitudes muy rápido, necesitas reducir la velocidad y esperar antes de hacer más solicitudes'. El rate limiting es una técnica crítica en APIs modernas que permite a los servidores: prevenir abuso y ataques DoS/DDoS, garantizar distribución justa de recursos entre todos los usuarios, proteger la infraestructura backend de sobrecarga, implementar modelos de negocio freemium (planes gratuitos con límites, planes pagos con límites mayores), y cumplir con acuerdos de nivel de servicio (SLA). Los límites pueden aplicarse de varias formas: por usuario/API key (100 requests por minuto por usuario), por dirección IP (1000 requests por hora por IP), por endpoint específico (10 requests por minuto al endpoint de búsqueda), límites globales del servicio, o límites basados en planes de suscripción. La respuesta 429 típicamente incluye encabezados informativos estándar: X-RateLimit-Limit (límite total), X-RateLimit-Remaining (cuántas requests quedan), X-RateLimit-Reset (timestamp cuando se resetea el límite), y Retry-After (cuándo puede reintentar). Los algoritmos comunes de rate limiting incluyen: token bucket, leaky bucket, fixed window, sliding window, y sliding log. Cuando un cliente recibe 429, debe respetar el Retry-After header e implementar backoff exponencial para reintentos subsecuentes.",
        "useCases": [
            "Protección contra abuso y ataques DDoS",
            "Implementación de planes freemium con límites por tier",
            "Prevención de scraping agresivo de datos",
            "Protección de recursos backend costosos (bases de datos, APIs externas)",
            "Garantizar calidad de servicio para todos los usuarios",
            "Cumplimiento de límites de APIs de terceros",
            "Prevención de bots y automatización abusiva",
            "Gestión de cuotas por usuario o organización"
        ],
        "examples": [
            {
                "scenario": "Rate limit por minuto excedido",
                "request": "GET /api/search?q=keyword HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_user_token\n\n[Esta es la solicitud número 61 en el último minuto]",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 60\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1705518000\nRetry-After: 45\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded the rate limit for this endpoint\",\n  \"limit_type\": \"requests_per_minute\",\n  \"limit\": 60,\n  \"current_usage\": 61,\n  \"remaining\": 0,\n  \"reset_time\": \"2024-01-17T20:00:00Z\",\n  \"reset_in_seconds\": 45,\n  \"retry_after\": \"45 seconds\",\n  \"user_plan\": \"free\",\n  \"endpoint\": \"/api/search\",\n  \"rate_limit_info\": {\n    \"window\": \"1 minute\",\n    \"limit_per_window\": 60,\n    \"current_window_start\": \"2024-01-17T19:59:00Z\",\n    \"current_window_end\": \"2024-01-17T20:00:00Z\"\n  },\n  \"suggestions\": [\n    \"Wait 45 seconds before making another request\",\n    \"Implement exponential backoff in your client\",\n    \"Cache responses to reduce API calls\",\n    \"Upgrade to Basic plan for 300 requests/minute\"\n  ],\n  \"upgrade_options\": [\n    {\n      \"plan\": \"basic\",\n      \"limit\": \"300 requests/minute\",\n      \"price\": \"$9.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/basic\"\n    },\n    {\n      \"plan\": \"pro\",\n      \"limit\": \"1,000 requests/minute\",\n      \"price\": \"$29.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/pro\"\n    },\n    {\n      \"plan\": \"enterprise\",\n      \"limit\": \"Custom limits\",\n      \"price\": \"Contact sales\",\n      \"contact\": \"sales@example.com\"\n    }\n  ],\n  \"documentation\": \"https://api.example.com/docs/rate-limits\"\n}",
                "explanation": "El usuario con plan gratuito ha hecho 61 solicitudes en el último minuto, excediendo su límite de 60. El servidor responde con 429 indicando que debe esperar 45 segundos hasta que se resetee la ventana de tiempo. Se incluyen opciones de upgrade para límites mayores."
            },
            {
                "scenario": "Múltiples límites - diario excedido",
                "request": "POST /api/generate-report HTTP/1.1\nHost: analytics.example.com\nAuthorization: Bearer user_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit-Minute: 10\nX-RateLimit-Remaining-Minute: 8\nX-RateLimit-Limit-Hour: 100\nX-RateLimit-Remaining-Hour: 45\nX-RateLimit-Limit-Day: 500\nX-RateLimit-Remaining-Day: 0\nX-RateLimit-Reset-Day: 1705622400\nRetry-After: 28800\nContent-Type: application/json\n\n{\n  \"error\": \"daily_quota_exceeded\",\n  \"message\": \"You have exceeded your daily quota\",\n  \"limits\": {\n    \"per_minute\": {\n      \"limit\": 10,\n      \"used\": 2,\n      \"remaining\": 8,\n      \"status\": \"ok\"\n    },\n    \"per_hour\": {\n      \"limit\": 100,\n      \"used\": 55,\n      \"remaining\": 45,\n      \"status\": \"ok\"\n    },\n    \"per_day\": {\n      \"limit\": 500,\n      \"used\": 500,\n      \"remaining\": 0,\n      \"status\": \"exceeded\",\n      \"reset_at\": \"2024-01-18T00:00:00Z\",\n      \"reset_in_hours\": 8\n    }\n  },\n  \"quota_type\": \"daily\",\n  \"exceeded_limit\": 500,\n  \"current_usage\": 500,\n  \"reset_time\": \"2024-01-18T00:00:00Z (midnight UTC)\",\n  \"retry_after_seconds\": 28800,\n  \"retry_after_hours\": 8,\n  \"explanation\": \"While you haven't exceeded your minute or hour limits, you've used all 500 of your daily report generations\",\n  \"user_plan\": \"standard\",\n  \"options\": [\n    \"Wait 8 hours for daily quota to reset\",\n    \"Upgrade to Premium plan for 2,000 daily reports\",\n    \"Purchase additional quota: $0.10 per report\"\n  ],\n  \"purchase_additional_quota\": \"POST /api/billing/purchase-quota\",\n  \"usage_analytics\": {\n    \"daily_average\": 350,\n    \"today_unusual\": true,\n    \"suggestion\": \"Your usage today is 43% higher than average. Consider optimizing your report generation workflow.\"\n  }\n}",
                "explanation": "Este servicio implementa múltiples niveles de rate limiting (por minuto, hora, y día). Aunque el usuario no ha excedido los límites por minuto u hora, ha agotado su cuota diaria de 500 reportes. Debe esperar hasta medianoche UTC (8 horas) para que se resetee."
            },
            {
                "scenario": "Rate limiting por IP - Prevención de scraping",
                "request": "GET /products/page-147 HTTP/1.1\nHost: shop.example.com\nUser-Agent: Python-Requests/2.28.0\n\n[Solicitud número 1001 desde la misma IP en la última hora]",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1705518000\nRetry-After: 3600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"Too many requests from your IP address\",\n  \"limit_type\": \"ip_based\",\n  \"your_ip\": \"203.0.113.42\",\n  \"limit\": \"1,000 requests per hour\",\n  \"current_usage\": 1001,\n  \"window\": \"1 hour\",\n  \"reset_at\": \"2024-01-17T20:00:00Z\",\n  \"retry_after_seconds\": 3600,\n  \"detection\": {\n    \"pattern\": \"Rapid sequential page requests\",\n    \"user_agent\": \"Python-Requests/2.28.0\",\n    \"behavior\": \"Automated scraping detected\",\n    \"pages_accessed\": 147,\n    \"time_span\": \"12 minutes\"\n  },\n  \"reason\": \"This rate limit protects our service from aggressive scraping and ensures fair access for all users\",\n  \"legitimate_access\": {\n    \"if_you_are_human\": \"Please slow down your browsing. Normal users don't access 147 pages in 12 minutes.\",\n    \"if_you_need_bulk_data\": {\n      \"option_1\": \"Use our official API: https://api.shop.example.com\",\n      \"option_2\": \"Request data export: https://shop.example.com/data-export\",\n      \"option_3\": \"Contact partnerships for bulk access: partners@example.com\"\n    }\n  },\n  \"warning\": \"Continued aggressive scraping may result in permanent IP ban\",\n  \"contact\": \"If you believe this is an error, contact: abuse@example.com\"\n}",
                "explanation": "Un script automatizado (detectado por User-Agent y patrón de comportamiento) está haciendo scraping agresivo del sitio, accediendo a 147 páginas en 12 minutos. El rate limiting por IP lo detiene después de 1,000 solicitudes en una hora. Se ofrecen alternativas legítimas para acceso a datos en bulk."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 6585, Section 4",
        "relatedHeaders": [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset",
            "Retry-After"
        ],
        "relatedCodes": [
            503
        ],
        "technicalNotes": "429 es específico para RATE LIMITING (demasiadas requests en ventana de tiempo). Diferente de 503 Service Unavailable (servidor temporalmente sobrecargado para todos). Headers comunes: X-RateLimit-* (no estándar pero ampliamente adoptado), Retry-After (estándar RFC 7231). Algoritmos de rate limiting: Token Bucket (permite bursts), Leaky Bucket (rate constante), Fixed Window (resetea en intervalos fijos), Sliding Window (más preciso), Sliding Log (más preciso pero costoso). Los límites pueden ser: por usuario/API key, por IP, por endpoint, globales, por plan/tier. Clientes deben: respetar Retry-After, implementar exponential backoff, cachear responses, optimizar número de requests. Servidores deben: documentar límites claramente, proporcionar headers informativos, permitir burst razonable, considerar diferentes límites por endpoint.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784550/429_juikmt.png",
                "alt": "Imagen que representa el nombre del código 429 Too Many Requests"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784184/53-removebg-preview_hueiwh.png",
                "alt": "Imagen del código 429 Too Many Requests"
            }
        ]
    },
    {
        "code": 431,
        "status": "Request Header Fields Too Large",
        "category": "Client Error",
        "description": "El código 431 Request Header Fields Too Large indica que el servidor no está dispuesto a procesar la solicitud porque los campos de encabezado de la solicitud son demasiado grandes. Este código fue estandarizado en RFC 6585 (2012) y puede aplicarse tanto al tamaño total de todos los encabezados combinados como al tamaño de un encabezado individual que excede los límites del servidor. El servidor está diciendo: 'Los encabezados HTTP que estás enviando son demasiado grandes para que yo los procese'. Los encabezados HTTP incluyen toda la metadata de la solicitud: Host, User-Agent, Authorization, Cookie, Accept, Content-Type, y muchos otros. Aunque cada encabezado individualmente puede parecer pequeño, cuando se combinan (especialmente con cookies grandes, tokens JWT largos, o headers personalizados extensos), pueden exceder los límites del servidor. Los límites típicos varían entre servidores: Apache tiene límite por defecto de ~8KB para todos los encabezados, nginx usa ~4-8KB, muchos proxies y balanceadores de carga tienen límites de 4-16KB, y algunos servidores permiten hasta 64KB. Las causas comunes incluyen: cookies excesivamente grandes (especialmente cuando se almacenan datos de sesión o preferencias complejas en cookies), tokens JWT muy largos con muchas claims, demasiados encabezados personalizados (X-Custom-*), User-Agent strings extremadamente largos, encabezados Accept-Language con muchos idiomas, o acumulación de cookies de múltiples subdominios. El código 431 puede aplicarse a la solicitud completa o solo a encabezados específicos. La respuesta debe idealmente indicar qué encabezado(s) causaron el problema para ayudar al cliente a corregirlo. Las soluciones incluyen: reducir el tamaño de cookies (almacenar ID de sesión en lugar de datos completos), usar tokens de acceso más cortos, limpiar cookies antiguas o innecesarias, reducir encabezados personalizados, o incrementar límites del servidor si es apropiado.",
        "useCases": [
            "Cookies excesivamente grandes que exceden límites del servidor",
            "Tokens JWT con demasiadas claims o datos embebidos",
            "Acumulación excesiva de cookies de múltiples subdominios",
            "Demasiados encabezados personalizados agregados por proxies/middleware",
            "User-Agent strings anormalmente largos",
            "Encabezados Accept-* con listas muy extensas",
            "Headers de autorización complejos con múltiples esquemas",
            "Metadata extensa en headers personalizados"
        ],
        "examples": [
            {
                "scenario": "Cookies excesivamente grandes",
                "request": "GET /dashboard HTTP/1.1\nHost: app.example.com\nUser-Agent: Mozilla/5.0...\nCookie: session_id=abc123...; preferences={\"theme\":\"dark\",\"language\":\"en\",\"notifications\":{...very long JSON...}}; analytics_data={...}; user_settings={...}; tracking_tokens=...; [... total cookie header: 12KB]\nAccept: text/html\nAuthorization: Bearer eyJhbGc...[2KB JWT token]",
                "response": "HTTP/1.1 431 Request Header Fields Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"request_headers_too_large\",\n  \"message\": \"Request header fields exceed maximum allowed size\",\n  \"total_headers_size\": 15360,\n  \"total_headers_size_human\": \"15 KB\",\n  \"max_allowed_size\": 8192,\n  \"max_allowed_size_human\": \"8 KB\",\n  \"exceeded_by\": 7168,\n  \"exceeded_by_human\": \"7 KB\",\n  \"problematic_headers\": [\n    {\n      \"header\": \"Cookie\",\n      \"size\": 12288,\n      \"size_human\": \"12 KB\",\n      \"issue\": \"Cookie header alone exceeds the 8KB limit\",\n      \"cookie_count\": 27,\n      \"largest_cookies\": [\n        {\"name\": \"preferences\", \"size\": 4096, \"size_human\": \"4 KB\"},\n        {\"name\": \"analytics_data\", \"size\": 3072, \"size_human\": \"3 KB\"},\n        {\"name\": \"user_settings\", \"size\": 2048, \"size_human\": \"2 KB\"}\n      ]\n    },\n    {\n      \"header\": \"Authorization\",\n      \"size\": 2048,\n      \"size_human\": \"2 KB\",\n      \"note\": \"JWT token is quite large\"\n    }\n  ],\n  \"recommendations\": [\n    {\n      \"action\": \"Reduce cookie sizes\",\n      \"details\": \"Store only session ID in cookies, keep user data server-side\",\n      \"example\": \"Cookie: session_id=abc123 (instead of embedding all preferences)\"\n    },\n    {\n      \"action\": \"Clean up old cookies\",\n      \"details\": \"Delete cookies that are no longer needed\",\n      \"javascript\": \"document.cookie = 'old_cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'\"\n    },\n    {\n      \"action\": \"Use localStorage for preferences\",\n      \"details\": \"Store UI preferences in localStorage instead of cookies\",\n      \"note\": \"Cookies are sent with every request; localStorage is not\"\n    },\n    {\n      \"action\": \"Reduce JWT token size\",\n      \"details\": \"Include only essential claims in the token\",\n      \"alternative\": \"Use shorter access tokens with refresh tokens\"\n    }\n  ],\n  \"immediate_fix\": \"Clear your browser cookies for this domain and log in again\",\n  \"technical_note\": \"Cookies from all subdomains (app.example.com, api.example.com, etc.) are sent together, contributing to total size\"\n}",
                "explanation": "El cliente tiene cookies que suman 12KB más un JWT de 2KB, totalizando 15KB en headers cuando el servidor solo acepta 8KB. Las cookies grandes provienen de almacenar preferencias completas, datos analíticos y configuraciones en lugar de solo IDs de sesión. El servidor rechaza la solicitud y sugiere almacenar datos en el servidor o localStorage."
            },
            {
                "scenario": "Encabezado individual excesivamente grande",
                "request": "POST /api/data HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nX-Custom-Metadata: {\"user_context\":{\"location\":{\"country\":\"US\",\"state\":\"CA\",\"city\":\"San Francisco\",\"coordinates\":{...}},\"device\":{\"type\":\"mobile\",\"os\":\"iOS\",\"version\":\"17.2\",\"model\":\"iPhone 15 Pro\",\"screen\":{...}},\"session\":{\"id\":\"...\",\"start_time\":\"...\",\"page_views\":[...100 items...],\"events\":[...200 items...]},\"preferences\":{...},\"history\":{...}}} [total: 32KB in single header]\nAuthorization: Bearer token",
                "response": "HTTP/1.1 431 Request Header Fields Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"header_too_large\",\n  \"message\": \"A single request header exceeds maximum allowed size\",\n  \"problematic_header\": \"X-Custom-Metadata\",\n  \"header_size\": 32768,\n  \"header_size_human\": \"32 KB\",\n  \"max_header_size\": 8192,\n  \"max_header_size_human\": \"8 KB\",\n  \"issue\": \"Single header exceeds limit by 24 KB\",\n  \"explanation\": \"HTTP headers are designed for metadata, not large payloads. A 32KB header is extremely unusual and problematic.\",\n  \"why_this_is_wrong\": [\n    \"Headers are meant for small metadata, not data payloads\",\n    \"Large headers increase overhead for every request\",\n    \"Proxies and CDNs may reject or truncate large headers\",\n    \"Headers are loaded into memory, causing performance issues\"\n  ],\n  \"correct_approach\": {\n    \"option_1\": {\n      \"method\": \"Include data in request body\",\n      \"description\": \"Move the large metadata to the JSON request body\",\n      \"example\": {\n        \"headers\": {\n          \"Content-Type\": \"application/json\",\n          \"X-Metadata-Included\": \"true\"\n        },\n        \"body\": {\n          \"data\": \"your actual data\",\n          \"metadata\": {\n            \"user_context\": {...},\n            \"session\": {...}\n          }\n        }\n      }\n    },\n    \"option_2\": {\n      \"method\": \"Send context separately\",\n      \"description\": \"Send large context data in a separate initialization request\",\n      \"flow\": [\n        \"POST /api/context with full context data, receive context_id\",\n        \"Use X-Context-ID: {context_id} header in subsequent requests\"\n      ]\n    },\n    \"option_3\": {\n      \"method\": \"Reduce metadata\",\n      \"description\": \"Include only essential metadata in headers\",\n      \"example\": \"X-User-ID: 12345, X-Session-ID: abc123 (small identifiers only)\"\n    }\n  },\n  \"best_practice\": \"Headers should typically be under 4KB total, with individual headers under 1KB\"\n}",
                "explanation": "El cliente intentó enviar 32KB de metadata de contexto en un solo encabezado X-Custom-Metadata. Esto es un mal uso de headers HTTP. Los headers están diseñados para metadata pequeña, no payloads grandes. El servidor rechaza la solicitud y explica que estos datos deben ir en el cuerpo de la solicitud o manejarse mediante un sistema de contexto separado."
            },
            {
                "scenario": "Acumulación de cookies de subdominios",
                "request": "GET /profile HTTP/1.1\nHost: www.example.com\nCookie: session_www=abc123; session_api=def456; session_blog=ghi789; session_shop=jkl012; tracking_www=...; tracking_api=...; tracking_blog=...; tracking_shop=...; analytics_www=...; analytics_api=...; [cookies from www, api, blog, shop, cdn, static, assets subdomains, total: 11KB]\nUser-Agent: Mozilla/5.0...",
                "response": "HTTP/1.1 431 Request Header Fields Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"cookie_header_too_large\",\n  \"message\": \"Cookie header exceeds maximum size due to cookies from multiple subdomains\",\n  \"cookie_header_size\": 11264,\n  \"cookie_header_size_human\": \"11 KB\",\n  \"max_allowed\": 8192,\n  \"max_allowed_human\": \"8 KB\",\n  \"cookie_analysis\": {\n    \"total_cookies\": 42,\n    \"cookies_by_subdomain\": {\n      \"www.example.com\": 8,\n      \"api.example.com\": 7,\n      \"blog.example.com\": 6,\n      \"shop.example.com\": 9,\n      \"cdn.example.com\": 4,\n      \"static.example.com\": 3,\n      \"assets.example.com\": 5\n    },\n    \"issue\": \"Cookies set with domain=.example.com are sent to ALL subdomains\"\n  },\n  \"explanation\": {\n    \"problem\": \"When cookies are set with domain=.example.com, they are sent to every subdomain request\",\n    \"accumulation\": \"Each subdomain added cookies, and now ALL of them are sent with EVERY request to ANY subdomain\",\n    \"impact\": \"A request to www.example.com carries cookies from api, blog, shop, cdn, static, and assets subdomains\"\n  },\n  \"solutions\": [\n    {\n      \"immediate\": \"Clear all cookies for *.example.com domain\",\n      \"action\": \"Use browser developer tools → Application → Cookies → Clear all\"\n    },\n    {\n      \"long_term\": \"Fix cookie scoping\",\n      \"details\": \"Set cookies ONLY for specific subdomains, not for parent domain\",\n      \"correct\": \"Set-Cookie: session=abc123; Domain=www.example.com; Path=/\",\n      \"incorrect\": \"Set-Cookie: session=abc123; Domain=.example.com; Path=/\"\n    },\n    {\n      \"architecture\": \"Use separate domains for different services\",\n      \"example\": \"exampleapi.com, exampleblog.com instead of api.example.com, blog.example.com\",\n      \"benefit\": \"Cookies won't be shared across different root domains\"\n    }\n  ],\n  \"cookie_best_practices\": [\n    \"Set cookies only for the specific subdomain that needs them\",\n    \"Use HttpOnly and Secure flags appropriately\",\n    \"Set appropriate expiration times to auto-clean old cookies\",\n    \"Store only essential data in cookies (IDs, tokens)\",\n    \"Keep session data server-side, not in cookies\"\n  ]\n}",
                "explanation": "Múltiples subdominios (www, api, blog, shop, cdn, static, assets) han establecido cookies con domain=.example.com, causando que TODAS las cookies se envíen a TODOS los subdominios. Esto acumula 11KB de cookies. El servidor rechaza la solicitud y explica que las cookies deben tener alcance específico por subdominio."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 6585, Section 5",
        "relatedHeaders": [
            "Cookie",
            "Authorization",
            "User-Agent",
            "Accept",
            "Accept-Language"
        ],
        "relatedCodes": [
            413,
            414
        ],
        "technicalNotes": "431 es específico para HEADERS demasiado grandes, diferente de 413 Payload Too Large (cuerpo de request) y 414 URI Too Long (URL). Los límites varían por servidor: Apache ~8KB, nginx ~4-8KB, IIS ~16KB, proxies 4-16KB. El error puede ser por: tamaño total de todos los headers combinados, o un solo header individual demasiado grande. Causas comunes: cookies grandes (almacenar datos vs solo IDs), JWT tokens extensos, acumulación de cookies de subdominios, headers X-Custom-* excesivos. Soluciones: reducir cookies (solo IDs, datos en servidor), usar localStorage para preferencias UI, tokens más cortos con refresh tokens, cookie scoping apropiado (específico por subdominio), limpiar cookies antiguas. Headers típicamente deben ser <4KB total, headers individuales <1KB. NO usar headers para payloads grandes - usar request body.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784551/431_rkj8ck.png",
                "alt": "Imagen que representa el nombre del código 431 Request Header Fields Too Large"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784181/54-removebg-preview_zp19ox.png",
                "alt": "Imagen del código 431 Request Header Fields Too Large"
            }
        ]
    },
    {
        "code": 444,
        "status": "No Response / Connection Closed Without Response",
        "category": "Client Error (Non-standard)",
        "description": "El código 444 NO es un código de estado HTTP oficial estándar. Es un código específico de nginx, un popular servidor web y proxy reverso. El código 444 es único porque en realidad NO se envía al cliente como respuesta HTTP - en su lugar, nginx simplemente cierra la conexión sin enviar ninguna respuesta en absoluto. El servidor está diciendo (o más bien, NO diciendo nada): 'Voy a cerrar esta conexión inmediatamente sin enviarte ninguna respuesta HTTP'. Este comportamiento es intencional y se utiliza principalmente como mecanismo de protección contra solicitudes maliciosas, bots, scrapers no deseados, o tráfico abusivo. Cuando nginx está configurado para devolver 444, lo que realmente sucede es: el cliente envía una solicitud, nginx la evalúa según sus reglas de configuración, si coincide con criterios para 444, nginx cierra la conexión TCP inmediatamente sin enviar código de estado HTTP, headers, o cuerpo de respuesta alguno. Desde la perspectiva del cliente, la conexión simplemente se cierra inesperadamente, lo que puede resultar en errores como 'connection reset', 'empty response', o 'connection closed by remote host'. El código 444 es útil por varias razones: ahorra ancho de banda y recursos del servidor al no enviar ninguna respuesta, confunde a bots y scrapers que esperan respuestas HTTP estándar, puede usarse para bloquear silenciosamente tráfico malicioso sin revelar información sobre el servidor, y es más eficiente que enviar respuestas de error completas a solicitudes que de todos modos serán ignoradas. Los casos de uso comunes incluyen: bloquear IPs conocidas como maliciosas, rechazar solicitudes a dominios incorrectos en hosting compartido, bloquear User-Agents de bots no deseados, proteger contra escaneos de vulnerabilidades, o cerrar conexiones de solicitudes obviamente malformadas o sospechosas.",
        "useCases": [
            "nginx: Bloquear IPs maliciosas sin enviar respuesta",
            "Rechazar solicitudes a hosts/dominios incorrectos en servidor compartido",
            "Bloquear bots y scrapers agresivos silenciosamente",
            "Protección contra escaneos de seguridad y vulnerability scanners",
            "Cerrar conexiones de solicitudes obviamente maliciosas",
            "Ahorro de recursos evitando respuestas a tráfico no deseado",
            "NOTA: Específico de nginx, NO es estándar HTTP"
        ],
        "examples": [
            {
                "scenario": "nginx - Bloqueo de IP maliciosa",
                "request": "GET /admin/login HTTP/1.1\nHost: example.com\nUser-Agent: AttackBot/1.0\nX-Forwarded-For: 198.51.100.42",
                "response": "[nginx cierra la conexión inmediatamente sin enviar ninguna respuesta HTTP]\n\nConfiguración nginx que causa esto:\n\nserver {\n    listen 80;\n    server_name example.com;\n    \n    # Bloquear IP maliciosa conocida\n    if ($remote_addr = 198.51.100.42) {\n        return 444;\n    }\n    \n    # ... resto de la configuración\n}\n\nLo que ve el cliente:\n- No hay código de estado HTTP\n- No hay headers\n- No hay cuerpo de respuesta\n- Solo: \"Connection closed by remote host\" o \"Empty reply from server\"",
                "explanation": "nginx detecta que la solicitud proviene de una IP conocida por actividad maliciosa (198.51.100.42). En lugar de enviar un error HTTP tradicional como 403 Forbidden, nginx simplemente cierra la conexión sin respuesta. Esto ahorra recursos y no proporciona información al atacante."
            },
            {
                "scenario": "nginx - Bloqueo de User-Agent de bot",
                "request": "GET / HTTP/1.1\nHost: example.com\nUser-Agent: BadBot/2.0 (Scraper; +http://badbot.com/bot.html)",
                "response": "[Conexión cerrada sin respuesta]\n\nConfiguración nginx:\n\nserver {\n    listen 80;\n    server_name example.com;\n    \n    # Bloquear User-Agents de bots no deseados\n    if ($http_user_agent ~* (BadBot|EvilScraper|MaliciousCrawler)) {\n        return 444;\n    }\n    \n    # Alternativamente con map:\n    map $http_user_agent $bad_bot {\n        default 0;\n        ~*BadBot 1;\n        ~*EvilScraper 1;\n        ~*MaliciousCrawler 1;\n    }\n    \n    if ($bad_bot) {\n        return 444;\n    }\n}\n\nResultado para el bot:\n- curl: \"curl: (52) Empty reply from server\"\n- wget: \"wget: unable to read initial HTTP response: Connection reset by peer\"\n- Python requests: \"requests.exceptions.ConnectionError: Connection closed unexpectedly\"",
                "explanation": "nginx identifica el User-Agent como un bot no deseado (BadBot/2.0) mediante regex matching. En lugar de enviar 403 o 429, cierra la conexión silenciosamente con 444. El bot recibe un error de conexión en lugar de una respuesta HTTP, lo que puede confundir scripts automatizados que esperan códigos de estado estándar."
            },
            {
                "scenario": "nginx - Rechazo de host incorrecto",
                "request": "GET / HTTP/1.1\nHost: wrong-domain-pointing-to-this-server.com\nUser-Agent: Mozilla/5.0...",
                "response": "[Conexión cerrada sin respuesta]\n\nConfiguración nginx:\n\n# Servidor por defecto que captura dominios no configurados\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    server_name _;\n    \n    # Cerrar conexión para cualquier dominio no configurado\n    return 444;\n}\n\n# Servidores reales con dominios específicos\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    # ... configuración normal\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    # ... configuración normal\n}\n\nUso:\nCuando alguien apunta un dominio aleatorio a tu servidor IP pero no está configurado en nginx,\nen lugar de mostrar el sitio por defecto o un error, nginx cierra la conexión.\n\nBeneficios:\n- Previene que dominios maliciosos usen tu servidor\n- Evita hosting involuntario de contenido de terceros\n- No revela información sobre el servidor\n- Ahorra ancho de banda",
                "explanation": "Alguien apuntó un dominio no autorizado (wrong-domain-pointing-to-this-server.com) a la IP del servidor. El servidor nginx tiene un bloque server default_server que captura todas las solicitudes a hosts no configurados y responde con 444, cerrando la conexión sin enviar respuesta. Esto previene el 'domain pointing abuse'."
            },
            {
                "scenario": "Alternativa estándar - Usar códigos HTTP oficiales",
                "request": "GET /admin HTTP/1.1\nHost: example.com\nX-Forwarded-For: 198.51.100.42",
                "response": "MEJOR PRÁCTICA: Usar códigos HTTP estándar en lugar de 444\n\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\nX-Blocked-Reason: IP-Blacklist\n\n{\n  \"error\": \"access_denied\",\n  \"message\": \"Access from your IP address is not permitted\",\n  \"reason\": \"Your IP is on the blocklist due to previous malicious activity\",\n  \"blocked_at\": \"2024-01-17T10:00:00Z\",\n  \"contact\": \"If you believe this is an error, contact: abuse@example.com\",\n  \"note\": \"This is a standard HTTP response, not nginx's 444\"\n}\n\nConfiguración nginx alternativa:\n\nserver {\n    listen 80;\n    server_name example.com;\n    \n    location / {\n        # En lugar de return 444;\n        if ($remote_addr = 198.51.100.42) {\n            return 403 '{\"error\":\"access_denied\",\"message\":\"IP blocked\"}';\n            # O redirigir a página de error\n            # return 403 /blocked.html;\n        }\n    }\n}\n\nVentajas de usar códigos estándar:\n- Clientes reciben respuesta HTTP apropiada\n- Mejor debugging y logging\n- Más compatible con herramientas de monitoreo\n- Más transparente para usuarios legítimos bloqueados por error",
                "explanation": "MEJOR PRÁCTICA: En lugar de usar el código no estándar 444 que cierra la conexión sin respuesta, es mejor usar códigos HTTP estándar como 403 Forbidden. Esto proporciona mejor compatibilidad, facilita debugging, y es más transparente. Sin embargo, 444 sigue siendo útil para tráfico claramente malicioso donde no quieres gastar recursos en respuestas."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [],
        "relatedCodes": [
            403,
            444
        ],
        "technicalNotes": "444 es ESPECÍFICO DE NGINX y NO es un código HTTP estándar oficial. NO se envía al cliente como respuesta HTTP - nginx simplemente cierra la conexión TCP sin enviar nada. Comportamiento: nginx evalúa la solicitud, si coincide con regla 'return 444;', cierra conexión inmediatamente sin response. El cliente ve: 'connection reset', 'empty response', 'connection closed'. Ventajas: ahorra ancho de banda (no envía respuesta), ahorra CPU (no procesa response), confunde bots/scrapers, no revela info del servidor. Desventajas: no estándar, dificulta debugging legítimo, puede confundir usuarios válidos bloqueados por error, herramientas de monitoreo pueden no entenderlo. Alternativas estándar: 403 Forbidden (acceso denegado), 429 Too Many Requests (rate limiting), 503 Service Unavailable (temporalmente no disponible). Usar 444 SOLO para tráfico claramente malicioso donde no quieres gastar recursos. Para usuarios legítimos, usar códigos HTTP estándar con mensajes informativos.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768784555/444_gcq9qv.png",
                "alt": "Imagen que representa el nombre del código 444 No Response"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768784180/55-removebg-preview_bstqfz.png",
                "alt": "Imagen del código 444 No Response"
            }
        ]
    },
    {
        "code": 450,
        "status": "Blocked by Windows Parental Controls",
        "category": "Client Error (Non-standard)",
        "description": "El código 450 Blocked by Windows Parental Controls es un código de estado HTTP NO estándar que fue utilizado específicamente por Microsoft en versiones antiguas de Windows (principalmente Windows Vista y Windows 7) cuando el sistema de control parental bloqueaba el acceso a ciertos sitios web o contenido. Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de Microsoft. El servidor (o más precisamente, el sistema de filtrado local de Windows) está diciendo: 'Este contenido ha sido bloqueado por la configuración de controles parentales de Windows en este equipo'. Es importante entender que este código NO era generado por servidores web remotos, sino por el software de filtrado local de Windows que interceptaba las solicitudes HTTP del navegador. Cuando un usuario (típicamente un menor) intentaba acceder a un sitio web que estaba bloqueado según las reglas de control parental configuradas por los padres, el sistema de filtrado de Windows interceptaba la solicitud y mostraba una página de bloqueo con el código 450. El mensaje típicamente incluía información sobre por qué el sitio fue bloqueado (categoría de contenido, calificación, etc.) y opciones para que un padre/administrador autorizara el acceso. Este código es extremadamente raro en la actualidad por varias razones: (1) las versiones modernas de Windows (8, 10, 11) usan diferentes mecanismos de control parental que no dependen de códigos de estado HTTP personalizados, (2) el filtrado se ha movido hacia soluciones basadas en la nube y cuentas de Microsoft Family, (3) muchas soluciones de control parental modernas operan a nivel de DNS o mediante extensiones de navegador en lugar de interceptar tráfico HTTP. El código 450 es principalmente de interés histórico hoy en día, representando un enfoque temprano de Microsoft para implementar filtrado de contenido web integrado en el sistema operativo.",
        "useCases": [
            "Windows Vista/7: Control parental bloqueando sitios web",
            "Filtrado de contenido basado en categorías (adulto, violencia, etc.)",
            "Restricciones horarias de navegación web para menores",
            "Bloqueo de sitios según calificaciones de contenido",
            "NOTA: Obsoleto, específico de versiones antiguas de Windows, NO estándar"
        ],
        "examples": [
            {
                "scenario": "Windows 7 - Control parental bloqueando sitio (histórico)",
                "request": "GET / HTTP/1.1\nHost: blocked-site.example.com\nUser-Agent: Mozilla/5.0 (Windows NT 6.1...) Internet Explorer/9.0\n\n[Solicitud interceptada por Windows Parental Controls]",
                "response": "HTTP/1.1 450 Blocked by Windows Parental Controls\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Windows Parental Controls - Site Blocked</title>\n    <style>\n        body { font-family: Segoe UI, Arial; margin: 40px; background: #f0f0f0; }\n        .container { background: white; padding: 30px; border-radius: 5px; }\n        .warning { color: #d83b01; font-size: 24px; font-weight: bold; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"warning\">⚠ Site Blocked</div>\n        <h2>Windows Parental Controls</h2>\n        <p>This website has been blocked by Windows Parental Controls.</p>\n        \n        <h3>Block Information:</h3>\n        <ul>\n            <li><strong>Site:</strong> blocked-site.example.com</li>\n            <li><strong>Category:</strong> Adult Content</li>\n            <li><strong>Rating:</strong> Mature (18+)</li>\n            <li><strong>User Account:</strong> Tommy (Child Account)</li>\n            <li><strong>Blocked at:</strong> 2024-01-17 20:30:00</li>\n        </ul>\n        \n        <h3>Why was this blocked?</h3>\n        <p>The site you're trying to access has been categorized as adult content and is not appropriate for your account type. The parental controls on this computer are set to block this type of content.</p>\n        \n        <h3>What can you do?</h3>\n        <ul>\n            <li>Ask a parent or guardian to review this site</li>\n            <li>A parent can log in and allow access to this site</li>\n            <li>Visit age-appropriate websites instead</li>\n        </ul>\n        \n        <h3>For Parents/Guardians:</h3>\n        <p>To review or change these settings:</p>\n        <ol>\n            <li>Open Control Panel</li>\n            <li>Go to User Accounts and Family Safety</li>\n            <li>Click on Parental Controls</li>\n            <li>Review the settings for this user account</li>\n        </ol>\n        \n        <p><small>If you believe this site was blocked in error, please contact your system administrator.</small></p>\n    </div>\n</body>\n</html>",
                "explanation": "EJEMPLO HISTÓRICO: En Windows 7, cuando un niño con cuenta restringida intentaba acceder a un sitio categorizado como contenido para adultos, el sistema de Windows Parental Controls interceptaba la solicitud HTTP y mostraba esta página de bloqueo con código 450. Este código era generado localmente por Windows, no por el servidor remoto."
            },
            {
                "scenario": "Bloqueo por categoría de contenido",
                "request": "GET /games HTTP/1.1\nHost: gaming-site.example.com\n\n[Usuario menor intentando acceder durante horario restringido]",
                "response": "HTTP/1.1 450 Blocked by Windows Parental Controls\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>Blocked - Time Restrictions</title></head>\n<body>\n    <h1>Access Restricted</h1>\n    <h2>Time Limit Restriction</h2>\n    \n    <p>This website is blocked during the current time period.</p>\n    \n    <div>\n        <strong>Current Time:</strong> 10:30 PM (22:30)<br>\n        <strong>Allowed Hours:</strong> Monday-Friday: 4:00 PM - 8:00 PM<br>\n        <strong>Your Account:</strong> Sarah (Limited Account)<br>\n        <strong>Site Category:</strong> Games & Entertainment\n    </div>\n    \n    <h3>Time Restrictions Active:</h3>\n    <p>Gaming and entertainment sites are only accessible during designated hours. You can access this site during:</p>\n    <ul>\n        <li>Weekdays: 4:00 PM - 8:00 PM</li>\n        <li>Weekends: 9:00 AM - 9:00 PM</li>\n    </ul>\n    \n    <p>Time until next allowed period: 17 hours 30 minutes</p>\n    \n    <p><em>These restrictions were set by your parent or guardian to help manage screen time.</em></p>\n</body>\n</html>",
                "explanation": "Windows Parental Controls podía bloquear sitios no solo por contenido sino también por horarios. Un menor intentando acceder a sitios de juegos fuera del horario permitido recibiría código 450 con información sobre cuándo podría acceder."
            },
            {
                "scenario": "Estado moderno - Mecanismos actuales (NO usan 450)",
                "request": "GET / HTTP/1.1\nHost: inappropriate-site.example.com\n\n[Usuario con Microsoft Family Safety en Windows 11]",
                "response": "SISTEMAS MODERNOS: No usan código 450\n\nWindows 10/11 con Microsoft Family Safety:\n- El bloqueo ocurre a nivel de DNS o mediante redirección\n- NO genera código HTTP 450\n- Redirige a página de Microsoft Family Safety\n- Usa servicios en la nube para filtrado\n\nEjemplo de bloqueo moderno:\n\nHTTP/1.1 302 Found\nLocation: https://account.microsoft.com/family/blocked?url=inappropriate-site.example.com\n\nO simplemente:\n- DNS no resuelve (si usa filtrado DNS)\n- Conexión bloqueada a nivel de firewall\n- Sin respuesta HTTP (conexión rechazada)\n\nPágina de bloqueo moderna (Microsoft Family):\n<!DOCTYPE html>\n<html>\n<head><title>Microsoft Family Safety</title></head>\n<body>\n    <h1>This site is blocked</h1>\n    <p>Ask a parent to review this site in their Microsoft Family Safety dashboard.</p>\n    <a href=\"https://account.microsoft.com/family\">Microsoft Family Safety Dashboard</a>\n</body>\n</html>\n\nCaracterísticas de sistemas modernos:\n- Basados en la nube (Microsoft Family, Google Family Link)\n- Sincronización entre dispositivos\n- Gestión remota desde app móvil de padres\n- Informes de actividad detallados\n- NO usan códigos HTTP personalizados como 450",
                "explanation": "CONTEXTO ACTUAL: Windows 10 y 11 NO usan el código 450. Microsoft Family Safety moderno opera mediante servicios en la nube, filtrado DNS, y redirecciones a páginas de Microsoft. El código 450 es obsoleto y solo es relevante históricamente para sistemas Windows Vista/7."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "Microsoft específico (Windows Vista/7) - No hay RFC oficial - OBSOLETO",
        "relatedHeaders": [],
        "relatedCodes": [
            451
        ],
        "technicalNotes": "450 es ESPECÍFICO DE MICROSOFT y completamente OBSOLETO. NO es un código HTTP estándar oficial. Fue usado SOLO en Windows Vista/7 con Parental Controls habilitado. NO se genera en servidores remotos - era generado localmente por el software de filtrado de Windows. Mecanismo: interceptaba solicitudes HTTP del navegador, evaluaba contra reglas parentales, si bloqueado mostraba página local con código 450. Windows 8+ usa Microsoft Family Safety con mecanismos diferentes (cloud-based, DNS filtering, account-level controls) que NO usan código 450. Sistemas modernos de control parental: Microsoft Family Safety (cloud), Google Family Link, Apple Screen Time, routers con filtrado DNS, no usan códigos HTTP personalizados. Código 451 Unavailable For Legal Reasons es el estándar oficial más cercano para bloqueo de contenido (pero para razones legales, no parentales). 450 es principalmente de interés histórico como ejemplo de código HTTP propietario obsoleto.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768785295/450_llngzw.png",
                "alt": "Imagen que representa el nombre del código 450 Blocked by Windows Parental Controls"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768785126/56-removebg-preview_tfbozh.png",
                "alt": "Imagen del código 450 Blocked by Windows Parental Controls"
            }
        ]
    },
    {
        "code": 451,
        "status": "Unavailable For Legal Reasons",
        "category": "Client Error",
        "description": "El código 451 Unavailable For Legal Reasons indica que el recurso solicitado no está disponible debido a razones legales, como órdenes judiciales, solicitudes gubernamentales, censura, cumplimiento de regulaciones, o restricciones por derechos de autor. Este código fue oficialmente estandarizado en RFC 7725 (diciembre 2015) y su número fue elegido como referencia a la novela distópica 'Fahrenheit 451' de Ray Bradbury, donde 451 grados Fahrenheit es la temperatura a la que el papel de los libros se quema, simbolizando la censura. El servidor está diciendo: 'Este contenido existe pero no puedo proporcionártelo debido a razones legales o regulatorias'. El código 451 es importante por varias razones: proporciona transparencia sobre por qué el contenido no está disponible (legal vs técnico), permite a los operadores cumplir con obligaciones legales de manera estándar, facilita el monitoreo de censura en internet por parte de organizaciones de derechos digitales, y distingue claramente entre contenido que no existe (404) y contenido que existe pero está legalmente bloqueado. La respuesta 451 debe incluir una explicación de qué autoridad legal requiere el bloqueo y, cuando sea posible, un enlace a la ley, orden judicial, o regulación específica. Los casos de uso incluyen: cumplimiento de órdenes de retiro de contenido (DMCA takedowns), bloqueo geográfico por restricciones de licencia, censura gubernamental, cumplimiento con leyes de protección de datos (GDPR, derecho al olvido), restricciones por difamación o contenido ilegal según jurisdicción específica, o bloqueo de contenido que viola leyes locales de un país. Es importante notar que 451 se usa cuando el bloqueo es por razones LEGALES específicas, no por decisiones editoriales o de moderación de contenido del sitio.",
        "useCases": [
            "Cumplimiento de órdenes judiciales de retiro de contenido",
            "DMCA takedowns por violación de derechos de autor",
            "Bloqueo geográfico por restricciones de licencia legal",
            "Censura gubernamental o regulaciones nacionales",
            "Derecho al olvido bajo GDPR u otras regulaciones de privacidad",
            "Contenido bloqueado por órdenes de difamación",
            "Cumplimiento con leyes locales que prohíben cierto contenido",
            "Restricciones por sanciones internacionales o embargos"
        ],
        "examples": [
            {
                "scenario": "DMCA Takedown - Violación de derechos de autor",
                "request": "GET /videos/movie-2024.mp4 HTTP/1.1\nHost: streaming.example.com\nUser-Agent: Mozilla/5.0...",
                "response": "HTTP/1.1 451 Unavailable For Legal Reasons\nLink: <https://www.dmca.com>; rel=\"blocked-by\"\nContent-Type: application/json\n\n{\n  \"error\": \"unavailable_for_legal_reasons\",\n  \"message\": \"This content has been removed in response to a legal complaint\",\n  \"legal_reason\": \"copyright_infringement\",\n  \"law\": \"Digital Millennium Copyright Act (DMCA)\",\n  \"complainant\": \"Major Film Studio Inc.\",\n  \"complaint_date\": \"2024-01-15\",\n  \"content_removed\": \"Full-length movie uploaded without authorization\",\n  \"legal_notice\": {\n    \"type\": \"DMCA Takedown Notice\",\n    \"reference_number\": \"DMCA-2024-001234\",\n    \"details\": \"The copyright holder has submitted a valid DMCA takedown notice claiming this video infringes their exclusive rights\"\n  },\n  \"counter_notice_info\": {\n    \"description\": \"If you believe this content was removed in error, you may file a counter-notice\",\n    \"requirements\": [\n      \"Provide contact information\",\n      \"Identify the removed material\",\n      \"Statement of good faith belief that removal was mistake\",\n      \"Consent to jurisdiction\",\n      \"Physical or electronic signature\"\n    ],\n    \"submit_to\": \"dmca-counter@example.com\",\n    \"documentation\": \"https://streaming.example.com/dmca/counter-notice\"\n  },\n  \"transparency_report\": \"https://streaming.example.com/transparency\",\n  \"related_law\": \"https://www.copyright.gov/legislation/dmca.pdf\"\n}",
                "explanation": "Un video que violaba derechos de autor fue removido tras una queja DMCA válida del titular de derechos. El servidor responde con 451 indicando que es un bloqueo legal, no técnico. Se proporciona información sobre la queja y el proceso para presentar una contra-notificación si el uploader cree que fue un error."
            },
            {
                "scenario": "Bloqueo geográfico por restricciones de licencia",
                "request": "GET /stream/premium-show-s01e01 HTTP/1.1\nHost: tv.example.com\nX-Forwarded-For: 45.33.32.156\nCF-IPCountry: CN\nUser-Agent: Mozilla/5.0...",
                "response": "HTTP/1.1 451 Unavailable For Legal Reasons\nContent-Type: application/json\n\n{\n  \"error\": \"geo_restricted\",\n  \"message\": \"This content is not available in your region due to licensing restrictions\",\n  \"legal_reason\": \"geographic_licensing_restrictions\",\n  \"your_location\": {\n    \"country\": \"China\",\n    \"country_code\": \"CN\",\n    \"ip_address\": \"45.33.32.156 (anonymized)\"\n  },\n  \"restriction_details\": {\n    \"type\": \"Content licensing agreement\",\n    \"explanation\": \"The content owner has only licensed this show for distribution in certain territories\",\n    \"allowed_regions\": [\"United States\", \"Canada\", \"United Kingdom\", \"Australia\"],\n    \"your_region_allowed\": false\n  },\n  \"legal_framework\": {\n    \"basis\": \"Territorial licensing agreements and intellectual property law\",\n    \"rights_holder\": \"International Broadcasting Company\",\n    \"license_scope\": \"North America, UK, and Australia only\"\n  },\n  \"alternatives\": [\n    {\n      \"option\": \"Check regional catalog\",\n      \"description\": \"We have other great content available in your region\",\n      \"link\": \"https://tv.example.com/browse/CN\"\n    },\n    {\n      \"option\": \"Contact local distributor\",\n      \"description\": \"This show may be available through local streaming services in China\",\n      \"note\": \"Different distributors hold rights in different territories\"\n    }\n  ],\n  \"vpn_note\": \"Using VPN or proxy services to circumvent geographic restrictions may violate our Terms of Service\",\n  \"more_info\": \"https://tv.example.com/help/geographic-restrictions\"\n}",
                "explanation": "Un usuario en China intenta acceder a un show que solo está licenciado para ciertos territorios. El bloqueo no es censura, sino cumplimiento con acuerdos de licencia territorial que son requisitos legales contractuales. El código 451 indica que es una restricción legal (contractual), no una limitación técnica."
            },
            {
                "scenario": "Derecho al olvido - GDPR",
                "request": "GET /news/2015/john-doe-arrest-article HTTP/1.1\nHost: news.example.com",
                "response": "HTTP/1.1 451 Unavailable For Legal Reasons\nLink: <https://gdpr-info.eu/art-17-gdpr/>; rel=\"blocked-by\"\nContent-Type: application/json\n\n{\n  \"error\": \"content_removed_legal_order\",\n  \"message\": \"This article has been removed following a legal order\",\n  \"legal_reason\": \"right_to_be_forgotten\",\n  \"regulation\": \"General Data Protection Regulation (GDPR) Article 17\",\n  \"jurisdiction\": \"European Union\",\n  \"removal_details\": {\n    \"type\": \"Court-ordered removal\",\n    \"date_removed\": \"2024-01-10\",\n    \"authority\": \"Data Protection Authority\",\n    \"case_reference\": \"DPA-2024-RTF-00456\"\n  },\n  \"explanation\": {\n    \"article_17_gdpr\": \"Right to erasure ('right to be forgotten')\",\n    \"reason\": \"A data subject successfully exercised their right to have personal data concerning them erased\",\n    \"criteria_met\": [\n      \"Data no longer necessary for original purpose\",\n      \"Individual withdrew consent\",\n      \"Data was unlawfully processed\",\n      \"Must be erased for compliance with legal obligation\"\n    ]\n  },\n  \"geographic_scope\": {\n    \"eu_users\": \"This content is unavailable to users in the European Union\",\n    \"non_eu_users\": \"The article may still be accessible outside the EU\",\n    \"note\": \"GDPR right to erasure applies to EU data subjects\"\n  },\n  \"transparency\": {\n    \"original_publication_date\": \"2015-03-20\",\n    \"article_topic\": \"Criminal arrest (charges later dropped)\",\n    \"removal_reason_category\": \"Rehabilitation and privacy rights\",\n    \"public_interest_balance\": \"Court determined privacy rights outweigh public interest in this specific case\"\n  },\n  \"related_information\": [\n    \"https://gdpr-info.eu/art-17-gdpr/\",\n    \"https://news.example.com/gdpr-policy\"\n  ]\n}",
                "explanation": "Un artículo de 2015 sobre un arresto (donde los cargos fueron posteriormente retirados) fue removido tras una orden judicial bajo el 'derecho al olvido' del GDPR. El individuo ejerció su derecho a que se borren datos personales que ya no son necesarios. El código 451 indica claramente que es una remoción legal, no editorial."
            },
            {
                "scenario": "Censura gubernamental",
                "request": "GET /article/political-criticism HTTP/1.1\nHost: news-international.example.com\nX-Forwarded-For: 192.0.2.45\nCF-IPCountry: XX",
                "response": "HTTP/1.1 451 Unavailable For Legal Reasons\nContent-Type: application/json\n\n{\n  \"error\": \"blocked_by_government_order\",\n  \"message\": \"This content is unavailable in your country due to government restrictions\",\n  \"legal_reason\": \"government_censorship_order\",\n  \"jurisdiction\": \"[Country Name Redacted]\",\n  \"blocking_details\": {\n    \"type\": \"Government content blocking order\",\n    \"authority\": \"National Telecommunications Regulatory Authority\",\n    \"order_date\": \"2024-01-12\",\n    \"legal_basis\": \"National Security Law Article 42\",\n    \"reference_number\": \"CENSORED\"\n  },\n  \"geographic_scope\": {\n    \"affected_region\": \"Users within [Country]\",\n    \"reason\": \"Local law requires blocking of this content within national borders\",\n    \"enforcement\": \"ISP-level blocking mandated by government\"\n  },\n  \"transparency_statement\": {\n    \"publisher_position\": \"We believe in freedom of expression and provide this content in jurisdictions where it is legal to do so\",\n    \"compliance_note\": \"We comply with local laws where we operate, even when we disagree with them\",\n    \"advocacy\": \"We advocate for press freedom and transparency globally\"\n  },\n  \"alternatives\": [\n    \"This content may be accessible in other countries\",\n    \"Consider using services that respect freedom of information\"\n  ],\n  \"transparency_report\": \"https://news-international.example.com/transparency-report\",\n  \"press_freedom_resources\": [\n    \"https://www.eff.org\",\n    \"https://rsf.org\"\n  ]\n}",
                "explanation": "Contenido bloqueado por orden gubernamental en un país específico. El uso de 451 hace visible la censura de manera transparente y permite documentar estos casos. Organizaciones de derechos digitales pueden monitorear respuestas 451 para rastrear censura global. El sitio cumple con la ley local pero mantiene transparencia sobre el bloqueo."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7725 (December 2015)",
        "relatedHeaders": [
            "Link (with rel=\"blocked-by\")"
        ],
        "relatedCodes": [
            403,
            404
        ],
        "technicalNotes": "451 es el código oficial para bloqueos por RAZONES LEGALES. Diferencias: 404 Not Found = recurso no existe; 403 Forbidden = prohibido por política del servidor; 451 = bloqueado por requisito legal/regulatorio. El nombre es referencia a 'Fahrenheit 451' de Ray Bradbury (novela sobre censura). Debe incluir información sobre la base legal del bloqueo cuando sea posible. Header Link con rel='blocked-by' puede apuntar a la ley/regulación relevante. Casos de uso principales: DMCA/copyright takedowns, geo-blocking por licencias, GDPR/derecho al olvido, censura gubernamental, cumplimiento de órdenes judicales. Importancia: proporciona transparencia sobre censura y bloqueos legales, permite monitoreo de libertad de expresión online, distingue bloqueos legales de otros tipos de errores. Organizaciones como EFF, Wikimedia, y grupos de derechos digitales monitorean uso de 451 para rastrear censura global.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768785296/451_lzbxfb.png",
                "alt": "Imagen que representa el nombre del código 451 Unavailable For Legal Reasons"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768785125/57-removebg-preview_ziw6pl.png",
                "alt": "Imagen del código 451 Unavailable For Legal Reasons"
            }
        ]
    },
    {
        "code": 495,
        "status": "SSL Certificate Error",
        "category": "Client Error (Non-standard)",
        "description": "El código 495 SSL Certificate Error es un código de estado HTTP NO estándar específico de nginx que indica que el cliente intentó establecer una conexión HTTPS pero proporcionó un certificado SSL/TLS de cliente inválido, o el certificado del cliente fue rechazado durante el proceso de validación. Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de nginx. Es importante entender que 495 se refiere específicamente a problemas con el CERTIFICADO DEL CLIENTE en escenarios de autenticación mutua TLS (mTLS), no a problemas con el certificado del servidor. El servidor está diciendo: 'Intentaste conectarte con un certificado de cliente, pero ese certificado es inválido, está expirado, no está firmado por una autoridad de certificación confiable, o fue rechazado por alguna otra razón'. La autenticación mutua TLS (mTLS) es un escenario donde no solo el servidor presenta un certificado al cliente (como en HTTPS normal), sino que el cliente también debe presentar su propio certificado al servidor para autenticarse. Esto es común en: APIs empresariales de alta seguridad, comunicación entre microservicios, sistemas bancarios y financieros, dispositivos IoT que se autentican con servidores, y cualquier escenario donde se necesita autenticación fuerte basada en certificados en lugar de contraseñas. Los problemas que causan 495 incluyen: certificado de cliente expirado, certificado no firmado por CA de confianza del servidor, certificado revocado (en lista CRL o vía OCSP), certificado para dominio/propósito incorrecto, cadena de certificados incompleta, o cliente no proporciona certificado cuando es requerido. El código 495 es útil para distinguir problemas de certificado de cliente de otros errores TLS/SSL.",
        "useCases": [
            "nginx: Certificado de cliente inválido en mTLS (autenticación mutua)",
            "Certificado de cliente expirado",
            "Certificado de cliente no firmado por CA confiable",
            "Certificado de cliente revocado",
            "Cliente no proporciona certificado cuando es requerido",
            "Cadena de certificados de cliente incompleta",
            "NOTA: Específico de nginx, NO es estándar HTTP"
        ],
        "examples": [
            {
                "scenario": "nginx - Certificado de cliente expirado",
                "request": "GET /api/secure-endpoint HTTP/1.1\nHost: api.example.com\n\n[Cliente intenta conexión HTTPS con certificado expirado]\n[TLS handshake incluye certificado de cliente que expiró hace 30 días]",
                "response": "[nginx cierra conexión con 495]\n\nConfiguración nginx que causa esto:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    # Certificado del servidor\n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    \n    # Configuración de autenticación de cliente (mTLS)\n    ssl_client_certificate /etc/nginx/ssl/ca.crt;  # CA que firmó certificados de cliente\n    ssl_verify_client on;  # Requiere certificado válido de cliente\n    ssl_verify_depth 2;    # Profundidad de cadena de certificados\n    \n    location /api/ {\n        # Si el certificado del cliente es inválido, nginx responde 495\n        if ($ssl_client_verify != SUCCESS) {\n            return 495;\n        }\n        \n        proxy_pass http://backend;\n    }\n}\n\nRespuesta efectiva:\nHTTP/1.1 495 SSL Certificate Error\nContent-Type: text/html\n\n<html>\n<head><title>495 SSL Certificate Error</title></head>\n<body>\n<h1>SSL Certificate Error</h1>\n<p>Your client certificate is invalid or has expired.</p>\n<p>Error details: Certificate expired on 2023-12-17</p>\n<p>Please obtain a new valid client certificate and try again.</p>\n</body>\n</html>\n\nLo que ve el cliente:\n- curl: \"SSL certificate problem: certificate has expired\"\n- Browsers: \"Your certificate is invalid\" o similar\n- Logs nginx: \"client SSL certificate verify error: (10:certificate has expired)\"",
                "explanation": "Un cliente intenta conectarse a una API que requiere mTLS (autenticación mutua). El cliente proporciona un certificado que expiró hace 30 días. nginx valida el certificado durante el TLS handshake, detecta que está expirado, y responde con código 495 indicando que el certificado del cliente es inválido."
            },
            {
                "scenario": "nginx - Cliente no proporciona certificado cuando es requerido",
                "request": "GET /api/critical-data HTTP/1.1\nHost: secure-api.example.com\n\n[Cliente intenta conexión HTTPS sin proporcionar certificado de cliente]\n[TLS handshake sin certificado de cliente cuando se requiere]",
                "response": "HTTP/1.1 495 SSL Certificate Error\nContent-Type: application/json\n\n{\n  \"error\": \"client_certificate_required\",\n  \"message\": \"A valid client certificate is required to access this endpoint\",\n  \"error_code\": 495,\n  \"ssl_verification\": \"FAILED\",\n  \"reason\": \"No client certificate provided\",\n  \"requirements\": {\n    \"certificate_type\": \"X.509 client certificate\",\n    \"issuer\": \"Must be issued by Company Internal CA\",\n    \"key_usage\": \"Digital Signature, Key Encipherment\",\n    \"extended_key_usage\": \"TLS Web Client Authentication\"\n  },\n  \"how_to_obtain_certificate\": {\n    \"step_1\": \"Request certificate from IT Security department\",\n    \"step_2\": \"Generate Certificate Signing Request (CSR)\",\n    \"step_3\": \"Submit CSR to internal CA portal: https://ca.example.com\",\n    \"step_4\": \"Install issued certificate in your client/browser\",\n    \"step_5\": \"Configure client to present certificate during TLS handshake\"\n  },\n  \"examples\": {\n    \"curl\": \"curl --cert client.crt --key client.key https://secure-api.example.com/api/critical-data\",\n    \"openssl\": \"openssl s_client -connect secure-api.example.com:443 -cert client.crt -key client.key\"\n  },\n  \"contact\": \"For certificate issues, contact: security@example.com\",\n  \"documentation\": \"https://secure-api.example.com/docs/client-certificates\"\n}\n\nConfiguración nginx:\n\nserver {\n    listen 443 ssl;\n    server_name secure-api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    \n    # Requiere certificado de cliente obligatoriamente\n    ssl_client_certificate /etc/nginx/ssl/client-ca.crt;\n    ssl_verify_client on;  # 'on' = obligatorio, 'optional' = opcional\n    \n    location /api/critical-data {\n        # Verificar que el certificado del cliente es válido\n        if ($ssl_client_verify != SUCCESS) {\n            return 495;\n        }\n        \n        # Pasar información del certificado al backend\n        proxy_set_header X-SSL-Client-Cert $ssl_client_cert;\n        proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn;\n        proxy_pass http://backend;\n    }\n}",
                "explanation": "Una API crítica requiere autenticación mediante certificado de cliente (mTLS). Un cliente intenta conectarse sin proporcionar ningún certificado. nginx detecta esta ausencia durante el TLS handshake y responde con 495, explicando que se requiere un certificado válido y cómo obtenerlo."
            },
            {
                "scenario": "nginx - Certificado no firmado por CA de confianza",
                "request": "GET /api/partner-integration HTTP/1.1\nHost: api.example.com\n\n[Cliente proporciona certificado auto-firmado o firmado por CA no confiable]",
                "response": "HTTP/1.1 495 SSL Certificate Error\nContent-Type: application/json\n\n{\n  \"error\": \"untrusted_certificate\",\n  \"message\": \"Client certificate is not trusted\",\n  \"ssl_verify_result\": \"FAILED\",\n  \"reason\": \"Certificate issuer is not in the trusted CA list\",\n  \"certificate_details\": {\n    \"subject\": \"CN=client.partner.com, O=Partner Corp\",\n    \"issuer\": \"CN=Unknown CA, O=Self-Signed\",\n    \"not_before\": \"2024-01-01T00:00:00Z\",\n    \"not_after\": \"2025-01-01T00:00:00Z\",\n    \"serial_number\": \"01:23:45:67:89:AB:CD:EF\"\n  },\n  \"issue\": \"The certificate was not issued by a Certificate Authority in our trust store\",\n  \"trusted_cas\": [\n    \"Company Internal CA\",\n    \"Partner CA Root\",\n    \"Trusted Third-Party CA\"\n  ],\n  \"your_certificate_issuer\": \"Unknown CA / Self-Signed\",\n  \"resolution\": {\n    \"option_1\": {\n      \"action\": \"Obtain certificate from trusted CA\",\n      \"description\": \"Request a client certificate issued by one of our trusted CAs\",\n      \"contact\": \"partner-onboarding@example.com\"\n    },\n    \"option_2\": {\n      \"action\": \"Register your CA with us\",\n      \"description\": \"If you have your own CA, we can add it to our trust store\",\n      \"requirements\": \"Requires security review and formal partnership agreement\",\n      \"contact\": \"security@example.com\"\n    }\n  },\n  \"common_causes\": [\n    \"Using self-signed certificate\",\n    \"Certificate issued by internal CA not registered with us\",\n    \"Using certificate intended for different purpose\",\n    \"CA certificate not included in chain\"\n  ]\n}\n\nNginx config:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    \n    # Lista de CAs confiables para certificados de cliente\n    ssl_client_certificate /etc/nginx/ssl/trusted-client-cas.crt;  # Bundle de múltiples CAs\n    ssl_verify_client on;\n    ssl_verify_depth 3;\n    \n    # Solo CAs en trusted-client-cas.crt son aceptadas\n    # Certificados auto-firmados o de otras CAs → 495\n}",
                "explanation": "Un cliente intenta autenticarse con un certificado auto-firmado o firmado por una CA que no está en la lista de CAs confiables del servidor. nginx valida la cadena de certificados, no encuentra la CA emisora en su trust store, y responde con 495. Se explica qué CAs son confiables y cómo obtener un certificado válido."
            },
            {
                "scenario": "Alternativa usando códigos HTTP estándar",
                "request": "GET /api/secure HTTP/1.1\nHost: api.example.com\n\n[Cliente sin certificado válido]",
                "response": "MEJOR PRÁCTICA: Usar códigos HTTP estándar\n\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: ClientCertificate realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"client_certificate_required\",\n  \"message\": \"Valid client certificate required for authentication\",\n  \"authentication_method\": \"Mutual TLS (mTLS)\",\n  \"certificate_requirements\": {\n    \"issuer\": \"Company Internal CA\",\n    \"validity\": \"Must not be expired or revoked\",\n    \"purpose\": \"Client Authentication\"\n  },\n  \"note\": \"Using standard 401 Unauthorized instead of nginx-specific 495 for better compatibility\",\n  \"documentation\": \"https://api.example.com/docs/authentication\"\n}\n\nAlternativamente: 403 Forbidden\n\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_client_certificate\",\n  \"message\": \"Your client certificate is invalid or not trusted\",\n  \"reason\": \"Certificate verification failed\",\n  \"note\": \"Using standard 403 instead of nginx-specific 495\"\n}\n\nVentajas de códigos estándar:\n- Mejor interoperabilidad con clientes HTTP\n- Más compatible con herramientas de monitoreo\n- Entendido por todos los frameworks y librerías\n- No requiere conocimiento específico de nginx",
                "explanation": "MEJOR PRÁCTICA: En lugar de usar el código no estándar 495 específico de nginx, es mejor usar códigos HTTP estándar como 401 Unauthorized (cuando falta autenticación) o 403 Forbidden (cuando la autenticación es inválida). Esto mejora la interoperabilidad y compatibilidad con herramientas estándar."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [
            "WWW-Authenticate"
        ],
        "relatedCodes": [
            401,
            403,
            496,
            497
        ],
        "technicalNotes": "495 es ESPECÍFICO DE NGINX y NO es estándar HTTP oficial. Se usa para problemas con CERTIFICADO DE CLIENTE en mTLS (autenticación mutua TLS), no certificados de servidor. Contexto: mTLS = cliente Y servidor presentan certificados (autenticación bidireccional). Causas de 495: certificado expirado, no firmado por CA confiable, revocado, propósito incorrecto, ausente cuando requerido. Nginx variables relacionadas: $ssl_client_verify (SUCCESS/FAILED), $ssl_client_cert, $ssl_client_s_dn, $ssl_client_i_dn. Otros códigos nginx SSL: 496 No Certificate (cliente no envió certificado cuando opcional), 497 HTTP to HTTPS (solicitud HTTP a puerto HTTPS). Alternativas estándar: 401 Unauthorized (falta autenticación), 403 Forbidden (autenticación inválida). Para producción: considerar usar 401/403 estándar en lugar de 495 para mejor compatibilidad.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786783/495_gr078p.png",
                "alt": "Imagen que representa el nombre del código 495 SSL Certificate Error"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786453/58-removebg-preview_kiposr.png",
                "alt": "Imagen del código 495 SSL Certificate Error"
            }
        ]
    },
    {
        "code": 496,
        "status": "SSL Certificate Required / No Certificate",
        "category": "Client Error (Non-standard)",
        "description": "El código 496 SSL Certificate Required (también conocido como 'No Certificate') es un código de estado HTTP NO estándar específico de nginx que indica que el cliente no proporcionó un certificado SSL/TLS de cliente cuando se esperaba uno, pero el certificado no era estrictamente obligatorio (configuración ssl_verify_client opcional). Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de nginx. El código 496 se diferencia del 495 en un aspecto clave: 495 se usa cuando el cliente proporciona un certificado pero es INVÁLIDO, mientras que 496 se usa cuando el cliente NO proporciona certificado en absoluto en un contexto donde es RECOMENDADO pero no estrictamente requerido. El servidor está diciendo: 'Esperaba que proporcionaras un certificado de cliente para autenticarte, pero no lo hiciste. Aunque no es estrictamente obligatorio, necesitas un certificado para acceder a este recurso específico'. Este código es útil en escenarios de autenticación flexible donde: algunos endpoints requieren certificado de cliente y otros no, se ofrece autenticación basada en certificado como opción premium o de mayor seguridad, se quiere permitir acceso básico sin certificado pero acceso completo con certificado, o se implementa degradación gradual de funcionalidad según el nivel de autenticación. La configuración nginx típica usa 'ssl_verify_client optional' o 'ssl_verify_client optional_no_ca', lo que significa que el servidor aceptará conexiones con o sin certificado de cliente, pero ciertas rutas pueden verificar la presencia del certificado y responder con 496 si falta. Este enfoque permite APIs híbridas donde algunos endpoints son públicos y otros requieren autenticación de certificado fuerte.",
        "useCases": [
            "nginx: Cliente no proporciona certificado cuando es esperado (pero no obligatorio)",
            "Autenticación opcional por certificado con degradación de funcionalidad",
            "APIs con endpoints públicos y privados en mismo servidor",
            "Acceso diferenciado según método de autenticación",
            "Certificado recomendado pero no estrictamente requerido",
            "NOTA: Específico de nginx, NO es estándar HTTP"
        ],
        "examples": [
            {
                "scenario": "nginx - Certificado opcional, endpoint específico lo requiere",
                "request": "GET /api/admin/settings HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer basic_user_token\n\n[Cliente se conecta sin certificado de cliente, solo con token Bearer]",
                "response": "HTTP/1.1 496 SSL Certificate Required\nContent-Type: application/json\n\n{\n  \"error\": \"certificate_required\",\n  \"message\": \"This endpoint requires client certificate authentication\",\n  \"error_code\": 496,\n  \"authentication_provided\": \"Bearer token\",\n  \"authentication_required\": \"Client certificate (mTLS)\",\n  \"explanation\": \"While you are authenticated via Bearer token, administrative endpoints require stronger authentication using client certificates\",\n  \"endpoint_classification\": {\n    \"type\": \"administrative\",\n    \"security_level\": \"high\",\n    \"authentication_required\": \"mTLS (mutual TLS with client certificate)\"\n  },\n  \"available_endpoints_without_certificate\": [\n    \"GET /api/public/info\",\n    \"GET /api/user/profile (with Bearer token)\",\n    \"POST /api/data (with Bearer token)\"\n  ],\n  \"certificate_protected_endpoints\": [\n    \"GET /api/admin/settings\",\n    \"POST /api/admin/users\",\n    \"DELETE /api/admin/data\",\n    \"PUT /api/admin/config\"\n  ],\n  \"how_to_obtain_certificate\": {\n    \"step_1\": \"Request admin-level client certificate from security team\",\n    \"step_2\": \"Generate CSR: openssl req -new -newkey rsa:2048 -nodes -keyout admin.key -out admin.csr\",\n    \"step_3\": \"Submit CSR to internal CA portal\",\n    \"step_4\": \"Install certificate: curl --cert admin.crt --key admin.key https://api.example.com/api/admin/settings\"\n  },\n  \"security_rationale\": \"Administrative operations require certificate-based authentication as an additional security layer beyond API tokens\",\n  \"contact\": \"security@example.com\"\n}\n\nConfiguración nginx:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    \n    # Certificado de cliente es OPCIONAL a nivel de servidor\n    ssl_client_certificate /etc/nginx/ssl/client-ca.crt;\n    ssl_verify_client optional;  # Acepta conexiones con o sin certificado\n    \n    # Endpoints públicos - no requieren certificado\n    location /api/public/ {\n        proxy_pass http://backend;\n    }\n    \n    # Endpoints de usuario - requieren token pero no certificado\n    location /api/user/ {\n        # Verificar token Bearer aquí\n        proxy_pass http://backend;\n    }\n    \n    # Endpoints administrativos - REQUIEREN certificado de cliente\n    location /api/admin/ {\n        # Si no hay certificado válido, rechazar con 496\n        if ($ssl_client_verify != SUCCESS) {\n            return 496;\n        }\n        \n        # Pasar info del certificado al backend\n        proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn;\n        proxy_set_header X-SSL-Client-Cert $ssl_client_cert;\n        proxy_pass http://backend;\n    }\n}",
                "explanation": "Una API tiene diferentes niveles de seguridad: endpoints públicos (sin autenticación), endpoints de usuario (token Bearer), y endpoints administrativos (requieren certificado de cliente). El servidor acepta conexiones con o sin certificado (ssl_verify_client optional), pero los endpoints /api/admin/ verifican explícitamente la presencia de certificado válido y responden con 496 si falta."
            },
            {
                "scenario": "nginx - Degradación de funcionalidad sin certificado",
                "request": "GET /api/data?include=sensitive HTTP/1.1\nHost: api.example.com\n\n[Cliente sin certificado intenta acceder a datos sensibles]",
                "response": "HTTP/1.1 496 SSL Certificate Required\nContent-Type: application/json\n\n{\n  \"error\": \"certificate_required_for_sensitive_data\",\n  \"message\": \"Client certificate required to access sensitive data\",\n  \"error_code\": 496,\n  \"requested_parameters\": {\n    \"include\": \"sensitive\"\n  },\n  \"issue\": \"The 'include=sensitive' parameter requires certificate-based authentication\",\n  \"functionality_levels\": {\n    \"basic_access\": {\n      \"authentication\": \"None required\",\n      \"available_data\": \"Public information only\",\n      \"example\": \"GET /api/data\"\n    },\n    \"standard_access\": {\n      \"authentication\": \"API key or Bearer token\",\n      \"available_data\": \"Standard dataset\",\n      \"example\": \"GET /api/data?api_key=YOUR_KEY\"\n    },\n    \"premium_access\": {\n      \"authentication\": \"Client certificate (mTLS)\",\n      \"available_data\": \"All data including sensitive fields\",\n      \"example\": \"GET /api/data?include=sensitive (with client certificate)\",\n      \"additional_features\": [\n        \"Access to PII data\",\n        \"Financial information\",\n        \"Audit logs\",\n        \"Administrative metadata\"\n      ]\n    }\n  },\n  \"alternative_request\": {\n    \"without_sensitive_data\": \"GET /api/data (returns standard dataset)\",\n    \"with_api_key\": \"GET /api/data?api_key=YOUR_KEY (returns standard dataset)\",\n    \"note\": \"Remove 'include=sensitive' parameter to access without certificate\"\n  },\n  \"upgrade_to_certificate_auth\": {\n    \"benefits\": [\n      \"Access to sensitive data fields\",\n      \"Higher rate limits\",\n      \"Priority support\",\n      \"Audit trail compliance\"\n    ],\n    \"contact\": \"enterprise@example.com\"\n  }\n}\n\nConfiguración nginx:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    ssl_client_certificate /etc/nginx/ssl/client-ca.crt;\n    ssl_verify_client optional;\n    \n    location /api/data {\n        # Verificar si se solicita datos sensibles\n        if ($arg_include = \"sensitive\") {\n            # Si incluye datos sensibles, requiere certificado\n            if ($ssl_client_verify != SUCCESS) {\n                return 496;\n            }\n        }\n        \n        # Pasar nivel de autenticación al backend\n        proxy_set_header X-Auth-Level $ssl_client_verify;\n        proxy_pass http://backend;\n    }\n}",
                "explanation": "La API implementa niveles de acceso graduales. Los datos básicos están disponibles sin autenticación, datos estándar requieren API key, y datos sensibles requieren certificado de cliente. Cuando un usuario sin certificado intenta acceder a include=sensitive, recibe 496 con explicación de los niveles de acceso disponibles."
            },
            {
                "scenario": "nginx - Acceso parcial sin certificado",
                "request": "GET /dashboard HTTP/1.1\nHost: portal.example.com\nCookie: session_id=abc123\n\n[Usuario con sesión válida pero sin certificado de cliente]",
                "response": "HTTP/1.1 200 OK\nContent-Type: text/html\nX-Certificate-Status: not-provided\nX-Access-Level: standard\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Dashboard - Standard Access</title>\n</head>\n<body>\n    <div class=\"banner warning\">\n        <h3>⚠️ Limited Access Mode</h3>\n        <p>You are viewing the dashboard in standard mode. Some features are restricted.</p>\n        <p><strong>Upgrade to premium access:</strong> Install a client certificate for full functionality.</p>\n        <a href=\"/help/client-certificates\">Learn how to install client certificate</a>\n    </div>\n    \n    <div class=\"dashboard\">\n        <h1>Welcome, User</h1>\n        \n        <!-- Features disponibles sin certificado -->\n        <section class=\"available\">\n            <h2>Available Features</h2>\n            <ul>\n                <li>✓ View basic statistics</li>\n                <li>✓ Read public documents</li>\n                <li>✓ Submit support tickets</li>\n            </ul>\n        </section>\n        \n        <!-- Features que requieren certificado -->\n        <section class=\"restricted\">\n            <h2>Premium Features (Certificate Required)</h2>\n            <ul>\n                <li>🔒 Advanced analytics</li>\n                <li>🔒 Download confidential reports</li>\n                <li>🔒 Administrative controls</li>\n                <li>🔒 API access management</li>\n            </ul>\n            <button disabled>Unlock with Certificate</button>\n        </section>\n    </div>\n</body>\n</html>\n\nConfiguración nginx:\n\nserver {\n    listen 443 ssl;\n    server_name portal.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    ssl_client_certificate /etc/nginx/ssl/client-ca.crt;\n    ssl_verify_client optional;\n    \n    location /dashboard {\n        # Permitir acceso con funcionalidad limitada\n        proxy_set_header X-Has-Certificate $ssl_client_verify;\n        proxy_pass http://backend;\n    }\n    \n    location /api/premium/ {\n        # Features premium requieren certificado\n        if ($ssl_client_verify != SUCCESS) {\n            return 496;\n        }\n        proxy_pass http://backend;\n    }\n}",
                "explanation": "En lugar de bloquear completamente el acceso, el portal permite ver el dashboard con funcionalidad limitada sin certificado. El backend recibe información sobre si el usuario tiene certificado válido (X-Has-Certificate header) y ajusta la interfaz en consecuencia. Los endpoints premium específicos (/api/premium/) sí devuelven 496 si falta el certificado."
            },
            {
                "scenario": "Alternativa usando códigos HTTP estándar",
                "request": "GET /api/secure-data HTTP/1.1\nHost: api.example.com",
                "response": "MEJOR PRÁCTICA: Usar códigos HTTP estándar\n\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: ClientCertificate realm=\"api.example.com\", charset=\"UTF-8\"\nContent-Type: application/json\n\n{\n  \"error\": \"authentication_required\",\n  \"message\": \"Client certificate authentication required\",\n  \"authentication_methods\": {\n    \"required\": \"Client Certificate (mTLS)\",\n    \"provided\": \"None\"\n  },\n  \"how_to_authenticate\": \"Connect with a valid client certificate\",\n  \"note\": \"Using standard 401 Unauthorized instead of nginx-specific 496 for better compatibility\"\n}\n\nO alternativamente:\n\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"insufficient_authentication\",\n  \"message\": \"This resource requires client certificate authentication\",\n  \"current_authentication\": \"None\",\n  \"required_authentication\": \"Client Certificate\",\n  \"note\": \"Using standard 403 Forbidden instead of nginx-specific 496\"\n}\n\nVentajas:\n- Estándar HTTP reconocido universalmente\n- Compatible con todas las herramientas y frameworks\n- Mejor para interoperabilidad\n- No requiere conocimiento específico de nginx",
                "explanation": "MEJOR PRÁCTICA: En lugar de usar el código no estándar 496 específico de nginx, es preferible usar códigos HTTP oficiales como 401 Unauthorized (cuando falta autenticación requerida) o 403 Forbidden (cuando el nivel de autenticación es insuficiente). Esto garantiza mejor compatibilidad e interoperabilidad."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [
            "WWW-Authenticate"
        ],
        "relatedCodes": [
            401,
            403,
            495,
            497
        ],
        "technicalNotes": "496 es ESPECÍFICO DE NGINX y NO es estándar HTTP oficial. Diferencias con códigos relacionados: 495 = certificado proporcionado pero INVÁLIDO; 496 = certificado NO proporcionado cuando es esperado/recomendado; 497 = solicitud HTTP a puerto HTTPS. Contexto de uso: ssl_verify_client optional o optional_no_ca (certificado no obligatorio a nivel de servidor pero puede ser requerido por ubicaciones específicas). Nginx variables útiles: $ssl_client_verify (SUCCESS/NONE/FAILED), $ssl_client_cert (certificado en formato PEM), $ssl_client_s_dn (Subject DN). Casos de uso: autenticación gradual, acceso diferenciado, APIs híbridas (públicas + privadas), degradación de funcionalidad. Alternativas estándar: 401 Unauthorized (falta autenticación), 403 Forbidden (autenticación insuficiente). Para mejor compatibilidad: usar códigos estándar 401/403 con mensajes descriptivos en lugar de 496 específico de nginx.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786787/496_jhnpwj.png",
                "alt": "Imagen que representa el nombre del código 496 SSL Certificate Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786449/59-removebg-preview_tdak8v.png",
                "alt": "Imagen del código 496 SSL Certificate Required"
            }
        ]
    },
    {
        "code": 497,
        "status": "HTTP Request Sent to HTTPS Port",
        "category": "Client Error (Non-standard)",
        "description": "El código 497 HTTP Request Sent to HTTPS Port es un código de estado HTTP NO estándar específico de nginx que indica que el cliente envió una solicitud HTTP simple (sin encriptación) a un puerto configurado para HTTPS (TLS/SSL). Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de nginx. El servidor está diciendo: 'Enviaste una solicitud HTTP plana (no encriptada) al puerto 443 (o cualquier puerto configurado para SSL), pero este puerto solo acepta conexiones HTTPS encriptadas'. Este error ocurre cuando hay una discordancia entre el protocolo que el cliente está usando (HTTP) y el protocolo que el servidor espera en ese puerto específico (HTTPS). Los escenarios comunes incluyen: un usuario escribe 'http://example.com' pero el servidor solo acepta HTTPS en el puerto 80 (redirigido) o directamente en 443, configuración incorrecta del cliente que intenta HTTP en puerto 443, scripts o aplicaciones legacy que no usan HTTPS, proxies mal configurados que reenvían HTTP a puertos HTTPS, o errores de código donde se construye URL con 'http://' en lugar de 'https://'. El código 497 es útil porque permite a nginx detectar estas solicitudes mal dirigidas y tomar acciones apropiadas como: cerrar la conexión, devolver un error, o más comúnmente, redirigir automáticamente a HTTPS. En la práctica moderna, la mayoría de las configuraciones nginx usan 497 para implementar redirección automática de HTTP a HTTPS, mejorando la experiencia del usuario en lugar de simplemente mostrar un error. Este código es parte de la familia de códigos 4xx específicos de nginx relacionados con SSL/TLS (495, 496, 497) que ayudan a diagnosticar y manejar problemas de configuración de seguridad de transporte.",
        "useCases": [
            "nginx: Detectar solicitudes HTTP enviadas a puerto HTTPS",
            "Redirección automática de HTTP a HTTPS",
            "Prevenir acceso HTTP accidental a puertos SSL",
            "Diagnóstico de problemas de configuración de cliente",
            "Manejo de errores en migración HTTP→HTTPS",
            "NOTA: Específico de nginx, NO es estándar HTTP"
        ],
        "examples": [
            {
                "scenario": "nginx - HTTP a puerto HTTPS (con redirección automática)",
                "request": "GET / HTTP/1.1\nHost: example.com\n\n[Solicitud HTTP enviada al puerto 443 que espera HTTPS]",
                "response": "Configuración nginx común (redirección automática):\n\nserver {\n    listen 443 ssl;\n    server_name example.com;\n    \n    ssl_certificate /etc/nginx/ssl/example.com.crt;\n    ssl_certificate_key /etc/nginx/ssl/example.com.key;\n    \n    # Interceptar solicitudes HTTP en puerto HTTPS y redirigir\n    error_page 497 =301 https://$host$request_uri;\n    \n    location / {\n        root /var/www/html;\n        index index.html;\n    }\n}\n\nLo que sucede:\n1. Cliente envía: GET / HTTP/1.1 al puerto 443\n2. nginx detecta que es HTTP plano en puerto SSL\n3. nginx internamente genera código 497\n4. La directiva error_page convierte 497 en redirección 301\n5. Cliente recibe:\n\nHTTP/1.1 301 Moved Permanently\nLocation: https://example.com/\nContent-Type: text/html\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"https://example.com/\">here</a>.</p>\n</body>\n</html>\n\n6. Cliente automáticamente redirige a HTTPS\n\nResultado final:\nEl usuario que accidentalmente usó http:// es redirigido automáticamente a https://\nsin ver ningún error, mejorando la experiencia de usuario.",
                "explanation": "CASO MÁS COMÚN: Un cliente envía solicitud HTTP al puerto 443 que está configurado para HTTPS. nginx detecta el error (código interno 497) pero en lugar de mostrarlo al usuario, usa error_page para convertirlo automáticamente en una redirección 301 a la versión HTTPS. Esto es una práctica común para manejar graciosamente usuarios que olvidan usar https://"
            },
            {
                "scenario": "nginx - Mensaje de error explícito (sin redirección)",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\n\n[Solicitud HTTP al puerto 443]",
                "response": "Configuración nginx (mostrar error en lugar de redirigir):\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/api.crt;\n    ssl_certificate_key /etc/nginx/ssl/api.key;\n    \n    # Página de error personalizada para 497\n    error_page 497 /497.html;\n    \n    location = /497.html {\n        root /var/www/errors;\n        internal;\n    }\n}\n\nContenido de /var/www/errors/497.html:\n\nHTTP/1.1 497 HTTP Request Sent to HTTPS Port\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>497 - HTTPS Required</title>\n    <style>\n        body { font-family: Arial; margin: 40px; background: #f5f5f5; }\n        .container { background: white; padding: 30px; border-radius: 5px; border-left: 5px solid #e74c3c; }\n        .error-code { color: #e74c3c; font-size: 48px; font-weight: bold; }\n        code { background: #f0f0f0; padding: 2px 6px; border-radius: 3px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"error-code\">497</div>\n        <h1>HTTPS Required</h1>\n        <p>You sent an HTTP request to an HTTPS port.</p>\n        \n        <h2>What happened?</h2>\n        <p>You tried to access <code>http://api.example.com</code> but this server only accepts secure HTTPS connections on this port.</p>\n        \n        <h2>How to fix this:</h2>\n        <ol>\n            <li>Change your URL from <code>http://</code> to <code>https://</code></li>\n            <li>Correct URL: <a href=\"https://api.example.com/api/data\">https://api.example.com/api/data</a></li>\n            <li>Update your application/script to use HTTPS</li>\n        </ol>\n        \n        <h2>For developers:</h2>\n        <p>If you're calling this API programmatically:</p>\n        <pre><code>// ❌ Wrong\nfetch('http://api.example.com/api/data')\n\n// ✅ Correct\nfetch('https://api.example.com/api/data')</code></pre>\n        \n        <p><small>Error code: 497 (nginx-specific) - HTTP request sent to HTTPS port</small></p>\n    </div>\n</body>\n</html>",
                "explanation": "En este caso, el servidor muestra explícitamente el error 497 al usuario en lugar de redirigir automáticamente. Esto puede ser apropiado para APIs donde se quiere que los desarrolladores corrijan sus aplicaciones para usar HTTPS correctamente desde el inicio, en lugar de depender de redirecciones."
            },
            {
                "scenario": "nginx - Múltiples puertos con diferentes comportamientos",
                "request": "Escenario complejo con múltiples configuraciones:\n\nSolicitud 1: GET / HTTP/1.1 al puerto 80\nSolicitud 2: GET / HTTP/1.1 al puerto 443\nSolicitud 3: GET / HTTPS/1.1 al puerto 443",
                "response": "Configuración nginx completa:\n\n# Servidor HTTP en puerto 80 - Redirige todo a HTTPS\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    \n    # Redirección permanente a HTTPS\n    return 301 https://$host$request_uri;\n}\n\n# Servidor HTTPS en puerto 443\nserver {\n    listen 443 ssl http2;\n    server_name example.com www.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/example.com.crt;\n    ssl_certificate_key /etc/nginx/ssl/example.com.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    \n    # Si alguien envía HTTP al puerto 443, redirigir a HTTPS\n    error_page 497 =301 https://$host$request_uri;\n    \n    location / {\n        root /var/www/html;\n        index index.html;\n    }\n}\n\nResultados para cada solicitud:\n\nSolicitud 1: GET / HTTP/1.1 → puerto 80\nRespuesta: HTTP/1.1 301 Moved Permanently\n          Location: https://example.com/\nExplicación: Servidor en puerto 80 redirige explícitamente a HTTPS\n\nSolicitud 2: GET / HTTP/1.1 → puerto 443  \nProceso:\n  1. nginx detecta HTTP en puerto SSL → genera 497 internamente\n  2. error_page 497 convierte a 301\n  3. Respuesta: HTTP/1.1 301 Moved Permanently\n               Location: https://example.com/\nExplicación: HTTP enviado a puerto HTTPS activó código 497, convertido a redirección\n\nSolicitud 3: GET / HTTPS/1.1 → puerto 443 (con TLS handshake)\nRespuesta: HTTP/1.1 200 OK (contenido normal)\nExplicación: Solicitud correcta HTTPS al puerto HTTPS, funciona normalmente\n\nEsta configuración asegura que:\n- Usuarios que usan http://example.com → redirigidos desde puerto 80\n- Usuarios que usan http://example.com:443 → redirigidos por 497\n- Usuarios que usan https://example.com → funcionan correctamente\n- Todos los caminos llevan a HTTPS",
                "explanation": "Configuración completa que maneja correctamente todos los escenarios: HTTP en puerto 80 (redirigido por configuración del servidor), HTTP en puerto 443 (redirigido por error_page 497), y HTTPS en puerto 443 (funciona normalmente). Esto garantiza que sin importar cómo el usuario intente acceder, terminará en HTTPS."
            },
            {
                "scenario": "Detección de cliente mal configurado",
                "request": "GET /api/v1/users HTTP/1.1\nHost: api.example.com:443\nUser-Agent: CustomApp/1.0\n\n[Aplicación configurada incorrectamente enviando HTTP a puerto 443]",
                "response": "HTTP/1.1 497 HTTP Request Sent to HTTPS Port\nContent-Type: application/json\n\n{\n  \"error\": \"protocol_mismatch\",\n  \"error_code\": 497,\n  \"message\": \"HTTP request sent to HTTPS port\",\n  \"details\": {\n    \"requested_protocol\": \"HTTP\",\n    \"required_protocol\": \"HTTPS\",\n    \"requested_port\": 443,\n    \"port_configuration\": \"HTTPS only\"\n  },\n  \"your_request\": {\n    \"url\": \"http://api.example.com:443/api/v1/users\",\n    \"method\": \"GET\",\n    \"user_agent\": \"CustomApp/1.0\"\n  },\n  \"problem\": \"Your application is configured to use HTTP protocol but connecting to an HTTPS-only port (443)\",\n  \"solution\": {\n    \"correct_url\": \"https://api.example.com/api/v1/users\",\n    \"changes_needed\": [\n      \"Change protocol from 'http://' to 'https://'\" ,\n      \"Remove explicit port :443 (it's default for HTTPS)\",\n      \"Update your application configuration\"\n    ]\n  },\n  \"code_examples\": {\n    \"incorrect\": \"http://api.example.com:443/api/v1/users\",\n    \"correct\": \"https://api.example.com/api/v1/users\"\n  },\n  \"nginx_specific\": {\n    \"note\": \"Error code 497 is nginx-specific and indicates HTTP/HTTPS port mismatch\",\n    \"standard_alternative\": \"Consider using 400 Bad Request for better compatibility\"\n  },\n  \"support\": \"For integration help, contact: api-support@example.com\"\n}\n\nConfiguración nginx que genera esta respuesta:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/api.crt;\n    ssl_certificate_key /etc/nginx/ssl/api.key;\n    \n    # En lugar de redirigir, devolver error JSON informativo\n    location @497_error {\n        default_type application/json;\n        return 497 '{\"error\":\"protocol_mismatch\",\"message\":\"HTTP sent to HTTPS port\"}';\n    }\n    \n    error_page 497 = @497_error;\n}",
                "explanation": "En lugar de redirigir silenciosamente, este servidor API devuelve un error JSON detallado cuando detecta HTTP en puerto HTTPS. Esto ayuda a los desarrolladores a identificar y corregir problemas de configuración en sus aplicaciones cliente, especialmente útil durante desarrollo e integración."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [
            "Location (cuando se convierte a redirección)"
        ],
        "relatedCodes": [
            301,
            400,
            495,
            496
        ],
        "technicalNotes": "497 es ESPECÍFICO DE NGINX y NO es estándar HTTP oficial. Se genera cuando: cliente envía solicitud HTTP plana a puerto configurado con SSL (listen ... ssl). Uso más común: error_page 497 =301 https://$host$request_uri; para redirección automática HTTP→HTTPS. Esto mejora UX al manejar graciosamente URLs http:// que apuntan a puertos HTTPS. Códigos nginx SSL relacionados: 495 (certificado cliente inválido), 496 (certificado cliente faltante), 497 (HTTP a puerto HTTPS). Escenarios que causan 497: URL con http:// pero puerto 443, cliente mal configurado, scripts legacy sin HTTPS, proxies mal configurados. Mejores prácticas: usar redirección automática con error_page 497, configurar HSTS para prevenir intentos HTTP futuros, documentar claramente que la API requiere HTTPS. Alternativa estándar: en lugar de 497, algunos prefieren devolver 400 Bad Request con mensaje explicativo para mejor compatibilidad con clientes que no entienden códigos nginx-specific.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786783/497_rqigqj.png",
                "alt": "Imagen que representa el nombre del código 497  HTTP Request Sent to HTTPS Port"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786447/60-removebg-preview_kdxckt.png",
                "alt": "Imagen del código 497 HTTP Request Sent to HTTPS Port"
            }
        ]
    },
    {
        "code": 498,
        "status": "Invalid Token",
        "category": "Client Error (Non-standard)",
        "description": "El código 498 Invalid Token es un código de estado HTTP NO estándar específico de nginx que indica que el token proporcionado por el cliente es inválido o ha expirado. Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de nginx. El servidor está diciendo: 'La solicitud incluye un token de autenticación pero ese token no es válido, está mal formado, ha expirado o ha sido revocado'. Es importante entender que el código 498 NO es parte del estándar HTTP - es una extensión propietaria de nginx utilizada principalmente en implementaciones que manejan tokens de autenticación directamente en la capa del proxy. Este código es útil para distinguir entre diferentes tipos de problemas de autenticación: mientras que 401 Unauthorized indica falta de credenciales o credenciales incorrectas, el 498 específicamente señala un problema con el token en sí. Las razones por las que un token puede ser inválido incluyen: token expirado (el más común), token revocado explícitamente, token mal formado o corrupto, firma del token inválida (en JWT), token emitido por autoridad no confiable, claims del token inválidos, o token usado antes de su tiempo de validez (nbf claim). El código 498 es especialmente común en: arquitecturas con API Gateway basado en nginx, sistemas que usan JWT para autenticación, aplicaciones con sesiones basadas en tokens, microservicios con autenticación centralizada, o implementaciones con módulos de autenticación personalizados en nginx. Monitorear la frecuencia de códigos 498 puede ayudar a identificar problemas con la generación de tokens, tiempos de expiración mal configurados, o intentos de acceso con tokens comprometidos.",
        "useCases": [
            "nginx: Token de autenticación inválido o expirado",
            "JWT expirado o con firma inválida",
            "Token revocado explícitamente por el sistema",
            "Token mal formado o corrupto",
            "Token usado antes de su tiempo de validez (nbf)",
            "Firma del token no coincide con la esperada",
            "NOTA: Específico de nginx, NO es estándar HTTP"
        ],
        "examples": [
            {
                "scenario": "JWT expirado enviado en request",
                "request": "GET /api/user/profile HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiZXhwIjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n[Token JWT tiene exp: 1516239022 (Jan 18, 2018)]\n[Fecha actual: Jan 17, 2024 - token expiró hace 6 años]",
                "response": "HTTP/1.1 498 Invalid Token\nServer: nginx/1.24.0\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nContent-Type: application/json\nContent-Length: 87\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"Token has expired\"\n\n{\n  \"error\": \"invalid_token\",\n  \"error_description\": \"Token has expired\",\n  \"expired_at\": \"2018-01-18T00:37:02Z\"\n}",
                "explanation": "El cliente envía un JWT que expiró hace años. nginx, configurado con un módulo de validación JWT, detecta que el claim 'exp' del token es anterior a la fecha actual y devuelve 498. Este es el caso más común de 498: tokens que eran válidos pero ya expiraron."
            },
            {
                "scenario": "Token con firma inválida (JWT manipulado)",
                "request": "GET /api/admin/users HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzA1NTAwMDAwfQ.FIRMA_MANIPULADA_INVALIDA\n\n[Atacante intentó cambiar 'role' de 'user' a 'admin' en el payload]\n[Pero no pudo regenerar la firma correctamente]",
                "response": "HTTP/1.1 498 Invalid Token\nServer: nginx/1.24.0\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nContent-Type: application/json\nContent-Length: 103\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"Token signature verification failed\"\n\n{\n  \"error\": \"invalid_token\",\n  \"error_description\": \"Token signature verification failed\",\n  \"reason\": \"Signature mismatch\"\n}\n\nConfiguración nginx con módulo JWT:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    location /api/ {\n        # Validar JWT antes de reenviar al backend\n        auth_jwt \"API Protected\";\n        auth_jwt_key_file /etc/nginx/jwt_secret.key;\n        \n        # Si JWT es inválido (expirado, firma incorrecta, etc.)\n        # nginx devuelve 498 Invalid Token\n        error_page 498 = @invalid_token;\n        \n        proxy_pass http://api_backend;\n    }\n    \n    location @invalid_token {\n        default_type application/json;\n        return 498 '{\"error\":\"invalid_token\",\"error_description\":\"Token validation failed\"}';\n    }\n}\n\nProceso de validación:\n1. Cliente envía request con JWT en header Authorization\n2. nginx extrae el token del header\n3. nginx valida:\n   - Formato del token (header.payload.signature)\n   - Firma usando la clave secreta\n   - Claims: exp (expiración), nbf (not before), iat (issued at)\n4. Si cualquier validación falla → 498 Invalid Token\n5. Si todo OK → request pasa al backend con token validado",
                "explanation": "Un atacante intenta manipular el payload de un JWT para elevar sus privilegios de 'user' a 'admin'. Sin embargo, al cambiar el payload sin conocer la clave secreta, la firma se vuelve inválida. nginx detecta que la firma no coincide con el payload y devuelve 498, previniendo el ataque."
            },
            {
                "scenario": "Token usado antes de su tiempo de validez (nbf claim)",
                "request": "GET /api/scheduled/report HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyNDU2IiwibmJmIjoxNzA1NTAwMDAwLCJleHAiOjE3MDU1ODY0MDB9.signature\n\n[Token tiene nbf (not before): 1705500000 = Jan 17, 2024 16:00:00]\n[Request hecho a las: Jan 17, 2024 15:30:00]\n[Token todavía no es válido - faltan 30 minutos]",
                "response": "HTTP/1.1 498 Invalid Token\nServer: nginx/1.24.0\nDate: Wed, 17 Jan 2024 15:30:00 GMT\nContent-Type: application/json\nContent-Length: 112\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"Token not yet valid\"\n\n{\n  \"error\": \"invalid_token\",\n  \"error_description\": \"Token not yet valid\",\n  \"not_before\": \"2024-01-17T16:00:00Z\",\n  \"current_time\": \"2024-01-17T15:30:00Z\"\n}\n\nEscenario de uso:\nSistema genera tokens para reportes programados que solo deben ser accesibles\na partir de cierta hora. Por ejemplo:\n\n- Reporte financiero se genera a las 16:00\n- Token emitido a las 15:00 con nbf=16:00\n- Si usuario intenta acceder antes de las 16:00 → 498\n- Previene acceso prematuro a datos sensibles\n\nConfiguración:\n\nserver {\n    location /api/scheduled/ {\n        auth_jwt \"Scheduled Access\";\n        auth_jwt_key_file /etc/nginx/jwt_secret.key;\n        \n        # nginx valida automáticamente el claim 'nbf'\n        # Si current_time < nbf → 498 Invalid Token\n        \n        proxy_pass http://backend;\n    }\n}",
                "explanation": "Un token JWT incluye el claim 'nbf' (not before) que indica que el token solo es válido a partir de las 16:00. El usuario intenta usarlo a las 15:30. nginx valida el claim nbf y detecta que el token todavía no es válido, devolviendo 498. Este mecanismo permite controlar cuándo un token se vuelve activo."
            },
            {
                "scenario": "Token revocado en lista negra",
                "request": "GET /api/sensitive/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyNzg5IiwianRpIjoiYWJjMTIzIiwiZXhwIjoxNzA1NTg2NDAwfQ.signature\n\n[Token tiene jti (JWT ID): abc123]\n[Este jti está en la lista de tokens revocados]\n[Usuario cerró sesión, pero token JWT aún no expiró naturalmente]",
                "response": "HTTP/1.1 498 Invalid Token\nServer: nginx/1.24.0\nDate: Wed, 17 Jan 2024 16:00:00 GMT\nContent-Type: application/json\nContent-Length: 95\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"Token has been revoked\"\n\n{\n  \"error\": \"invalid_token\",\n  \"error_description\": \"Token has been revoked\",\n  \"token_id\": \"abc123\",\n  \"revoked_at\": \"2024-01-17T15:45:00Z\"\n}\n\nImplementación con nginx + Redis para blacklist:\n\nserver {\n    location /api/sensitive/ {\n        # Validar JWT\n        auth_jwt \"Protected API\";\n        auth_jwt_key_file /etc/nginx/jwt_secret.key;\n        \n        # Verificar contra blacklist en Redis usando Lua\n        access_by_lua_block {\n            local jwt = require \"resty.jwt\"\n            local redis = require \"resty.redis\"\n            \n            -- Obtener token del header\n            local auth_header = ngx.var.http_authorization\n            if not auth_header then\n                return ngx.exit(401)\n            end\n            \n            local token = auth_header:sub(8)  -- Remover \"Bearer \"\n            local jwt_obj = jwt:load_jwt(token)\n            \n            -- Verificar si jti está en blacklist Redis\n            local red = redis:new()\n            red:connect(\"127.0.0.1\", 6379)\n            \n            local jti = jwt_obj.payload.jti\n            local is_revoked = red:get(\"revoked:\" .. jti)\n            \n            if is_revoked == \"1\" then\n                ngx.status = 498\n                ngx.header[\"Content-Type\"] = \"application/json\"\n                ngx.say('{\"error\":\"invalid_token\",\"error_description\":\"Token has been revoked\"}')\n                return ngx.exit(498)\n            end\n        }\n        \n        proxy_pass http://backend;\n    }\n}\n\nProceso de revocación:\n1. Usuario cierra sesión: POST /api/auth/logout\n2. Backend añade jti del token a Redis:\n   SET revoked:abc123 \"1\" EX 86400  # Expira cuando el token expiraría\n3. Futuros requests con ese token → nginx consulta Redis → 498\n\nVentajas:\n- Permite invalidar tokens JWT antes de su expiración natural\n- Útil para: logout, cambio de contraseña, compromiso de seguridad\n- Redis provee almacenamiento rápido y con TTL automático",
                "explanation": "Un usuario cierra sesión, pero los JWT son stateless y normalmente siguen siendo válidos hasta su expiración. Para revocar el token inmediatamente, el sistema mantiene una blacklist en Redis. nginx consulta esta blacklist antes de permitir el acceso y devuelve 498 si el token está revocado, incluso si técnicamente aún no ha expirado."
            },
            {
                "scenario": "Monitoreo y análisis de tokens inválidos",
                "request": "Análisis de nginx access.log para identificar patrones de 498",
                "response": "Ejemplo de logs nginx con códigos 498:\n\n# access.log con formato extendido\n203.0.113.10 - user123 [17/Jan/2024:10:15:30 +0000] \"GET /api/profile HTTP/1.1\" 200 1534 \"-\" \"App/2.0\"\n203.0.113.11 - - [17/Jan/2024:10:16:45 +0000] \"GET /api/data HTTP/1.1\" 498 87 \"-\" \"App/2.0\" \"token_expired\"\n203.0.113.12 - user456 [17/Jan/2024:10:17:20 +0000] \"POST /api/update HTTP/1.1\" 200 412 \"-\" \"App/2.0\"\n203.0.113.11 - - [17/Jan/2024:10:17:30 +0000] \"GET /api/data HTTP/1.1\" 498 87 \"-\" \"App/2.0\" \"token_expired\"\n203.0.113.15 - - [17/Jan/2024:10:18:00 +0000] \"GET /api/admin HTTP/1.1\" 498 103 \"-\" \"curl/7.68\" \"invalid_signature\"\n203.0.113.11 - user123 [17/Jan/2024:10:18:15 +0000] \"GET /api/data HTTP/1.1\" 200 2341 \"-\" \"App/2.0\"\n203.0.113.20 - - [17/Jan/2024:10:19:00 +0000] \"GET /api/secure HTTP/1.1\" 498 95 \"-\" \"App/1.5\" \"token_revoked\"\n\nAnálisis con comandos:\n\n# Contar códigos de estado\n$ awk '{print $9}' access.log | sort | uniq -c | sort -rn\n   5430 200\n    287 498  ← Alta cantidad de tokens inválidos\n    156 401\n     45 403\n     12 500\n\n# Razones de 498 (si se logea el motivo)\n$ awk '$9 == 498 {print $NF}' access.log | tr -d '\"' | sort | uniq -c | sort -rn\n    189 token_expired       ← 66% son tokens expirados\n     54 invalid_signature   ← 19% firmas inválidas (intentos de manipulación?)\n     32 token_revoked       ← 11% tokens revocados\n     12 token_not_yet_valid ← 4% usados prematuramente\n\n# IPs con más intentos de tokens inválidos\n$ awk '$9 == 498 {print $1}' access.log | sort | uniq -c | sort -rn | head -5\n     45 203.0.113.15  ← IP sospechosa con muchos intentos\n     12 203.0.113.11\n      8 198.51.100.5\n      5 192.0.2.100\n      3 203.0.113.20\n\n# Análisis temporal de 498s por hora\n$ awk '$9 == 498 {print $4}' access.log | cut -d: -f2 | sort | uniq -c\n     15 08  # 8 AM\n     23 09  # 9 AM - pico (usuarios volviendo después de la noche)\n     45 10  # 10 AM - pico mayor\n     32 11  # 11 AM\n     18 12  # 12 PM\n\nInterpretación y acciones:\n\n1. **66% tokens expirados (189 de 287)**\n   - Problema: TTL de tokens muy corto vs patrón de uso\n   - Solución: Aumentar tiempo de expiración O implementar refresh tokens\n   - Si tokens expiran cada 1 hora pero usuarios usan app continuamente\n     → frustración con re-autenticaciones frecuentes\n\n2. **19% firmas inválidas (54 intentos)**\n   - IP 203.0.113.15 tiene 45 intentos → posible atacante\n   - Acción: Investigar e implementar rate limiting o bloqueo\n   - Comando para bloquear en nginx:\n     ```\n     # En nginx.conf\n     geo $blocked_ip {\n         default 0;\n         203.0.113.15 1;\n     }\n     \n     server {\n         if ($blocked_ip) {\n             return 403;\n         }\n     }\n     ```\n\n3. **Pico de 498s a las 9-10 AM**\n   - Usuarios regresan después de la noche\n   - Tokens emitidos ayer a las 5 PM (con exp=16h) → expirados\n   - Solución: Extender expiración a 24h O implementar \"remember me\"\n\n4. **11% tokens revocados**\n   - Normal si hay muchos logouts\n   - Verificar que TTL de blacklist coincida con exp del token\n\nConfiguración nginx para logging detallado:\n\nhttp {\n    # Mapear razón de 498 para logging\n    map $upstream_http_x_token_error $token_error_reason {\n        default \"unknown\";\n        \"expired\" \"token_expired\";\n        \"invalid_signature\" \"invalid_signature\";\n        \"revoked\" \"token_revoked\";\n        \"not_yet_valid\" \"token_not_yet_valid\";\n    }\n    \n    log_format jwt_detailed '$remote_addr - $remote_user [$time_local] '\n                           '\"$request\" $status $body_bytes_sent '\n                           '\"$http_referer\" \"$http_user_agent\" '\n                           '\"$token_error_reason\"';\n    \n    access_log /var/log/nginx/access.log jwt_detailed;\n}\n\nDashboard de monitoreo (Prometheus + Grafana):\n\n# Métricas a trackear\n- Total 498s por hora/día\n- Ratio 498/(200+498) → tasa de tokens inválidos\n- Breakdown por razón (expired, invalid_signature, etc.)\n- Top IPs con 498s\n- Distribución temporal de 498s\n\n# Alertas\n- Si 498s > 100/hora → revisar expiración de tokens\n- Si invalid_signature > 10 desde misma IP → posible ataque\n- Si token_expired spike a ciertas horas → ajustar TTL",
                "explanation": "Monitorear códigos 498 en logs es esencial para identificar problemas con tokens. Alta frecuencia de 498 puede indicar: (1) tiempos de expiración muy cortos causando frustración, (2) intentos de ataque con tokens manipulados, (3) problemas con sincronización de tiempo entre cliente/servidor, o (4) blacklist de revocación mal configurada. El análisis de logs permite optimizar la configuración de tokens y detectar amenazas de seguridad."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [
            "Authorization",
            "WWW-Authenticate"
        ],
        "relatedCodes": [
            401,
            403,
            499
        ],
        "technicalNotes": "498 es ESPECÍFICO DE NGINX y NO es estándar HTTP oficial. Se usa principalmente con módulos de autenticación JWT en nginx (ngx_http_auth_jwt_module). Diferencias clave: 401 Unauthorized = falta credenciales o credenciales incorrectas; 498 Invalid Token = token presente pero inválido/expirado; 403 Forbidden = autenticado pero sin permisos; 499 Client Closed Request = cliente canceló antes de respuesta. Validaciones que disparan 498: (1) exp claim expirado, (2) firma JWT inválida, (3) nbf (not before) no alcanzado, (4) token en blacklist/revocado, (5) algoritmo de firma no permitido, (6) issuer (iss) no confiable, (7) audience (aud) incorrecta, (8) formato de token mal formado. Implementación típica usa: auth_jwt directive, auth_jwt_key_file para verificar firma, access_by_lua para validaciones personalizadas (blacklist), map para personalizar respuestas. Monitoreo: alta tasa de 498 puede indicar: TTL muy corto, sincronización de tiempo incorrecta, intentos de manipulación de tokens, problemas con refresh tokens. Best practices: implementar refresh tokens para evitar 498s por expiración, usar blacklist con TTL igual a exp del token, loguear razón específica del 498, implementar rate limiting para IPs con muchos 498s, alertar sobre picos de invalid_signature. No hay equivalente estándar HTTP - usar 401 con WWW-Authenticate en implementaciones estándar.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786789/498_jnb2mv.png",
                "alt": "Imagen que representa el nombre del código 498 Invalid Token"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786445/61-removebg-preview_t3zdfh.png",
                "alt": "Imagen del código 498 Invalid Token"
            }
        ]
    },
    {
        "code": 499,
        "status": "Client Closed Request",
        "category": "Client Error (Non-standard)",
        "description": "El código 499 Client Closed Request es un código de estado HTTP NO estándar específico de nginx que indica que el cliente cerró la conexión antes de que el servidor pudiera enviar una respuesta. Este código NO aparece en ninguna especificación oficial de HTTP (RFC) y es completamente específico de nginx. El servidor está diciendo (o más bien, registrando en logs): 'Estaba procesando la solicitud pero el cliente cerró la conexión antes de que pudiera enviar la respuesta'. Es importante entender que el código 499 NO se envía realmente al cliente como respuesta HTTP - el cliente ya cerró la conexión, por lo que no puede recibir ninguna respuesta. En su lugar, 499 es un código interno que nginx registra en sus logs de acceso para indicar esta situación específica. Este código es extremadamente útil para diagnóstico, monitoreo y análisis de comportamiento de clientes. Las razones por las que un cliente cierra la conexión prematuramente incluyen: timeout del cliente (el usuario se cansó de esperar y canceló la solicitud o cerró el navegador), el procesamiento del servidor toma demasiado tiempo, usuario navegó a otra página antes de que cargara la actual, usuario cerró el navegador o pestaña, aplicación cliente canceló la solicitud (por timeout configurado o lógica de cancelación), pérdida de conexión de red, o el usuario presionó el botón 'detener' del navegador. El código 499 es especialmente común en: solicitudes de larga duración (uploads grandes, procesamiento pesado), conexiones lentas o inestables, usuarios impacientes que navegan rápidamente, aplicaciones con timeouts agresivos, o situaciones donde el servidor backend tarda mucho en responder. Monitorear la frecuencia de códigos 499 puede ayudar a identificar problemas de rendimiento del servidor o timeouts de cliente mal configurados.",
        "useCases": [
            "nginx: Cliente cerró conexión antes de recibir respuesta",
            "Usuario canceló solicitud (cerró navegador, navegó a otra página)",
            "Timeout del cliente mientras servidor procesaba solicitud",
            "Aplicación cliente canceló request programáticamente",
            "Pérdida de conexión de red durante procesamiento",
            "Upload cancelado por usuario a mitad de camino",
            "NOTA: Específico de nginx, NO es estándar HTTP, NO se envía al cliente"
        ],
        "examples": [
            {
                "scenario": "Usuario impaciente cancela solicitud de carga lenta",
                "request": "GET /heavy-report?date_range=2023-01-01to2023-12-31 HTTP/1.1\nHost: analytics.example.com\nUser-Agent: Mozilla/5.0...\n\n[Servidor comienza a generar reporte complejo que toma 45 segundos]\n[Después de 10 segundos, usuario cierra la pestaña del navegador]",
                "response": "[NO HAY RESPUESTA - el cliente ya cerró la conexión]\n\nLo que sucede:\n\n1. Cliente envía solicitud a las 14:00:00\n2. nginx reenvía a backend que comienza procesamiento pesado\n3. A las 14:00:10, usuario cierra navegador (cansado de esperar)\n4. nginx detecta que la conexión del cliente se cerró\n5. nginx registra en access.log:\n\n203.0.113.42 - - [17/Jan/2024:14:00:10 +0000] \"GET /heavy-report?date_range=2023-01-01to2023-12-31 HTTP/1.1\" 499 0 \"-\" \"Mozilla/5.0...\"\n\nCódigo 499 en logs indica: cliente cerró conexión antes de recibir respuesta\n\nEl backend puede continuar procesando (dependiendo de configuración):\n- Si no hay proxy_ignore_client_abort, nginx cancela request al backend\n- Si proxy_ignore_client_abort on, backend continúa aunque cliente se fue\n\nConfiguración nginx:\n\nserver {\n    listen 80;\n    server_name analytics.example.com;\n    \n    location /heavy-report {\n        # Por defecto: cancelar backend si cliente cierra conexión\n        # proxy_ignore_client_abort off;  # default\n        \n        # Alternativamente: continuar procesamiento aunque cliente se vaya\n        # proxy_ignore_client_abort on;\n        \n        proxy_pass http://backend;\n        proxy_read_timeout 60s;\n    }\n}\n\nIndicadores de 499 en monitoreo:\nAlta tasa de 499 puede indicar:\n- Servidor muy lento (usuarios se cansan de esperar)\n- Timeouts de cliente demasiado cortos\n- Problemas de rendimiento en backend\n- UI no muestra indicadores de carga (usuarios creen que nada pasa)",
                "explanation": "El caso más común de 499: un usuario solicita un recurso que tarda mucho en generarse. Después de esperar 10 segundos sin ver resultados, cierra el navegador frustrado. nginx registra 499 en logs porque el cliente cerró la conexión mientras aún se procesaba. No hay respuesta HTTP porque el cliente ya no está allí para recibirla."
            },
            {
                "scenario": "Upload grande cancelado a mitad de camino",
                "request": "POST /api/upload HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data\nContent-Length: 524288000\nAuthorization: Bearer user_token\n\n[Cliente comienza a subir archivo de 500MB]\n[Después de subir 200MB, usuario cancela o pierde conexión]",
                "response": "[NO HAY RESPUESTA - conexión cerrada por cliente]\n\nProceso:\n\n1. Cliente inicia upload de 500MB\n2. nginx comienza a recibir datos (200MB/500MB completados)\n3. Cliente cancela el upload o pierde conexión WiFi\n4. nginx detecta EOF (end of file) prematuro\n5. nginx registra código 499 en access.log:\n\n198.51.100.45 - user123 [17/Jan/2024:15:30:45 +0000] \"POST /api/upload HTTP/1.1\" 499 209715200 \"-\" \"UploadApp/2.0\"\n                                                                                      ^^^ 499\n                                                                                          ^^^^^^^^^ bytes recibidos antes de desconexión\n\nConfiguración nginx para uploads:\n\nserver {\n    listen 443 ssl;\n    server_name storage.example.com;\n    \n    # Permitir uploads grandes\n    client_max_body_size 1G;\n    client_body_timeout 300s;\n    \n    location /api/upload {\n        # Configurar timeouts apropiados\n        proxy_request_buffering off;  # Stream directamente al backend\n        proxy_read_timeout 300s;\n        proxy_send_timeout 300s;\n        \n        # Si cliente se desconecta durante upload\n        # nginx cancelará el request al backend (default)\n        # proxy_ignore_client_abort off;\n        \n        proxy_pass http://upload_backend;\n    }\n}\n\nImplicaciones:\n- Backend puede haber guardado archivo parcial (200MB de 500MB)\n- Aplicación debe limpiar uploads incompletos\n- Cliente debe poder resumir upload (si se implementó)\n- Alta tasa de 499 en uploads puede indicar timeouts muy cortos o conexiones inestables",
                "explanation": "Durante un upload de archivo grande, el cliente pierde conexión o cancela después de subir 200MB de 500MB. nginx registra 499 indicando que el cliente cerró la conexión antes de completar. Esto es común con archivos grandes en conexiones inestables o cuando usuarios cancelan uploads lentos."
            },
            {
                "scenario": "Aplicación con timeout agresivo",
                "request": "GET /api/search?q=complex+query HTTP/1.1\nHost: api.example.com\nX-Request-Timeout: 5000\n\n[Aplicación JavaScript configurada con timeout de 5 segundos]\n[Búsqueda compleja toma 7 segundos en el servidor]",
                "response": "[NO HAY RESPUESTA - cliente canceló por timeout]\n\nCódigo JavaScript del cliente:\n\nconst controller = new AbortController();\nconst timeoutId = setTimeout(() => controller.abort(), 5000); // 5 segundos\n\ntry {\n  const response = await fetch('https://api.example.com/api/search?q=complex+query', {\n    signal: controller.signal\n  });\n  clearTimeout(timeoutId);\n  const data = await response.json();\n  console.log(data);\n} catch (error) {\n  if (error.name === 'AbortError') {\n    console.log('Request timed out after 5 seconds');\n    // Cliente cerró conexión → nginx registrará 499\n  }\n}\n\nTimeline:\n- 00:00 - Cliente envía solicitud\n- 00:05 - Timeout del cliente (5s), aborta fetch → cierra conexión TCP\n- 00:07 - Servidor termina procesamiento (pero cliente ya se fue)\n\nnginx access.log:\n192.0.2.100 - - [17/Jan/2024:16:15:05 +0000] \"GET /api/search?q=complex+query HTTP/1.1\" 499 0 \"https://app.example.com\" \"Mozilla/5.0...\"\n\nProblema:\n- Cliente timeout: 5 segundos\n- Servidor toma: 7 segundos\n- Mismatch causa 499s frecuentes\n\nSoluciones:\n1. Optimizar búsqueda para completar en <5s\n2. Aumentar timeout del cliente a 10s\n3. Implementar búsqueda asíncrona con polling:\n   - POST /api/search → devuelve search_id inmediatamente\n   - GET /api/search/status/{search_id} → polling hasta completado\n4. Implementar paginación o búsqueda incremental\n\nConfiguración nginx:\n\nserver {\n    listen 443 ssl;\n    server_name api.example.com;\n    \n    location /api/search {\n        proxy_pass http://search_backend;\n        proxy_read_timeout 10s;  # Timeout del proxy\n        \n        # Si excede 10s, nginx devuelve 504 Gateway Timeout\n        # Si cliente cancela antes, nginx registra 499\n    }\n}",
                "explanation": "Una aplicación JavaScript tiene un timeout de 5 segundos para todas las solicitudes. Una búsqueda compleja toma 7 segundos en el servidor. El cliente cancela la solicitud después de 5 segundos (AbortController), cerrando la conexión. nginx registra 499 porque el cliente se desconectó antes de que el servidor pudiera enviar la respuesta completa."
            },
            {
                "scenario": "Análisis de logs - Identificando problemas de rendimiento",
                "request": "Análisis de nginx access.log con alta frecuencia de 499",
                "response": "Ejemplo de logs nginx con códigos 499:\n\n# access.log\n203.0.113.10 - - [17/Jan/2024:20:00:15 +0000] \"GET /api/data HTTP/1.1\" 200 1234 \"-\" \"App/1.0\"\n203.0.113.11 - - [17/Jan/2024:20:00:16 +0000] \"GET /api/report HTTP/1.1\" 499 0 \"-\" \"Browser/1.0\"\n203.0.113.12 - - [17/Jan/2024:20:00:18 +0000] \"POST /api/process HTTP/1.1\" 499 0 \"-\" \"App/1.0\"\n203.0.113.13 - - [17/Jan/2024:20:00:20 +0000] \"GET /api/data HTTP/1.1\" 200 5678 \"-\" \"App/1.0\"\n203.0.113.14 - - [17/Jan/2024:20:00:22 +0000] \"GET /slow-endpoint HTTP/1.1\" 499 0 \"-\" \"Browser/1.0\"\n203.0.113.15 - - [17/Jan/2024:20:00:25 +0000] \"GET /slow-endpoint HTTP/1.1\" 499 0 \"-\" \"Browser/1.0\"\n\nAnálisis con comandos:\n\n# Contar códigos de estado\n$ awk '{print $9}' access.log | sort | uniq -c | sort -rn\n   1523 200\n    342 499  ← Alta cantidad de 499s\n     89 404\n     45 500\n     12 502\n\n# Endpoints con más 499s\n$ awk '$9 == 499 {print $7}' access.log | sort | uniq -c | sort -rn\n    156 /slow-endpoint\n     89 /api/report\n     54 /api/process\n     43 /api/upload\n\n# Tiempos de respuesta promedio por endpoint (si logeas $request_time)\n$ awk '$9 == 499 {sum[$7]+=$10; count[$7]++} END {for (url in sum) print url, sum[url]/count[url]}' access.log\n/slow-endpoint 45.2     ← Promedio 45 segundos antes de cancelación\n/api/report 12.5\n/api/process 8.3\n\nInterpretación:\n- /slow-endpoint tiene 156 códigos 499 con tiempo promedio de 45s antes de cancelación\n- Usuarios están esperando 45 segundos y luego cancelando frustrados\n- Indica problema grave de rendimiento en ese endpoint\n\nAcciones correctivas:\n1. Investigar por qué /slow-endpoint tarda tanto\n2. Optimizar queries de base de datos\n3. Implementar caching\n4. Considerar procesamiento asíncrono\n5. Añadir indicadores de progreso en UI\n6. Revisar timeouts de cliente vs tiempos reales de procesamiento\n\nConfiguracion nginx para logging mejorado:\n\nhttp {\n    log_format detailed '$remote_addr - $remote_user [$time_local] '\n                       '\"$request\" $status $body_bytes_sent '\n                       '\"$http_referer\" \"$http_user_agent\" '\n                       'rt=$request_time uct=\"$upstream_connect_time\" '\n                       'uht=\"$upstream_header_time\" urt=\"$upstream_response_time\"';\n    \n    access_log /var/log/nginx/access.log detailed;\n}\n\n# Esto registra tiempos detallados:\n# rt = request_time (tiempo total)\n# uct = upstream_connect_time (tiempo conectar a backend)\n# uht = upstream_header_time (tiempo recibir headers del backend)\n# urt = upstream_response_time (tiempo respuesta completa del backend)\n\n# Con estos datos puedes determinar:\n# - Si 499s ocurren porque backend es lento\n# - Si hay problemas de red con backend\n# - Cuánto tiempo esperan usuarios antes de cancelar",
                "explanation": "Monitorear códigos 499 en logs nginx es crucial para identificar problemas de rendimiento. Alta frecuencia de 499s en endpoints específicos indica que los usuarios están cancelando solicitudes porque tardan demasiado. Analizar los logs permite identificar qué endpoints necesitan optimización urgente."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP)",
        "specification": "nginx específico - No hay RFC oficial",
        "relatedHeaders": [],
        "relatedCodes": [
            408,
            504
        ],
        "technicalNotes": "499 es ESPECÍFICO DE NGINX y NO es estándar HTTP oficial. IMPORTANTE: 499 NO se envía al cliente como respuesta - solo aparece en logs de nginx. El cliente ya cerró la conexión y no puede recibir ninguna respuesta. Causas comunes: timeout del cliente, usuario canceló (cerró navegador/tab), navegación a otra página, pérdida de conexión de red, aplicación cliente abortó request (fetch abort, XMLHttpRequest.abort()). Configuración relevante: proxy_ignore_client_abort (off=default, cancela backend; on=continúa procesando), client_body_timeout, proxy_read_timeout. Diferencias: 408 Request Timeout = servidor cierra por timeout; 499 = cliente cierra antes de respuesta; 504 Gateway Timeout = backend tarda demasiado. Monitoreo: alta tasa de 499s indica: servidor muy lento, timeouts de cliente muy cortos, problemas de rendimiento, conexiones inestables. Útil para: diagnóstico de rendimiento, identificar endpoints problemáticos, ajustar timeouts, medir paciencia de usuarios. No hay equivalente estándar HTTP porque el cliente ya se fue antes de recibir cualquier código.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786792/499_atct5z.png",
                "alt": "Imagen que representa el nombre del código 499 Client Closed Request"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786442/62-removebg-preview_payakt.png",
                "alt": "Imagen del código 499 Client Closed Request"
            }
        ]
    },
    {
        "code": 500,
        "status": "Internal Server Error",
        "category": "Server Error",
        "description": "El código 500 Internal Server Error es un código de estado HTTP estándar que indica que el servidor encontró una condición inesperada que le impidió completar la solicitud. Este es el código de error genérico del servidor cuando no hay un código más específico disponible. El servidor está diciendo: 'Algo salió mal de mi lado, pero no puedo ser más específico sobre qué fue'. Es importante entender que el 500 es un error INTERNO del servidor - el problema está en el lado del servidor, no en la solicitud del cliente. A diferencia de los errores 4xx que indican problemas con la solicitud del cliente, el 500 significa que la solicitud era válida pero el servidor falló al procesarla debido a un error interno. Las causas más comunes incluyen: excepciones no capturadas en el código de la aplicación, errores de configuración del servidor, problemas con bases de datos (conexión fallida, queries mal formados), recursos del servidor agotados (memoria, CPU, conexiones), errores en dependencias o servicios externos, permisos de archivos incorrectos, o errores de sintaxis en código del servidor. El código 500 es crítico porque indica que hay un problema serio en el servidor que debe ser investigado y corregido inmediatamente. A diferencia de errores esperados como 404 o 400, un 500 representa un fallo inesperado del sistema. Los desarrolladores deben monitorear cuidadosamente los errores 500, ya que afectan directamente la experiencia del usuario y pueden indicar problemas graves de estabilidad o seguridad.",
        "useCases": [
            "Excepción no capturada en código de aplicación",
            "Error en query de base de datos o conexión fallida",
            "Configuración incorrecta del servidor (web.config, .htaccess)",
            "Recursos del servidor agotados (memoria, CPU, conexiones)",
            "Error en dependencias externas (APIs, librerías)",
            "Permisos de archivos incorrectos",
            "Timeout interno al procesar solicitud",
            "Error en template engine o rendering"
        ],
        "examples": [
            {
                "scenario": "Excepción no capturada en código de aplicación",
                "request": "POST /api/orders HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token_123\n\n{\n  \"product_id\": 789,\n  \"quantity\": 2,\n  \"price\": null\n}",
                "response": "HTTP/1.1 500 Internal Server Error\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: Apache/2.4.41\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"error\": \"Internal Server Error\",\n  \"message\": \"An unexpected error occurred while processing your request\",\n  \"request_id\": \"req_abc123xyz\",\n  \"timestamp\": \"2024-01-17T14:30:00Z\"\n}\n\nCódigo del servidor que causó el error (Node.js/Express):\n\napp.post('/api/orders', async (req, res) => {\n  try {\n    const { product_id, quantity, price } = req.body;\n    \n    // ERROR: price es null, pero el código asume que es un número\n    const total = price * quantity;  // null * 2 = NaN\n    const tax = total * 0.16;        // NaN * 0.16 = NaN\n    \n    // Intentar guardar en base de datos con valores NaN\n    const order = await db.orders.create({\n      product_id,\n      quantity,\n      total,      // NaN → Error en base de datos\n      tax         // NaN → Error en base de datos\n    });\n    \n    res.status(201).json(order);\n  } catch (error) {\n    // Excepción no capturada apropiadamente\n    console.error('Order creation failed:', error);\n    \n    // Devuelve 500 genérico sin exponer detalles internos\n    res.status(500).json({\n      error: 'Internal Server Error',\n      message: 'An unexpected error occurred while processing your request',\n      request_id: generateRequestId(),\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\nLog interno del servidor:\n\n[2024-01-17 14:30:00] ERROR: Order creation failed\nError: Invalid numeric value for column 'total'\n  at Database.create (database.js:145)\n  at async /app/routes/orders.js:12:20\nStack trace:\n  Database.create (database.js:145:15)\n  processOrder (orders.js:12:20)\n  ...\n\nRequest ID: req_abc123xyz\nUser: user_456\nPayload: {\"product_id\":789,\"quantity\":2,\"price\":null}\n\nSOLUCIÓN - Código corregido con validación:\n\napp.post('/api/orders', async (req, res) => {\n  try {\n    const { product_id, quantity, price } = req.body;\n    \n    // VALIDACIÓN: Verificar que price sea un número válido\n    if (typeof price !== 'number' || isNaN(price) || price <= 0) {\n      return res.status(400).json({\n        error: 'Bad Request',\n        message: 'Price must be a valid positive number',\n        field: 'price',\n        provided_value: price\n      });\n    }\n    \n    // Ahora es seguro hacer cálculos\n    const total = price * quantity;\n    const tax = total * 0.16;\n    \n    const order = await db.orders.create({\n      product_id,\n      quantity,\n      total,\n      tax\n    });\n    \n    res.status(201).json(order);\n  } catch (error) {\n    console.error('Order creation failed:', error);\n    \n    // Loguear error completo para debugging\n    logger.error({\n      message: 'Order creation failed',\n      error: error.message,\n      stack: error.stack,\n      user: req.user?.id,\n      request_id: req.id,\n      payload: req.body\n    });\n    \n    res.status(500).json({\n      error: 'Internal Server Error',\n      message: 'An unexpected error occurred',\n      request_id: req.id\n    });\n  }\n});",
                "explanation": "Este es el caso más común de 500: una excepción no capturada en el código. El cliente envía price: null, pero el código asume que siempre será un número válido. Al intentar hacer cálculos con null, se generan valores NaN que causan un error al guardar en la base de datos. El servidor captura la excepción y devuelve 500 genérico al cliente, mientras loguea los detalles completos internamente para debugging. La solución es agregar validación apropiada y devolver 400 Bad Request cuando los datos sean inválidos."
            },
            {
                "scenario": "Error de conexión a base de datos",
                "request": "GET /api/products?category=electronics HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nAccept: application/json",
                "response": "HTTP/1.1 500 Internal Server Error\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nContent-Length: 142\nRetry-After: 30\n\n{\n  \"error\": \"Internal Server Error\",\n  \"message\": \"Service temporarily unavailable\",\n  \"request_id\": \"req_def456\",\n  \"timestamp\": \"2024-01-17T15:45:00Z\"\n}\n\nCódigo del servidor que causó el error (Python/Flask):\n\n@app.route('/api/products')\ndef get_products():\n    try:\n        category = request.args.get('category')\n        \n        # Intentar conectar a base de datos\n        connection = mysql.connector.connect(\n            host='db.example.com',\n            user='api_user',\n            password='secret',\n            database='shop'\n        )\n        \n        cursor = connection.cursor()\n        query = \"SELECT * FROM products WHERE category = %s\"\n        cursor.execute(query, (category,))\n        products = cursor.fetchall()\n        \n        cursor.close()\n        connection.close()\n        \n        return jsonify(products), 200\n        \n    except mysql.connector.Error as db_error:\n        # ERROR: Base de datos no disponible\n        app.logger.error(f'Database connection failed: {db_error}')\n        app.logger.error(f'Error code: {db_error.errno}')\n        app.logger.error(f'SQL state: {db_error.sqlstate}')\n        \n        return jsonify({\n            'error': 'Internal Server Error',\n            'message': 'Service temporarily unavailable',\n            'request_id': generate_request_id(),\n            'timestamp': datetime.utcnow().isoformat()\n        }), 500, {'Retry-After': '30'}\n    \n    except Exception as error:\n        app.logger.error(f'Unexpected error: {error}')\n        return jsonify({\n            'error': 'Internal Server Error',\n            'message': 'An unexpected error occurred'\n        }), 500\n\nLog interno del servidor:\n\n[2024-01-17 15:45:00] ERROR: Database connection failed\nException: Can't connect to MySQL server on 'db.example.com' (111)\nError code: 2003\nSQL state: HY000\nReason: Connection refused (database server down or firewall blocking)\n\nRequest ID: req_def456\nEndpoint: GET /api/products?category=electronics\nUser: user_789\n\nCausas posibles:\n- Servidor de base de datos caído\n- Máximo de conexiones alcanzado\n- Firewall bloqueando conexión\n- Credenciales incorrectas\n- Network partition entre app y DB\n\nSOLUCIÓN - Implementar connection pooling y circuit breaker:\n\nfrom mysql.connector import pooling\nimport circuitbreaker\n\n# Connection pool para reusar conexiones\nconnection_pool = pooling.MySQLConnectionPool(\n    pool_name=\"api_pool\",\n    pool_size=10,\n    pool_reset_session=True,\n    host='db.example.com',\n    user='api_user',\n    password='secret',\n    database='shop'\n)\n\n# Circuit breaker para fallar rápido si DB está caída\n@circuitbreaker.circuit(\n    failure_threshold=5,\n    recovery_timeout=60,\n    expected_exception=mysql.connector.Error\n)\ndef get_db_connection():\n    return connection_pool.get_connection()\n\n@app.route('/api/products')\ndef get_products():\n    try:\n        category = request.args.get('category')\n        \n        # Obtener conexión del pool\n        connection = get_db_connection()\n        \n        with connection.cursor() as cursor:\n            query = \"SELECT * FROM products WHERE category = %s\"\n            cursor.execute(query, (category,))\n            products = cursor.fetchall()\n        \n        connection.close()  # Devolver al pool\n        return jsonify(products), 200\n        \n    except circuitbreaker.CircuitBreakerError:\n        # Circuit breaker abierto - fallar rápido\n        app.logger.warning('Circuit breaker open - database unavailable')\n        return jsonify({\n            'error': 'Service Unavailable',\n            'message': 'Database temporarily unavailable, please try again later'\n        }), 503, {'Retry-After': '60'}\n    \n    except mysql.connector.Error as db_error:\n        app.logger.error(f'Database error: {db_error}')\n        return jsonify({\n            'error': 'Internal Server Error',\n            'message': 'Service temporarily unavailable'\n        }), 500, {'Retry-After': '30'}\n\nMonitoreo y alertas:\n\n# Prometheus metrics\ndb_errors_total = Counter('db_errors_total', 'Total database errors')\ndb_connection_duration = Histogram('db_connection_duration_seconds', 'DB connection time')\n\n# Alert en Prometheus/Grafana\nalert: DatabaseErrors\n  expr: rate(db_errors_total[5m]) > 0.1\n  for: 5m\n  annotations:\n    summary: \"High rate of database errors\"\n    description: \"Database error rate is {{ $value }} per second\"",
                "explanation": "Un error crítico de infraestructura: la base de datos no está disponible. Esto podría ser porque el servidor MySQL está caído, el pool de conexiones está agotado, o hay un problema de red. El servidor devuelve 500 porque no puede completar la solicitud, e incluye un header Retry-After sugiriendo al cliente que reintente en 30 segundos. La solución incluye connection pooling para reutilizar conexiones eficientemente y un circuit breaker para fallar rápido cuando la base de datos está caída, devolviendo 503 Service Unavailable en lugar de intentar conectar repetidamente."
            },
            {
                "scenario": "Recursos del servidor agotados - Out of Memory",
                "request": "GET /api/reports/annual?year=2023&format=detailed HTTP/1.1\nHost: analytics.example.com\nAuthorization: Bearer token_123\nAccept: application/json",
                "response": "HTTP/1.1 500 Internal Server Error\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: Apache/2.4.41\nContent-Type: text/html\nContent-Length: 612\n\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>500 Internal Server Error</title>\n</head><body>\n<h1>Internal Server Error</h1>\n<p>The server encountered an internal error or\nmisconfiguration and was unable to complete\nyour request.</p>\n<p>Please contact the server administrator at\n webmaster@analytics.example.com to inform them of the time this error occurred,\n and the actions you performed just before this error.</p>\n</body></html>\n\nCódigo del servidor que causó el error (Java/Spring Boot):\n\n@GetMapping(\"/api/reports/annual\")\npublic ResponseEntity<AnnualReport> getAnnualReport(\n    @RequestParam int year,\n    @RequestParam String format) {\n    \n    try {\n        // PROBLEMA: Cargar TODOS los registros en memoria\n        // Si hay millones de registros → OutOfMemoryError\n        List<Transaction> transactions = transactionRepository\n            .findByYear(year);  // SELECT * FROM transactions WHERE year = 2023\n                                // Retorna 10 millones de registros → ~2GB en memoria\n        \n        // Procesar todos los datos en memoria\n        List<ReportEntry> reportData = new ArrayList<>();\n        for (Transaction tx : transactions) {\n            ReportEntry entry = new ReportEntry(\n                tx.getId(),\n                tx.getDate(),\n                tx.getAmount(),\n                tx.getCategory(),\n                tx.getDescription()  // Campo de texto largo\n            );\n            reportData.add(entry);  // Memoria se agota aquí\n        }\n        \n        AnnualReport report = generateReport(reportData);\n        return ResponseEntity.ok(report);\n        \n    } catch (OutOfMemoryError oom) {\n        logger.error(\"OutOfMemoryError generating annual report\", oom);\n        logger.error(\"Heap size: {}MB\", \n            Runtime.getRuntime().totalMemory() / (1024 * 1024));\n        logger.error(\"Free memory: {}MB\", \n            Runtime.getRuntime().freeMemory() / (1024 * 1024));\n        \n        // Servidor devuelve 500 genérico\n        return ResponseEntity.status(500).build();\n        \n    } catch (Exception e) {\n        logger.error(\"Error generating report\", e);\n        return ResponseEntity.status(500).build();\n    }\n}\n\nLog interno del servidor:\n\n[2024-01-17 16:30:00] ERROR: OutOfMemoryError generating annual report\njava.lang.OutOfMemoryError: Java heap space\n  at java.util.ArrayList.add(ArrayList.java:459)\n  at com.example.ReportController.getAnnualReport(ReportController.java:45)\n  ...\n\nHeap size: 4096MB\nFree memory: 12MB\nTransactions loaded: 8,450,000\nEstimated memory usage: ~3.8GB\n\nJVM will attempt garbage collection but likely crash or become unresponsive\n\nSOLUCIÓN - Procesamiento en streaming con paginación:\n\n@GetMapping(\"/api/reports/annual\")\npublic ResponseEntity<StreamingResponseBody> getAnnualReport(\n    @RequestParam int year,\n    @RequestParam String format) {\n    \n    StreamingResponseBody stream = outputStream -> {\n        try (Writer writer = new OutputStreamWriter(outputStream)) {\n            // Iniciar JSON/CSV\n            writer.write(\"{\\\"year\\\":\" + year + \",\\\"data\\\":[\");\n            \n            int pageSize = 1000;\n            int page = 0;\n            boolean hasMore = true;\n            boolean first = true;\n            \n            // STREAMING: Procesar en lotes pequeños\n            while (hasMore) {\n                // Obtener solo 1000 registros a la vez\n                Page<Transaction> transactionPage = transactionRepository\n                    .findByYear(year, PageRequest.of(page, pageSize));\n                \n                List<Transaction> transactions = transactionPage.getContent();\n                \n                // Procesar este lote\n                for (Transaction tx : transactions) {\n                    if (!first) writer.write(\",\");\n                    first = false;\n                    \n                    // Escribir directamente al stream (sin acumular en memoria)\n                    String entry = String.format(\n                        \"{\\\"id\\\":%d,\\\"date\\\":\\\"%s\\\",\\\"amount\\\":%.2f}\",\n                        tx.getId(), tx.getDate(), tx.getAmount()\n                    );\n                    writer.write(entry);\n                    writer.flush();\n                }\n                \n                hasMore = transactionPage.hasNext();\n                page++;\n                \n                // Limpiar memoria después de cada lote\n                transactions.clear();\n                System.gc();  // Sugerir garbage collection\n            }\n            \n            writer.write(\"]}\");\n            writer.flush();\n        }\n    };\n    \n    return ResponseEntity.ok()\n        .header(\"Content-Type\", \"application/json\")\n        .header(\"Content-Disposition\", \"attachment; filename=report-\" + year + \".json\")\n        .body(stream);\n}\n\nConfiguración JVM optimizada:\n\n# Aumentar heap si es necesario\njava -Xms2g -Xmx8g \\\n     -XX:+UseG1GC \\\n     -XX:MaxGCPauseMillis=200 \\\n     -XX:+HeapDumpOnOutOfMemoryError \\\n     -XX:HeapDumpPath=/var/log/heapdump.hprof \\\n     -jar app.jar\n\nMonitoreo:\n\n# Prometheus metrics para memoria JVM\njvm_memory_used_bytes{area=\"heap\"}\njvm_memory_max_bytes{area=\"heap\"}\n\n# Alert si memoria > 90%\nalert: HighMemoryUsage\n  expr: (jvm_memory_used_bytes{area=\"heap\"} / jvm_memory_max_bytes{area=\"heap\"}) > 0.9\n  for: 5m",
                "explanation": "Un caso crítico de 500: el servidor se queda sin memoria al intentar cargar millones de registros simultáneamente. El código intenta obtener todos los registros del año 2023 de una vez (10 millones de registros = ~2GB+), causando OutOfMemoryError. El servidor devuelve 500 y puede volverse inestable o crashear completamente. La solución es implementar streaming con paginación: procesar los datos en lotes pequeños (1000 registros a la vez) y escribir directamente al output stream sin acumular todo en memoria. También se debe configurar apropiadamente el heap de la JVM y monitorear el uso de memoria."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.1",
        "relatedHeaders": [
            "Retry-After",
            "Content-Type"
        ],
        "relatedCodes": [
            502,
            503,
            504
        ],
        "technicalNotes": "El código 500 es el error genérico del servidor cuando no hay un código más específico disponible. Diferencias importantes: 500 Internal Server Error = error genérico del servidor, problema no específico; 502 Bad Gateway = gateway/proxy recibió respuesta inválida del upstream; 503 Service Unavailable = servidor temporalmente sobrecargado o en mantenimiento; 504 Gateway Timeout = gateway/proxy no recibió respuesta a tiempo del upstream. CRÍTICO: Nunca exponer detalles técnicos del error (stack traces, rutas de archivos, nombres de base de datos) al cliente en producción - esto es un riesgo de seguridad. Los detalles completos deben loguearse internamente para debugging. Best practices: (1) Loguear errores completos con stack trace, request ID, user ID, timestamp; (2) Devolver respuesta genérica al cliente con request_id para rastrear; (3) Implementar monitoreo y alertas para 500s (Sentry, New Relic, Datadog); (4) Usar códigos más específicos cuando sea posible (502, 503, 504); (5) Incluir Retry-After header si el error es temporal; (6) Implementar circuit breakers para dependencias externas; (7) Configurar límites de recursos (memory, CPU, connections); (8) Implementar health checks y graceful degradation. Causas comunes específicas: NullPointerException, ArrayIndexOutOfBoundsException, SQLException, OutOfMemoryError, StackOverflowError, configuración incorrecta (web.config, php.ini), permisos de archivos, dependencias faltantes. Monitoreo: trackear tasa de 500s, tiempo de respuesta antes del error, endpoints más afectados, correlación con deploys o cambios. Un spike de 500s generalmente indica un bug recién introducido o problema de infraestructura crítico.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768786794/500_mn2od4.png",
                "alt": "Imagen que representa el nombre del código 500 Internal Server Error"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768786441/63-removebg-preview_z3fbqm.png",
                "alt": "Imagen del código 500 Internal Server Error"
            }
        ]
    },
    {
        "code": 501,
        "status": "Not Implemented",
        "category": "Server Error",
        "description": "El código 501 Not Implemented es un código de estado HTTP estándar que indica que el servidor no soporta la funcionalidad requerida para completar la solicitud. El servidor está diciendo: 'Entiendo tu solicitud, pero no tengo implementada la capacidad para manejarla'. A diferencia del 405 Method Not Allowed (que indica que el método HTTP no está permitido para ese recurso específico), el 501 significa que el servidor NO reconoce o NO ha implementado el método HTTP en absoluto, o no puede cumplir con la funcionalidad solicitada. Es importante entender que 501 se usa cuando el servidor carece completamente de la capacidad para procesar la solicitud - no es un error temporal como 503, ni un problema de permisos como 403. Las causas más comunes incluyen: método HTTP no reconocido o no implementado por el servidor (por ejemplo, PATCH, PROPFIND), funcionalidad HTTP/2 o HTTP/3 solicitada en servidor que solo soporta HTTP/1.1, características HTTP avanzadas no soportadas (Transfer-Encoding no reconocido, Expect: 100-continue no implementado), o proxies/gateways que no pueden manejar ciertos tipos de solicitudes. El código 501 indica que esta es una limitación permanente del servidor - no se espera que el servidor implemente esta funcionalidad en el futuro cercano. Los clientes que reciben 501 deben evitar reintentar la misma solicitud, ya que el resultado será el mismo. Este código es relativamente raro en servidores web modernos, ya que la mayoría implementan todos los métodos HTTP estándar, pero puede aparecer en servidores especializados, proxies antiguos, o APIs que deliberadamente limitan los métodos soportados.",
        "useCases": [
            "Método HTTP no reconocido por el servidor (ej: PATCH en servidor antiguo)",
            "Servidor solo soporta GET/POST, recibe PUT/DELETE/OPTIONS",
            "Proxy no puede manejar cierto tipo de solicitud",
            "Transfer-Encoding no soportado (ej: compress, deflate)",
            "HTTP/2 solicitado en servidor que solo soporta HTTP/1.1",
            "Funcionalidad HTTP avanzada no implementada",
            "WebDAV methods (PROPFIND, MKCOL) en servidor sin WebDAV"
        ],
        "examples": [
            {
                "scenario": "Método HTTP PATCH no implementado en servidor antiguo",
                "request": "PATCH /api/users/123 HTTP/1.1\nHost: legacy.example.com\nContent-Type: application/json\nAuthorization: Bearer token_abc\n\n{\n  \"email\": \"newemail@example.com\"\n}",
                "response": "HTTP/1.1 501 Not Implemented\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: Apache/2.2.15\nAllow: GET, POST, DELETE\nContent-Type: application/json\nContent-Length: 178\n\n{\n  \"error\": \"Not Implemented\",\n  \"message\": \"The PATCH method is not implemented on this server\",\n  \"supported_methods\": [\"GET\", \"POST\", \"DELETE\"],\n  \"suggestion\": \"Use PUT to replace the entire resource or POST for updates\"\n}\n\nConfiguración del servidor (Apache antiguo):\n\n# httpd.conf - Apache 2.2 (2005-2013)\n<VirtualHost *:80>\n    ServerName legacy.example.com\n    DocumentRoot /var/www/legacy\n    \n    # Apache 2.2 NO tiene soporte nativo para PATCH\n    # Solo reconoce: GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, CONNECT\n    \n    <Directory /var/www/legacy>\n        # Si se recibe método no implementado → 501\n        <LimitExcept GET POST DELETE>\n            # Devolver 501 para métodos no soportados\n        </LimitExcept>\n    </Directory>\n</VirtualHost>\n\nCódigo de la aplicación (PHP legacy):\n\n<?php\n// legacy-api.php\n\n$method = $_SERVER['REQUEST_METHOD'];\n\n// Lista de métodos soportados por la aplicación\n$supported_methods = ['GET', 'POST', 'DELETE'];\n\nif (!in_array($method, $supported_methods)) {\n    // Método no implementado\n    header('HTTP/1.1 501 Not Implemented');\n    header('Allow: ' . implode(', ', $supported_methods));\n    header('Content-Type: application/json');\n    \n    echo json_encode([\n        'error' => 'Not Implemented',\n        'message' => \"The {$method} method is not implemented on this server\",\n        'supported_methods' => $supported_methods,\n        'suggestion' => 'Use PUT to replace the entire resource or POST for updates'\n    ]);\n    exit;\n}\n\n// Procesar solicitud con método soportado\nswitch ($method) {\n    case 'GET':\n        handleGet();\n        break;\n    case 'POST':\n        handlePost();\n        break;\n    case 'DELETE':\n        handleDelete();\n        break;\n}\n?>\n\nContexto histórico:\n- PATCH fue definido en RFC 5789 (2010)\n- Apache 2.2 (lanzado en 2005) no tiene soporte nativo para PATCH\n- Muchos servidores legacy aún en producción no reconocen PATCH\n- Apache 2.4+ y nginx modernos sí soportan PATCH\n\nCliente debe adaptarse:\n\n// Cliente JavaScript detecta 501 y usa alternativa\nasync function updateUser(userId, updates) {\n    try {\n        // Intentar PATCH primero\n        const response = await fetch(`/api/users/${userId}`, {\n            method: 'PATCH',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(updates)\n        });\n        \n        if (response.status === 501) {\n            console.warn('PATCH not implemented, falling back to POST');\n            \n            // Fallback: usar POST con parámetro especial\n            return await fetch(`/api/users/${userId}?_method=PATCH`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updates)\n            });\n        }\n        \n        return response;\n    } catch (error) {\n        console.error('Update failed:', error);\n    }\n}\n\nSolución en servidor moderno:\n\n# nginx.conf - Soporte completo para PATCH\nserver {\n    listen 80;\n    server_name modern.example.com;\n    \n    location /api/ {\n        # nginx soporta todos los métodos HTTP estándar\n        # incluyendo PATCH, OPTIONS, etc.\n        \n        proxy_pass http://backend;\n        proxy_method $request_method;  # Preserva el método original\n    }\n}",
                "explanation": "Este es el caso más común de 501: un servidor antiguo (Apache 2.2) que no tiene implementado el método PATCH. El cliente intenta hacer una actualización parcial usando PATCH, pero el servidor no reconoce este método y devuelve 501. El servidor incluye el header Allow listando los métodos que SÍ soporta (GET, POST, DELETE) para que el cliente pueda adaptar su solicitud. La respuesta también incluye una sugerencia para usar PUT o POST como alternativa. El cliente moderno debe detectar el 501 y hacer fallback a un método soportado."
            },
            {
                "scenario": "Transfer-Encoding no soportado por proxy",
                "request": "POST /api/upload HTTP/1.1\nHost: api.example.com\nContent-Type: application/octet-stream\nTransfer-Encoding: compress\nAuthorization: Bearer token_xyz\n\n[Datos comprimidos con algoritmo compress (LZW)]",
                "response": "HTTP/1.1 501 Not Implemented\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: ProxyServer/1.0\nContent-Type: text/plain\nContent-Length: 156\n\n501 Not Implemented\n\nThe proxy server does not support the 'compress' transfer encoding.\nSupported encodings: chunked, gzip, identity\n\nPlease use a supported transfer encoding.\n\nConfiguración del proxy:\n\n# Proxy server que solo soporta ciertos Transfer-Encoding\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location / {\n        # Validar Transfer-Encoding antes de proxy\n        if ($http_transfer_encoding ~* \"^(compress|deflate|x-compress)$\") {\n            # Encodings antiguos/no soportados\n            return 501 \"The proxy does not support the '$http_transfer_encoding' transfer encoding.\\nSupported: chunked, gzip, identity\";\n        }\n        \n        proxy_pass http://backend;\n    }\n}\n\nExplicación técnica:\n\nTransfer-Encoding valores posibles:\n- chunked: Soportado universalmente (HTTP/1.1 estándar)\n- gzip: Ampliamente soportado\n- compress: OBSOLETO (algoritmo LZW, patentes, raramente implementado)\n- deflate: Soportado pero menos común\n- identity: Valor por defecto (sin encoding)\n\nEl problema:\n- Cliente usa 'compress' (algoritmo antiguo de Unix)\n- Proxy moderno NO tiene implementado decodificador para 'compress'\n- Proxy no puede procesar/reenviar la solicitud → 501\n\nDiferencias importantes:\n- 501 Not Implemented: servidor/proxy no tiene la capacidad\n- 415 Unsupported Media Type: Content-Type no soportado\n- 400 Bad Request: Transfer-Encoding mal formado\n\nCliente debe adaptar:\n\nfetch('https://api.example.com/api/upload', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/octet-stream',\n        // NO usar Transfer-Encoding compress\n        // 'Transfer-Encoding': 'compress',  ❌\n        \n        // Opciones válidas:\n        'Content-Encoding': 'gzip',  // ✅ Comprimir el contenido\n        // O usar chunked (automático en HTTP/1.1)\n    },\n    body: gzippedData\n});\n\nAlternativa moderna (HTTP/2):\n\n// HTTP/2 no usa Transfer-Encoding\n// En su lugar usa compresión nativa de headers (HPACK)\n// y frames para streaming\n\nfetch('https://api.example.com/api/upload', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/octet-stream'\n    },\n    body: data  // HTTP/2 maneja streaming automáticamente\n});",
                "explanation": "Un proxy moderno recibe una solicitud con Transfer-Encoding: compress, un algoritmo de compresión obsoleto (algoritmo LZW de Unix) que raramente está implementado en servidores/proxies modernos. El proxy no tiene la capacidad de decodificar este encoding y devuelve 501, indicando que no puede procesar solicitudes con este tipo de codificación. La respuesta lista los encodings soportados (chunked, gzip, identity) para que el cliente pueda adaptar su solicitud. El cliente debe usar un encoding soportado como gzip o simplemente chunked transfer encoding estándar de HTTP/1.1."
            },
            {
                "scenario": "Métodos WebDAV no implementados en servidor HTTP estándar",
                "request": "PROPFIND /documents/reports/ HTTP/1.1\nHost: files.example.com\nDepth: 1\nContent-Type: application/xml\nAuthorization: Basic dXNlcjpwYXNz\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:propfind xmlns:D=\"DAV:\">\n  <D:prop>\n    <D:displayname/>\n    <D:getcontentlength/>\n    <D:getlastmodified/>\n  </D:prop>\n</D:propfind>",
                "response": "HTTP/1.1 501 Not Implemented\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/html\nContent-Length: 187\n\n<html>\n<head><title>501 Not Implemented</title></head>\n<body>\n<h1>501 Not Implemented</h1>\n<p>The PROPFIND method is not implemented on this server.</p>\n<p>This server does not support WebDAV.</p>\n</body>\n</html>\n\nConfiguración nginx (sin módulo WebDAV):\n\nserver {\n    listen 80;\n    server_name files.example.com;\n    \n    location /documents/ {\n        root /var/www/files;\n        \n        # nginx estándar NO incluye soporte WebDAV\n        # Métodos WebDAV: PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK\n        \n        # Si se reciben métodos WebDAV → 501\n        if ($request_method ~* \"^(PROPFIND|PROPPATCH|MKCOL|COPY|MOVE|LOCK|UNLOCK)$\") {\n            return 501 \"The $request_method method is not implemented. This server does not support WebDAV.\";\n        }\n        \n        # Solo permitir métodos HTTP estándar\n        limit_except GET HEAD POST PUT DELETE OPTIONS {\n            deny all;\n        }\n    }\n}\n\nMétodos WebDAV y su propósito:\n\nPROPFIND:     Obtener propiedades de recursos (metadatos)\nPROPPATCH:    Modificar propiedades de recursos\nMKCOL:        Crear colecciones (directorios)\nCOPY:         Copiar recursos\nMOVE:         Mover/renombrar recursos\nLOCK:         Bloquear recursos (edición exclusiva)\nUNLOCK:       Desbloquear recursos\n\nEjemplo de cliente WebDAV intentando conectar:\n\n# Cliente WebDAV (cadaver, davfs, Windows Explorer)\n$ cadaver http://files.example.com/documents/\n\nConnecting to files.example.com...\nAuthentication required:\nUsername: user\nPassword: ****\n\nPROPFIND /documents/ → 501 Not Implemented\nERROR: Server does not support WebDAV\nConnection failed.\n\nSOLUCIÓN - Habilitar WebDAV en nginx:\n\n# Instalar módulo WebDAV\n# nginx-full en Debian/Ubuntu incluye ngx_http_dav_module\n\nserver {\n    listen 80;\n    server_name files.example.com;\n    \n    location /documents/ {\n        root /var/www/files;\n        \n        # Habilitar métodos WebDAV\n        dav_methods PUT DELETE MKCOL COPY MOVE;\n        \n        # Habilitar métodos WebDAV extendidos (requiere nginx-dav-ext-module)\n        # dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;\n        \n        # Permisos\n        dav_access user:rw group:r;\n        \n        # Crear directorios intermedios automáticamente\n        create_full_put_path on;\n        \n        # Autenticación\n        auth_basic \"WebDAV Access\";\n        auth_basic_user_file /etc/nginx/.htpasswd;\n        \n        # CORS para clientes web\n        add_header 'Access-Control-Allow-Origin' '*';\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS, PROPFIND, MKCOL';\n    }\n}\n\nAlternativa: usar servidor WebDAV dedicado\n\n# Apache con mod_dav (soporte completo WebDAV)\n<VirtualHost *:80>\n    ServerName files.example.com\n    DocumentRoot /var/www/files\n    \n    <Directory /var/www/files/documents>\n        # Habilitar WebDAV\n        Dav On\n        \n        # Configurar locking\n        DavLockDB /var/lock/apache2/DavLock\n        \n        # Autenticación\n        AuthType Basic\n        AuthName \"WebDAV Storage\"\n        AuthUserFile /etc/apache2/.htpasswd\n        Require valid-user\n        \n        # Permisos por método\n        <LimitExcept GET HEAD OPTIONS PROPFIND>\n            Require user admin\n        </LimitExcept>\n    </Directory>\n</VirtualHost>\n\nCliente debe verificar soporte WebDAV:\n\n// JavaScript - Verificar soporte WebDAV antes de usar\nasync function checkWebDAVSupport(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'OPTIONS'\n        });\n        \n        const davHeader = response.headers.get('DAV');\n        const allowHeader = response.headers.get('Allow');\n        \n        if (!davHeader || !allowHeader?.includes('PROPFIND')) {\n            console.warn('WebDAV not supported on this server');\n            console.log('Supported methods:', allowHeader);\n            return false;\n        }\n        \n        console.log('WebDAV support level:', davHeader);\n        return true;\n    } catch (error) {\n        console.error('Failed to check WebDAV support:', error);\n        return false;\n    }\n}\n\n// Usar API REST como fallback si no hay WebDAV\nif (!await checkWebDAVSupport('/documents/')) {\n    // Usar API REST estándar en su lugar\n    useRESTAPI();\n} else {\n    // Usar cliente WebDAV\n    useWebDAVClient();\n}",
                "explanation": "Un cliente WebDAV (como Windows Explorer en modo \"Map Network Drive\" o aplicaciones de sincronización de archivos) intenta usar el método PROPFIND para listar archivos y obtener metadatos en un servidor nginx estándar. Sin embargo, nginx sin el módulo WebDAV no tiene implementados los métodos WebDAV (PROPFIND, MKCOL, COPY, MOVE, LOCK, UNLOCK) y devuelve 501. Esto significa que el servidor literalmente no tiene la capacidad de procesar solicitudes WebDAV - no es que esté prohibido (403) o no disponible temporalmente (503), sino que el servidor no tiene implementada esa funcionalidad. La solución es instalar nginx con el módulo WebDAV o usar Apache con mod_dav, que tiene soporte completo para WebDAV."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.2",
        "relatedHeaders": [
            "Allow"
        ],
        "relatedCodes": [
            405,
            400,
            505
        ],
        "technicalNotes": "El código 501 indica que el servidor NO ha implementado la funcionalidad requerida. Diferencias críticas: 501 Not Implemented = servidor carece de la capacidad completamente (método HTTP no reconocido, funcionalidad no implementada); 405 Method Not Allowed = servidor entiende el método pero no lo permite para ese recurso específico (incluye header Allow); 400 Bad Request = solicitud mal formada; 505 HTTP Version Not Supported = versión HTTP no soportada. El 501 es una limitación PERMANENTE del servidor - no se espera que cambie sin actualización/reconfiguración del servidor. Casos comunes: (1) Métodos HTTP antiguos/modernos no implementados (PATCH en servidores viejos, WebDAV methods en servidores sin WebDAV); (2) Transfer-Encoding no soportado (compress, deflate obsoletos); (3) Características HTTP/2 o HTTP/3 en servidor HTTP/1.1 only; (4) Expect: 100-continue no implementado; (5) Proxies que no pueden manejar ciertos tipos de solicitudes. Best practices: Incluir header Allow listando métodos soportados; proporcionar mensaje claro explicando qué no está implementado; sugerir alternativas cuando sea posible; loguear 501s para identificar necesidades de actualización. A diferencia de 5xx temporales (503, 504), el 501 indica problema permanente - clientes NO deben reintentar automáticamente. Monitoreo: 501s frecuentes pueden indicar: clientes usando funcionalidades modernas en servidor legacy, necesidad de actualizar servidor/proxy, documentación API incorrecta prometiendo funcionalidades no implementadas. Soluciones: actualizar servidor a versión moderna, instalar módulos necesarios (WebDAV, HTTP/2), implementar métodos HTTP faltantes en aplicación, o documentar claramente limitaciones.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768844686/501_ufydhr.png",
                "alt": "Imagen que representa el nombre del código 501 Not Implemented"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768844406/64-removebg-preview_tzlryy.png",
                "alt": "Imagen del código 501 Not Implemented"
            }
        ]
    },
    {
        "code": 502,
        "status": "Bad Gateway",
        "category": "Server Error",
        "description": "El código 502 Bad Gateway es un código de estado HTTP estándar que indica que un servidor actuando como gateway o proxy recibió una respuesta inválida del servidor upstream al que intentó acceder para completar la solicitud. El servidor proxy/gateway está diciendo: 'Intenté comunicarme con el servidor backend para procesar tu solicitud, pero recibí una respuesta que no puedo entender o que está mal formada'. Es importante entender que el 502 NO significa que el servidor proxy tenga un problema - el problema está en el servidor upstream (backend) o en la comunicación entre el proxy y el backend. A diferencia del 500 (error interno del servidor), el 502 específicamente identifica que el problema ocurrió durante la comunicación entre servidores. Las causas más comunes incluyen: servidor backend caído o no responde, servidor backend devolvió respuesta HTTP mal formada, timeout de conexión al backend, servidor backend sobrecargado y rechazando conexiones, problemas de DNS al resolver nombre del backend, firewall bloqueando comunicación entre proxy y backend, o servidor backend reiniciándose/desplegándose. El código 502 es muy común en arquitecturas modernas con load balancers, reverse proxies (nginx, Apache), API gateways, CDNs, y servicios en la nube. Un 502 generalmente indica un problema temporal que puede resolverse automáticamente cuando el backend se recupere. Los clientes pueden reintentar la solicitud después de un breve delay. Monitorear 502s es crítico para identificar problemas de infraestructura, deploys problemáticos, o backends inestables.",
        "useCases": [
            "Servidor backend caído o no responde",
            "Backend devuelve respuesta HTTP mal formada",
            "Timeout de conexión al servidor upstream",
            "Backend sobrecargado rechazando nuevas conexiones",
            "DNS no puede resolver nombre del servidor backend",
            "Firewall bloqueando comunicación proxy-backend",
            "Backend reiniciándose durante deploy",
            "Versión HTTP incompatible entre proxy y backend"
        ],
        "examples": [
            {
                "scenario": "Servidor backend caído durante deploy",
                "request": "GET /api/products HTTP/1.1\nHost: api.example.com\nUser-Agent: Mozilla/5.0...\nAccept: application/json",
                "response": "HTTP/1.1 502 Bad Gateway\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/html\nContent-Length: 157\n\n<html>\n<head><title>502 Bad Gateway</title></head>\n<body>\n<center><h1>502 Bad Gateway</h1></center>\n<center>nginx/1.24.0</center>\n</body>\n</html>\n\nConfiguración nginx:\n\nupstream api_backend {\n    # Pool de servidores backend\n    server backend1.internal:8080;\n    server backend2.internal:8080;\n    server backend3.internal:8080;\n    \n    # Health check pasivo\n    # Si un backend falla, nginx lo marca como down\n    max_fails 3;\n    fail_timeout 30s;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location /api/ {\n        proxy_pass http://api_backend;\n        \n        # Timeouts\n        proxy_connect_timeout 5s;   # Timeout para conectar al backend\n        proxy_send_timeout 10s;     # Timeout para enviar request\n        proxy_read_timeout 30s;     # Timeout para recibir respuesta\n        \n        # Headers para el backend\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        # Página de error personalizada para 502\n        error_page 502 /502.html;\n    }\n    \n    location = /502.html {\n        root /usr/share/nginx/html;\n        internal;\n    }\n}\n\nEscenario: Deploy con downtime\n\nTimeline:\n14:28:00 - Deploy iniciado: todos los backends empiezan a reiniciarse\n14:28:05 - backend1 apagado (no acepta conexiones)\n14:28:10 - backend2 apagado\n14:28:15 - backend3 apagado\n14:28:20 - TODOS los backends caídos\n14:28:25 - nginx intenta conectar → Connection refused\n14:28:30 - nginx devuelve 502 Bad Gateway a clientes\n14:29:00 - backend1 vuelve online\n14:29:15 - backend2 vuelve online\n14:29:30 - backend3 vuelve online\n14:30:00 - Servicio completamente restaurado\n\nLog de nginx durante el incidente:\n\n[2024-01-17 14:28:30] [error] connect() failed (111: Connection refused) while connecting to upstream, client: 203.0.113.10, server: api.example.com, request: \"GET /api/products HTTP/1.1\", upstream: \"http://backend1.internal:8080/api/products\", host: \"api.example.com\"\n\n[2024-01-17 14:28:30] [error] connect() failed (111: Connection refused) while connecting to upstream, client: 203.0.113.10, server: api.example.com, request: \"GET /api/products HTTP/1.1\", upstream: \"http://backend2.internal:8080/api/products\", host: \"api.example.com\"\n\n[2024-01-17 14:28:30] [error] connect() failed (111: Connection refused) while connecting to upstream, client: 203.0.113.10, server: api.example.com, request: \"GET /api/products HTTP/1.1\", upstream: \"http://backend3.internal:8080/api/products\", host: \"api.example.com\"\n\n[2024-01-17 14:28:30] [error] no live upstreams while connecting to upstream, client: 203.0.113.10, server: api.example.com, request: \"GET /api/products HTTP/1.1\", upstream: \"http://api_backend/api/products\", host: \"api.example.com\"\n\nSOLUCIÓN - Deploy sin downtime (Rolling deployment):\n\nupstream api_backend {\n    server backend1.internal:8080;\n    server backend2.internal:8080;\n    server backend3.internal:8080;\n    \n    # Health check activo (requiere nginx plus o módulo)\n    # Alternativamente, usar passive health checks\n    max_fails 2;\n    fail_timeout 10s;\n}\n\nserver {\n    location /api/ {\n        proxy_pass http://api_backend;\n        proxy_next_upstream error timeout http_502 http_503 http_504;\n        proxy_next_upstream_tries 3;\n        \n        # Si un backend falla, nginx automáticamente intenta el siguiente\n    }\n}\n\nEstrategia de deploy:\n\n# 1. Deploy backend1 → esperar health check OK\n# 2. Deploy backend2 → esperar health check OK  \n# 3. Deploy backend3 → esperar health check OK\n# Siempre hay al menos 2/3 backends disponibles\n\n# Script de deploy\n#!/bin/bash\nfor backend in backend1 backend2 backend3; do\n    echo \"Deploying $backend...\"\n    ssh $backend 'systemctl restart api-service'\n    \n    # Esperar a que el health check pase\n    for i in {1..30}; do\n        if curl -f http://$backend:8080/health > /dev/null 2>&1; then\n            echo \"$backend is healthy\"\n            break\n        fi\n        echo \"Waiting for $backend to be healthy... ($i/30)\"\n        sleep 2\n    done\n    \n    # Esperar 10 segundos adicionales antes del siguiente\n    sleep 10\ndone\n\nManejo del cliente:\n\n// Cliente con retry automático para 502\nasync function fetchWithRetry(url, options = {}, maxRetries = 3) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            const response = await fetch(url, options);\n            \n            if (response.status === 502) {\n                if (attempt < maxRetries) {\n                    console.warn(`502 Bad Gateway, retrying (${attempt}/${maxRetries})...`);\n                    // Exponential backoff: 1s, 2s, 4s\n                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));\n                    continue;\n                } else {\n                    throw new Error('Service temporarily unavailable after retries');\n                }\n            }\n            \n            return response;\n        } catch (error) {\n            if (attempt === maxRetries) throw error;\n            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n        }\n    }\n}\n\n// Uso\ntry {\n    const response = await fetchWithRetry('/api/products');\n    const data = await response.json();\n    console.log(data);\n} catch (error) {\n    console.error('Failed after retries:', error);\n    showErrorMessage('Service temporarily unavailable. Please try again later.');\n}",
                "explanation": "Este es el escenario más común de 502: todos los servidores backend están caídos durante un deploy. nginx (actuando como reverse proxy) intenta conectar a backend1, backend2, y backend3, pero todos rechazan la conexión porque están reiniciándose. Al no tener ningún backend disponible, nginx devuelve 502 Bad Gateway al cliente. Los logs de nginx muestran 'Connection refused' y 'no live upstreams'. La solución es implementar rolling deployment: desplegar los backends uno por uno, esperando que cada uno pase el health check antes de continuar con el siguiente. De esta forma siempre hay al menos 2 de 3 backends disponibles, evitando 502s. El cliente también debe implementar retry logic con exponential backoff para manejar 502s transitorios."
            },
            {
                "scenario": "Backend devuelve respuesta HTTP mal formada",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAuthorization: Bearer token_abc",
                "response": "HTTP/1.1 502 Bad Gateway\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/html\nContent-Length: 157\n\n<html>\n<head><title>502 Bad Gateway</title></head>\n<body>\n<center><h1>502 Bad Gateway</h1></center>\n<center>nginx/1.24.0</center>\n</body>\n</html>\n\nLo que sucedió en el backend (Node.js con bug):\n\n// backend-server.js - CÓDIGO CON BUG\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    if (req.url === '/api/data') {\n        // BUG: Escribir al response después de res.end()\n        res.writeHead(200, {'Content-Type': 'application/json'});\n        res.write('{\"status\":\"ok\",');\n        res.end();  // Terminar respuesta aquí\n        \n        // ERROR: Intentar escribir después de end()\n        setTimeout(() => {\n            res.write('\"data\":[1,2,3]}');  // ❌ Crash o respuesta mal formada\n        }, 100);\n    }\n});\n\nserver.listen(8080);\n\nRespuesta del backend al proxy (MAL FORMADA):\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nTransfer-Encoding: chunked\n\n0\r\n  ← Indica fin de respuesta chunked\n\r\n\n\"data\":[1,2,3]}  ← Datos adicionales después del fin (INVÁLIDO)\n\nnginx recibe esto y detecta violación del protocolo HTTP:\n- Transfer-Encoding: chunked terminó con chunk de tamaño 0\n- Pero hay datos adicionales después\n- Esto viola la especificación HTTP\n- nginx rechaza la respuesta → 502 Bad Gateway\n\nLog de nginx:\n\n[2024-01-17 15:45:00] [error] upstream sent invalid chunked response while reading response header from upstream, client: 203.0.113.25, server: api.example.com, request: \"GET /api/data HTTP/1.1\", upstream: \"http://backend1.internal:8080/api/data\", host: \"api.example.com\"\n\n[2024-01-17 15:45:00] [warn] upstream sent invalid HTTP response while reading response header from upstream\n\nOtros casos de respuestas mal formadas que causan 502:\n\n1. Headers HTTP mal formados:\nHTTP/1.1 200 OK\nContent Type: application/json  ❌ (debe ser Content-Type con guión)\nContent-Length: abc              ❌ (debe ser número)\n\n2. Status line inválida:\nHTTP/1.1 200                     ❌ (falta reason phrase)\nHTTP/1.x 200 OK                  ❌ (versión inválida)\n\n3. Response sin status line:\n{\"data\": \"value\"}                ❌ (JSON directo, sin headers HTTP)\n\n4. Caracteres no ASCII en headers:\nHTTP/1.1 200 OK\nX-Custom-Header: café☕          ❌ (emojis/acentos en headers)\n\n5. Content-Length incorrecto:\nHTTP/1.1 200 OK\nContent-Length: 100\n\n{\"short\": \"data\"}                ❌ (solo 18 bytes, no 100)\n\nSOLUCIÓN - Código backend corregido:\n\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    if (req.url === '/api/data') {\n        // Construir respuesta completa ANTES de enviar\n        const responseData = {\n            status: 'ok',\n            data: [1, 2, 3]\n        };\n        \n        const body = JSON.stringify(responseData);\n        \n        // Enviar headers correctos\n        res.writeHead(200, {\n            'Content-Type': 'application/json',\n            'Content-Length': Buffer.byteLength(body)\n        });\n        \n        // Enviar body completo\n        res.end(body);\n        \n        // ✅ No intentar escribir después de end()\n    } else {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('Not Found');\n    }\n});\n\nserver.listen(8080);\n\nValidación en nginx:\n\nserver {\n    location /api/ {\n        proxy_pass http://api_backend;\n        \n        # Validar respuesta del backend\n        proxy_http_version 1.1;\n        \n        # Buffers para manejar respuestas grandes\n        proxy_buffer_size 4k;\n        proxy_buffers 8 4k;\n        proxy_busy_buffers_size 8k;\n        \n        # Si backend envía respuesta inválida → 502\n        # nginx loguea el error específico\n    }\n}\n\nMonitoreo para detectar respuestas mal formadas:\n\n# Alertas en logs de nginx para identificar problemas\ngrep \"invalid.*response\" /var/log/nginx/error.log\ngrep \"upstream sent\" /var/log/nginx/error.log\n\n# Patrones comunes:\n# - \"upstream sent invalid chunked response\"\n# - \"upstream sent invalid header\"\n# - \"upstream sent invalid HTTP response\"\n# - \"upstream prematurely closed connection\"",
                "explanation": "Un bug en el código del backend hace que envíe una respuesta HTTP mal formada: intenta escribir datos adicionales después de haber terminado la respuesta con res.end(). Esto viola el protocolo HTTP, especialmente cuando se usa Transfer-Encoding: chunked. nginx recibe esta respuesta malformada, detecta la violación del protocolo (datos después del chunk de tamaño 0 que indica fin), y rechaza la respuesta devolviendo 502 Bad Gateway al cliente. Los logs de nginx muestran 'upstream sent invalid chunked response'. La solución es corregir el código del backend para construir la respuesta completa antes de enviarla, asegurando que se respete el protocolo HTTP y no se escriba al response después de end()."
            },
            {
                "scenario": "Timeout de conexión al backend (backend sobrecargado)",
                "request": "POST /api/process HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 145\n\n{\n  \"task\": \"analyze_large_dataset\",\n  \"dataset_id\": \"dataset_12345\",\n  \"options\": {\"detailed\": true}\n}",
                "response": "HTTP/1.1 502 Bad Gateway\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/html\nContent-Length: 157\n\n<html>\n<head><title>502 Bad Gateway</title></head>\n<body>\n<center><h1>502 Bad Gateway</h1></center>\n<center>nginx/1.24.0</center>\n</body>\n</html>\n\nConfiguración nginx:\n\nupstream processing_backend {\n    server backend1.internal:8080 max_fails=3 fail_timeout=30s;\n    server backend2.internal:8080 max_fails=3 fail_timeout=30s;\n    \n    # Límite de conexiones por backend\n    # Si se excede, nginx espera o devuelve error\n    keepalive 32;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location /api/process {\n        proxy_pass http://processing_backend;\n        \n        # TIMEOUTS CRÍTICOS\n        proxy_connect_timeout 10s;  # Timeout para establecer conexión TCP\n        proxy_send_timeout 30s;     # Timeout para enviar request\n        proxy_read_timeout 60s;     # Timeout para recibir respuesta\n        \n        # Si excede proxy_connect_timeout → 502\n        # Si excede proxy_read_timeout → 504 Gateway Timeout\n    }\n}\n\nEscenario: Backend sobrecargado\n\nEstado del backend:\n- CPU: 95% utilizada\n- RAM: 7.8GB / 8GB (97%)\n- Conexiones activas: 250 / 256 (casi en límite)\n- Queue de requests: 45 esperando procesamiento\n- Nuevas conexiones TCP: rechazadas o muy lentas\n\nTimeline de la solicitud:\n\n16:30:00.000 - Cliente envía POST /api/process\n16:30:00.001 - nginx recibe request\n16:30:00.002 - nginx intenta conectar a backend1:8080\n16:30:00.003 - backend1 no responde (sobrecargado, backlog lleno)\n16:30:00.004 - nginx espera... (proxy_connect_timeout=10s)\n16:30:00.005 - nginx sigue esperando...\n16:30:10.002 - TIMEOUT (10 segundos después)\n16:30:10.003 - nginx intenta backend2:8080\n16:30:10.004 - backend2 tampoco responde (también sobrecargado)\n16:30:20.004 - TIMEOUT otra vez\n16:30:20.005 - nginx no tiene más backends → 502 Bad Gateway\n\nLog de nginx:\n\n[2024-01-17 16:30:10] [error] upstream timed out (110: Connection timed out) while connecting to upstream, client: 203.0.113.50, server: api.example.com, request: \"POST /api/process HTTP/1.1\", upstream: \"http://backend1.internal:8080/api/process\", host: \"api.example.com\"\n\n[2024-01-17 16:30:20] [error] upstream timed out (110: Connection timed out) while connecting to upstream, client: 203.0.113.50, server: api.example.com, request: \"POST /api/process HTTP/1.1\", upstream: \"http://backend2.internal:8080/api/process\", host: \"api.example.com\"\n\n[2024-01-17 16:30:20] [error] no live upstreams while connecting to upstream, client: 203.0.113.50, server: api.example.com, request: \"POST /api/process HTTP/1.1\"\n\nDiferencias importantes:\n\n502 Bad Gateway:\n- Backend rechaza conexión (Connection refused)\n- Backend timeout al conectar\n- Backend respuesta mal formada\n\n504 Gateway Timeout:\n- Conexión establecida OK\n- Backend no envía respuesta completa a tiempo\n- Excede proxy_read_timeout\n\nSOLUCIONES:\n\n1. Escalar backends horizontalmente:\n\nupstream processing_backend {\n    # Añadir más servidores\n    server backend1.internal:8080;\n    server backend2.internal:8080;\n    server backend3.internal:8080;  # Nuevo\n    server backend4.internal:8080;  # Nuevo\n    server backend5.internal:8080;  # Nuevo\n    \n    # Load balancing con least_conn\n    least_conn;  # Enviar a backend con menos conexiones activas\n}\n\n2. Implementar queue/retry con backoff:\n\nserver {\n    location /api/process {\n        proxy_pass http://processing_backend;\n        \n        # Reintentar en otro backend si falla\n        proxy_next_upstream error timeout http_502;\n        proxy_next_upstream_tries 3;\n        proxy_next_upstream_timeout 30s;\n        \n        # Aumentar timeouts para procesamiento pesado\n        proxy_connect_timeout 15s;\n        proxy_read_timeout 120s;\n    }\n}\n\n3. Circuit breaker en cliente:\n\nclass CircuitBreaker {\n    constructor(threshold = 5, timeout = 60000) {\n        this.failureCount = 0;\n        this.threshold = threshold;\n        this.timeout = timeout;\n        this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN\n        this.nextAttempt = Date.now();\n    }\n    \n    async call(fn) {\n        if (this.state === 'OPEN') {\n            if (Date.now() < this.nextAttempt) {\n                throw new Error('Circuit breaker is OPEN');\n            }\n            this.state = 'HALF_OPEN';\n        }\n        \n        try {\n            const result = await fn();\n            this.onSuccess();\n            return result;\n        } catch (error) {\n            this.onFailure();\n            throw error;\n        }\n    }\n    \n    onSuccess() {\n        this.failureCount = 0;\n        this.state = 'CLOSED';\n    }\n    \n    onFailure() {\n        this.failureCount++;\n        if (this.failureCount >= this.threshold) {\n            this.state = 'OPEN';\n            this.nextAttempt = Date.now() + this.timeout;\n            console.warn('Circuit breaker opened');\n        }\n    }\n}\n\nconst breaker = new CircuitBreaker(5, 60000);\n\nasync function processData(data) {\n    try {\n        return await breaker.call(async () => {\n            const response = await fetch('/api/process', {\n                method: 'POST',\n                headers: {'Content-Type': 'application/json'},\n                body: JSON.stringify(data)\n            });\n            \n            if (response.status === 502) {\n                throw new Error('Backend unavailable');\n            }\n            \n            return response.json();\n        });\n    } catch (error) {\n        console.error('Request failed:', error);\n        showUserMessage('Service temporarily overloaded. Please try again in a minute.');\n    }\n}\n\n4. Monitoreo y auto-scaling:\n\n# Prometheus metrics\nupstream_response_time_seconds\nupstream_connection_failures_total\nactive_connections\n\n# Alert\nalert: HighBackendConnectionFailures\n  expr: rate(upstream_connection_failures_total[5m]) > 0.1\n  for: 5m\n  annotations:\n    summary: \"High rate of backend connection failures (502s)\"\n    description: \"{{ $value }} connection failures per second\"\n    action: \"Scale up backend instances\"\n\n# Auto-scaling en Kubernetes\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-backend\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-backend\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80",
                "explanation": "El backend está completamente sobrecargado (CPU 95%, RAM 97%, conexiones al límite) y no puede aceptar nuevas conexiones TCP. nginx intenta conectar a backend1, pero después de 10 segundos (proxy_connect_timeout) no recibe respuesta - el backend está tan saturado que ni siquiera puede aceptar la conexión. nginx intenta backend2 con el mismo resultado. Al no tener backends disponibles, devuelve 502 Bad Gateway. Los logs muestran 'Connection timed out' y 'no live upstreams'. Las soluciones incluyen: (1) escalar horizontalmente añadiendo más backends, (2) implementar circuit breaker para fallar rápido, (3) configurar auto-scaling basado en métricas, (4) usar least_conn load balancing para distribuir mejor la carga, y (5) implementar retry logic con exponential backoff en el cliente."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.3",
        "relatedHeaders": [
            "Retry-After"
        ],
        "relatedCodes": [
            500,
            503,
            504
        ],
        "technicalNotes": "El código 502 indica específicamente que un proxy/gateway recibió respuesta inválida del upstream. Diferencias críticas: 502 Bad Gateway = proxy recibió respuesta inválida o no pudo conectar al backend; 500 Internal Server Error = error interno del servidor sin proxy involucrado; 503 Service Unavailable = servidor temporalmente sobrecargado o en mantenimiento (puede ser el proxy mismo); 504 Gateway Timeout = proxy se conectó OK pero backend no respondió a tiempo. Causas detalladas: (1) Backend caído - 'Connection refused' (errno 111 Linux, 10061 Windows); (2) Backend timeout - 'Connection timed out' (errno 110); (3) Respuesta HTTP mal formada - headers inválidos, chunked encoding incorrecto, Content-Length incorrecto; (4) Versión HTTP incompatible; (5) Backend cerró conexión prematuramente; (6) DNS failure resolviendo backend; (7) Firewall/security group bloqueando. nginx mensajes de error comunes: 'upstream sent invalid chunked response', 'upstream sent invalid header', 'upstream prematurely closed connection', 'no live upstreams', 'connect() failed'. Best practices: (1) Implementar health checks activos en load balancer; (2) Rolling deployments para evitar downtime; (3) proxy_next_upstream para retry automático; (4) Circuit breakers en cliente; (5) Monitorear 502s por endpoint y backend; (6) Loguear detalles completos (qué backend falló, por qué); (7) Incluir Retry-After header; (8) Auto-scaling basado en métricas. Debugging: revisar logs de nginx Y del backend, verificar conectividad de red, validar formato de respuestas HTTP, revisar configuración de timeouts, verificar recursos del backend (CPU, RAM, conexiones), analizar timing (¿ocurre durante deploys?). 502 generalmente es TEMPORAL y resoluble con retry, a diferencia de 500 que puede indicar bug permanente.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768844684/502_a2r4vw.png",
                "alt": "Imagen que representa el nombre del código 502 Bad Gateway"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768844405/65-removebg-preview_vkwkro.png",
                "alt": "Imagen del código 502 Bad Gateway"
            }
        ]
    },
    {
        "code": 503,
        "status": "Service Unavailable",
        "category": "Server Error",
        "description": "El código 503 Service Unavailable es un código de estado HTTP estándar que indica que el servidor actualmente no puede manejar la solicitud debido a una sobrecarga temporal o mantenimiento programado. El servidor está diciendo: 'Estoy funcionando, pero temporalmente no puedo procesar tu solicitud en este momento - intenta de nuevo más tarde'. Es importante entender que el 503 es TEMPORAL por naturaleza - el servidor espera poder manejar la solicitud en el futuro cercano. A diferencia del 500 (error interno permanente) o 502 (problema con backend upstream), el 503 indica una condición temporal del servidor mismo. Las causas más comunes incluyen: servidor sobrecargado con demasiadas solicitudes concurrentes, mantenimiento programado del servidor, recursos del sistema agotados (memoria, CPU, hilos de trabajo), límite de rate limiting alcanzado, servidor reiniciándose o iniciándose (warmup period), cola de procesamiento llena, o dependencias críticas temporalmente no disponibles. El código 503 es crucial en arquitecturas modernas para implementar degradación elegante - el servidor puede devolver 503 para nuevas solicitudes mientras completa las solicitudes en curso. Los clientes que reciben 503 DEBEN respetar el header Retry-After si está presente, que indica cuándo pueden reintentar. Monitorear 503s es esencial para identificar problemas de capacidad, necesidad de escalar, o problemas con deploys.",
        "useCases": [
            "Servidor sobrecargado con demasiadas conexiones concurrentes",
            "Mantenimiento programado del servidor",
            "Servidor iniciándose (warmup/startup period)",
            "Rate limiting - límite de requests excedido",
            "Cola de procesamiento llena (max queue size alcanzado)",
            "Recursos del sistema temporalmente agotados",
            "Degradación elegante durante alta carga",
            "Circuit breaker abierto (dependencias caídas)"
        ],
        "examples": [
            {
                "scenario": "Servidor sobrecargado - Demasiadas conexiones concurrentes",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nUser-Agent: Mozilla/5.0...\nAccept: application/json\nAuthorization: Bearer token_abc",
                "response": "HTTP/1.1 503 Service Unavailable\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nRetry-After: 30\nContent-Length: 152\n\n{\n  \"error\": \"Service Unavailable\",\n  \"message\": \"Server is temporarily overloaded. Please try again in 30 seconds.\",\n  \"retry_after\": 30,\n  \"timestamp\": \"2024-01-17T14:30:00Z\"\n}\n\nConfiguración nginx con límite de conexiones:\n\nhttp {\n    # Limitar conexiones concurrentes globalmente\n    limit_conn_zone $server_name zone=server_conn:10m;\n    limit_conn_zone $binary_remote_addr zone=per_ip:10m;\n    \n    # Limitar rate de requests\n    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location /api/ {\n        # Máximo 1000 conexiones concurrentes al servidor\n        limit_conn server_conn 1000;\n        \n        # Máximo 10 conexiones concurrentes por IP\n        limit_conn per_ip 10;\n        \n        # Máximo 10 requests por segundo por IP\n        # burst=20 permite picos de hasta 20 requests\n        # nodelay procesa el burst inmediatamente\n        limit_req zone=api_limit burst=20 nodelay;\n        \n        # Si se exceden los límites → 503\n        limit_conn_status 503;\n        limit_req_status 503;\n        \n        # Mensaje de error personalizado\n        error_page 503 /503.json;\n        \n        proxy_pass http://backend;\n    }\n    \n    location = /503.json {\n        internal;\n        default_type application/json;\n        return 503 '{\"error\":\"Service Unavailable\",\"message\":\"Server temporarily overloaded\",\"retry_after\":30}';\n        add_header Retry-After \"30\" always;\n    }\n}\n\nEscenario: Pico de tráfico\n\nEstado del servidor:\n- Conexiones concurrentes: 1000/1000 (límite alcanzado)\n- Requests en cola: 150 (esperando procesamiento)\n- CPU: 85% utilizada\n- RAM: 6.5GB / 8GB (81%)\n- Nuevas conexiones: rechazadas temporalmente\n\nTimeline:\n14:28:00 - Tráfico normal: 200 conexiones concurrentes\n14:29:00 - Inicio de pico: 500 conexiones\n14:29:30 - Pico continúa: 800 conexiones\n14:30:00 - LÍMITE ALCANZADO: 1000 conexiones\n14:30:15 - Nueva solicitud llega → 503 Service Unavailable\n14:30:20 - Múltiples 503s siendo devueltos\n14:31:00 - Algunas conexiones terminan, espacio disponible\n14:31:30 - Tráfico volviendo a normal: 600 conexiones\n14:32:00 - Servidor estabilizado: 300 conexiones\n\nLog de nginx:\n\n[2024-01-17 14:30:00] [error] limiting connections by zone \"server_conn\", client: 203.0.113.10, server: api.example.com, request: \"GET /api/data HTTP/1.1\", host: \"api.example.com\"\n\n[2024-01-17 14:30:05] [warn] 1000 worker connections exceeded while connecting to upstream, client: 203.0.113.15\n\n[2024-01-17 14:30:10] [error] limiting requests, excess: 20.500 by zone \"api_limit\", client: 198.51.100.20, server: api.example.com, request: \"GET /api/products HTTP/1.1\"\n\nCliente con manejo de 503:\n\nasync function fetchWithRetry(url, maxRetries = 3) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            const response = await fetch(url);\n            \n            if (response.status === 503) {\n                const retryAfter = response.headers.get('Retry-After');\n                const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : 5000;\n                \n                if (attempt < maxRetries) {\n                    console.log(`503 received, retrying after ${waitTime/1000}s...`);\n                    await new Promise(resolve => setTimeout(resolve, waitTime));\n                    continue;\n                } else {\n                    throw new Error('Service unavailable after retries');\n                }\n            }\n            \n            return response;\n        } catch (error) {\n            if (attempt === maxRetries) throw error;\n        }\n    }\n}\n\n// Uso con fallback\ntry {\n    const response = await fetchWithRetry('/api/data');\n    const data = await response.json();\n    displayData(data);\n} catch (error) {\n    showMessage('Service temporarily busy. Please try again in a moment.');\n    displayCachedData();\n}",
                "explanation": "El servidor está recibiendo un pico masivo de tráfico y ha alcanzado su límite de 1000 conexiones concurrentes. nginx está configurado con limit_conn para proteger el servidor de sobrecarga. Cuando llega una nueva solicitud y el límite ya está alcanzado, nginx inmediatamente devuelve 503 Service Unavailable con un header Retry-After: 30 indicando que el cliente debe esperar 30 segundos antes de reintentar. Esto protege al servidor de colapsar completamente bajo la carga. El cliente inteligente respeta el Retry-After, espera el tiempo indicado, y reintenta."
            },
            {
                "scenario": "Mantenimiento programado del servidor",
                "request": "GET /api/users/profile HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nAccept: application/json",
                "response": "HTTP/1.1 503 Service Unavailable\nDate: Wed, 17 Jan 2024 02:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nRetry-After: Wed, 17 Jan 2024 04:00:00 GMT\nContent-Length: 198\n\n{\n  \"error\": \"Service Unavailable\",\n  \"message\": \"System maintenance in progress\",\n  \"maintenance_window\": {\n    \"start\": \"2024-01-17T02:00:00Z\",\n    \"end\": \"2024-01-17T04:00:00Z\",\n    \"estimated_completion\": \"2024-01-17T04:00:00Z\"\n  },\n  \"status_page\": \"https://status.example.com\"\n}\n\nConfiguración nginx para modo mantenimiento:\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    # Flag de mantenimiento (activado manualmente o por script)\n    set $maintenance 0;\n    \n    # Leer flag desde archivo\n    if (-f /var/www/maintenance.flag) {\n        set $maintenance 1;\n    }\n    \n    location / {\n        # Si está en mantenimiento → 503\n        if ($maintenance = 1) {\n            return 503;\n        }\n        \n        proxy_pass http://backend;\n    }\n    \n    # Página de error personalizada para mantenimiento\n    error_page 503 @maintenance;\n    \n    location @maintenance {\n        root /var/www/maintenance;\n        try_files /maintenance.json =503;\n        add_header Content-Type application/json always;\n        add_header Retry-After \"Wed, 17 Jan 2024 04:00:00 GMT\" always;\n    }\n    \n    # Permitir health checks incluso en mantenimiento\n    location /health {\n        access_log off;\n        return 200 '{\"status\":\"maintenance\"}';\n        add_header Content-Type application/json;\n    }\n}\n\nScript de mantenimiento automatizado:\n\n#!/bin/bash\n# maintenance.sh\n\nMAINTENANCE_FLAG=\"/var/www/maintenance.flag\"\n\nfunction start_maintenance() {\n    echo \"Starting maintenance mode...\"\n    touch \"$MAINTENANCE_FLAG\"\n    nginx -s reload\n    echo \"Maintenance mode activated\"\n}\n\nfunction stop_maintenance() {\n    echo \"Stopping maintenance mode...\"\n    rm -f \"$MAINTENANCE_FLAG\"\n    nginx -s reload\n    echo \"Maintenance mode deactivated\"\n}\n\ncase \"$1\" in\n    start) start_maintenance ;;\n    stop) stop_maintenance ;;\n    *) echo \"Usage: $0 {start|stop}\" ;;\nesac\n\nCliente - Detección de mantenimiento:\n\nasync function request(url, options = {}) {\n    const response = await fetch(url, options);\n    \n    if (response.status === 503) {\n        const data = await response.json();\n        \n        if (data.maintenance_window) {\n            const retryAfter = response.headers.get('Retry-After');\n            const retryDate = new Date(retryAfter);\n            \n            showMaintenanceBanner({\n                message: data.message,\n                endTime: retryDate\n            });\n            \n            // Programar retry automático\n            const waitTime = retryDate - new Date();\n            setTimeout(() => {\n                window.location.reload();\n            }, waitTime);\n        }\n        \n        throw new Error('Service in maintenance');\n    }\n    \n    return response;\n}",
                "explanation": "El servidor está en modo de mantenimiento programado (2:00 AM - 4:00 AM) para realizar actualizaciones críticas. nginx detecta un archivo flag que indica que el mantenimiento está activo y devuelve 503 Service Unavailable para todas las solicitudes. La respuesta incluye un header Retry-After con la fecha exacta de finalización del mantenimiento y un JSON detallando la ventana de mantenimiento. Esto permite a los clientes mostrar mensajes informativos a los usuarios y programar reintentos automáticos después del mantenimiento."
            },
            {
                "scenario": "Rate limiting - Límite de requests excedido",
                "request": "GET /api/search?q=products HTTP/1.1\nHost: api.example.com\nX-API-Key: user_api_key_123\nAccept: application/json\n\n[Este es el request número 1001 en la última hora]",
                "response": "HTTP/1.1 503 Service Unavailable\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1705510800\nRetry-After: 1800\nContent-Length: 245\n\n{\n  \"error\": \"Service Unavailable\",\n  \"message\": \"Rate limit exceeded\",\n  \"rate_limit\": {\n    \"limit\": 1000,\n    \"remaining\": 0,\n    \"reset\": 1705510800,\n    \"reset_time\": \"2024-01-17T17:00:00Z\",\n    \"retry_after\": 1800\n  },\n  \"documentation\": \"https://docs.example.com/rate-limits\"\n}\n\nConfiguración nginx con rate limiting:\n\nhttp {\n    # Zona para rate limiting por API key\n    limit_req_zone $http_x_api_key zone=api_key_limit:10m rate=1000r/h;\n    \n    # Zona para rate limiting por IP (fallback)\n    limit_req_zone $binary_remote_addr zone=ip_limit:10m rate=100r/h;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location /api/search {\n        # Aplicar rate limit\n        limit_req zone=api_key_limit burst=50 nodelay;\n        limit_req_status 503;\n        \n        error_page 503 = @rate_limit_exceeded;\n        proxy_pass http://backend;\n        \n        # Añadir headers de rate limit\n        add_header X-RateLimit-Limit \"1000\" always;\n    }\n    \n    location @rate_limit_exceeded {\n        default_type application/json;\n        add_header X-RateLimit-Limit \"1000\" always;\n        add_header X-RateLimit-Remaining \"0\" always;\n        add_header Retry-After \"1800\" always;\n        return 503 '{\"error\":\"Service Unavailable\",\"message\":\"Rate limit exceeded\"}';\n    }\n}\n\nCliente con manejo de rate limiting:\n\nclass APIClient {\n    constructor(apiKey) {\n        this.apiKey = apiKey;\n        this.rateLimit = {\n            limit: null,\n            remaining: null,\n            reset: null\n        };\n    }\n    \n    async request(url, options = {}) {\n        const response = await fetch(url, {\n            ...options,\n            headers: {\n                'X-API-Key': this.apiKey,\n                ...options.headers\n            }\n        });\n        \n        // Actualizar info de rate limit\n        this.rateLimit.limit = parseInt(response.headers.get('X-RateLimit-Limit'));\n        this.rateLimit.remaining = parseInt(response.headers.get('X-RateLimit-Remaining'));\n        this.rateLimit.reset = parseInt(response.headers.get('X-RateLimit-Reset'));\n        \n        if (response.status === 503) {\n            const data = await response.json();\n            \n            if (data.message?.includes('Rate limit')) {\n                const retryAfter = parseInt(response.headers.get('Retry-After'));\n                const resetTime = new Date(this.rateLimit.reset * 1000);\n                \n                console.error(`Rate limit exceeded. Resets at: ${resetTime.toLocaleString()}`);\n                \n                // Esperar y reintentar si es razonable\n                if (retryAfter < 300) {\n                    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n                    return this.request(url, options);\n                }\n                \n                throw new Error(`Rate limit exceeded. Retry after ${retryAfter}s`);\n            }\n        }\n        \n        return response;\n    }\n}",
                "explanation": "El cliente ha excedido su límite de rate limiting de 1000 requests por hora. El sistema está trackeando requests por API key y detecta que este es el request número 1001. Inmediatamente devuelve 503 Service Unavailable con headers detallados: X-RateLimit-Limit (1000), X-RateLimit-Remaining (0), X-RateLimit-Reset (timestamp del próximo reset), y Retry-After (1800 segundos = 30 minutos). El cliente inteligente lee estos headers, muestra el tiempo de espera al usuario, y puede esperar automáticamente antes de reintentar si el tiempo es razonable."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.4",
        "relatedHeaders": [
            "Retry-After",
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset"
        ],
        "relatedCodes": [
            500,
            502,
            504,
            429
        ],
        "technicalNotes": "El código 503 indica que el servidor está temporalmente incapaz de manejar la solicitud. Diferencias críticas: 503 Service Unavailable = servidor temporalmente sobrecargado o en mantenimiento; 500 Internal Server Error = error permanente del servidor; 502 Bad Gateway = problema con servidor upstream; 504 Gateway Timeout = timeout con upstream; 429 Too Many Requests = específicamente para rate limiting (RFC 6585). IMPORTANTE: 503 es TEMPORAL - el servidor espera recuperarse. El header Retry-After es CRUCIAL - indica cuándo reintentar (en segundos o fecha HTTP). Causas comunes: (1) Sobrecarga - demasiadas conexiones concurrentes, CPU/RAM agotada; (2) Mantenimiento programado - deploys, migraciones, backups; (3) Warmup - servidor iniciándose; (4) Rate limiting - límites excedidos; (5) Queue llena - cola de procesamiento saturada; (6) Circuit breaker abierto - dependencias críticas caídas; (7) Degradación elegante - rechazar nuevas solicitudes para completar las actuales. Best practices: (1) SIEMPRE incluir Retry-After header; (2) Devolver JSON descriptivo con detalles; (3) Implementar graceful degradation; (4) Usar limit_conn y limit_req en nginx; (5) Monitorear 503s por causa (sobrecarga vs mantenimiento); (6) Implementar health checks; (7) Auto-scaling basado en métricas; (8) Circuit breakers para dependencias. Clientes DEBEN: respetar Retry-After, implementar exponential backoff, mostrar mensajes claros al usuario, usar datos en caché cuando sea posible. nginx configuración: limit_conn_zone, limit_req_zone, limit_conn_status 503, error_page 503. Monitoreo: trackear tasa de 503s, duración de periodos de sobrecarga, efectividad de rate limiting, correlación con picos de tráfico o deploys. 503 vs 429: usar 429 específicamente para rate limiting (más semántico), 503 para sobrecarga general y mantenimiento.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768880546/503_cap7p3.png",
                "alt": "Imagen que representa el nombre del código 503 Service Unavailable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768880351/66-removebg-preview_mbhk3w.png",
                "alt": "Imagen del código 503 Service Unavailable"
            }
        ]
    },
    {
        "code": 504,
        "status": "Gateway Timeout",
        "category": "Server Error",
        "description": "El código 504 Gateway Timeout es un código de estado HTTP estándar que indica que un servidor actuando como gateway o proxy no recibió una respuesta a tiempo del servidor upstream que necesitaba acceder para completar la solicitud. El servidor proxy/gateway está diciendo: 'Me conecté exitosamente al servidor backend, pero no me envió una respuesta dentro del tiempo límite permitido'. Es importante entender que el 504 NO significa que el servidor upstream esté caído - la conexión TCP se estableció correctamente, pero el upstream está tardando demasiado en procesar la solicitud y enviar la respuesta. A diferencia del 502 Bad Gateway (donde la conexión falla o la respuesta es inválida), el 504 específicamente indica un problema de TIMEOUT durante la espera de la respuesta. Las causas más comunes incluyen: procesamiento de backend excesivamente lento (queries complejas, cálculos pesados), servidor upstream sobrecargado procesando otras solicitudes, timeout configurado demasiado corto para operaciones largas, problemas de red causando latencia alta entre proxy y backend, servidor upstream bloqueado esperando recursos (DB locks, I/O), o deadlocks en el backend. El código 504 es muy común en arquitecturas con reverse proxies (nginx, Apache), load balancers, API gateways, y CDNs. Un 504 indica que el problema está en el tiempo de procesamiento del backend - o el backend es muy lento, o los timeouts están mal configurados. Los clientes pueden reintentar, pero si el backend realmente está lento, el reintento probablemente resultará en otro 504. Monitorear 504s es crítico para identificar cuellos de botella de rendimiento y optimizar tiempos de procesamiento.",
        "useCases": [
            "Backend tarda demasiado procesando solicitud (excede timeout)",
            "Query de base de datos extremadamente lenta o bloqueada",
            "Procesamiento pesado (análisis, generación de reportes, ML inference)",
            "Backend esperando respuesta de servicio externo lento",
            "Timeout configurado demasiado corto para operación legítima",
            "Deadlock o resource contention en backend",
            "Red lenta o con alta latencia entre proxy y backend",
            "Backend procesando pero no enviando respuesta incremental"
        ],
        "examples": [
            {
                "scenario": "Query de base de datos extremadamente lenta",
                "request": "GET /api/reports/annual?year=2023&detail=full HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_abc\nAccept: application/json",
                "response": "HTTP/1.1 504 Gateway Timeout\nDate: Wed, 17 Jan 2024 14:35:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/html\nContent-Length: 183\n\n<html>\n<head><title>504 Gateway Timeout</title></head>\n<body>\n<center><h1>504 Gateway Timeout</h1></center>\n<center>The server did not respond in time.</center>\n</body>\n</html>\n\nConfiguración nginx:\n\nupstream api_backend {\n    server backend1.internal:8080;\n    server backend2.internal:8080;\n    keepalive 32;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n    \n    location /api/reports/ {\n        proxy_pass http://api_backend;\n        \n        # TIMEOUTS CRÍTICOS\n        proxy_connect_timeout 5s;   # Tiempo para establecer conexión TCP\n        proxy_send_timeout 10s;     # Tiempo para enviar request al backend\n        proxy_read_timeout 60s;     # Tiempo para recibir respuesta del backend\n        \n        # Si excede proxy_read_timeout → 504 Gateway Timeout\n        \n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n\nEscenario: Query lenta en el backend\n\nTimeline de la solicitud:\n\n14:34:00.000 - Cliente envía GET /api/reports/annual\n14:34:00.050 - nginx recibe request\n14:34:00.100 - nginx conecta a backend1:8080 (SUCCESS - conexión establecida)\n14:34:00.150 - nginx envía request completo al backend\n14:34:00.200 - Backend recibe request y comienza procesamiento\n14:34:00.300 - Backend ejecuta query SQL:\n\nSELECT \n    t.id, t.date, t.amount, t.category, t.description,\n    c.name, c.email, c.address,\n    p.name as product_name, p.price, p.details,\n    u.username, u.department\nFROM transactions t\nJOIN customers c ON t.customer_id = c.id\nJOIN products p ON t.product_id = p.id\nJOIN users u ON t.user_id = u.id\nWHERE YEAR(t.date) = 2023\nORDER BY t.date DESC;\n\n-- Query procesa 5 millones de registros\n-- Múltiples JOINs sin índices apropiados\n-- ORDER BY en columna no indexada\n-- Toma 90 segundos en completar\n\n14:34:01 - Backend procesando... (SQL query ejecutando)\n14:34:10 - Backend procesando... (30% completado)\n14:34:20 - Backend procesando... (50% completado)\n14:34:30 - Backend procesando... (70% completado)\n14:34:40 - Backend procesando... (85% completado)\n14:34:50 - Backend procesando... (95% completado)\n14:35:00 - ⏱️ TIMEOUT (60 segundos - proxy_read_timeout alcanzado)\n14:35:00 - nginx cierra conexión con backend\n14:35:00 - nginx devuelve 504 Gateway Timeout al cliente\n14:35:30 - Backend finalmente termina query (pero cliente ya se fue)\n\nLog de nginx:\n\n[2024-01-17 14:35:00] [error] upstream timed out (110: Connection timed out) while reading response header from upstream, client: 203.0.113.25, server: api.example.com, request: \"GET /api/reports/annual?year=2023&detail=full HTTP/1.1\", upstream: \"http://backend1.internal:8080/api/reports/annual?year=2023&detail=full\", host: \"api.example.com\"\n\nSOLUCIONES:\n\n1. Optimizar query SQL:\n\n-- Añadir índices apropiados\nCREATE INDEX idx_transactions_date ON transactions(date);\nCREATE INDEX idx_transactions_year ON transactions((YEAR(date)));\nCREATE INDEX idx_transactions_customer ON transactions(customer_id);\n\n-- Query optimizada\nSELECT \n    t.id, t.date, t.amount, t.category,\n    c.name as customer_name,\n    p.name as product_name\nFROM transactions t\nINNER JOIN customers c ON t.customer_id = c.id\nINNER JOIN products p ON t.product_id = p.id\nWHERE t.date >= '2023-01-01' AND t.date < '2024-01-01'\nORDER BY t.date DESC\nLIMIT 1000 OFFSET 0;\n\n-- Tiempo reducido de 90s → 2s\n\n2. Implementar paginación:\n\napp.get('/api/reports/annual', async (req, res) => {\n    const year = req.query.year;\n    const page = parseInt(req.query.page) || 1;\n    const pageSize = parseInt(req.query.pageSize) || 100;\n    const offset = (page - 1) * pageSize;\n    \n    const results = await db.query(`\n        SELECT ... \n        FROM transactions t\n        WHERE YEAR(t.date) = ?\n        ORDER BY t.date DESC\n        LIMIT ? OFFSET ?\n    `, [year, pageSize, offset]);\n    \n    res.json({\n        data: results,\n        pagination: { page, pageSize, total }\n    });\n});\n\n3. Aumentar timeout para operaciones largas:\n\nserver {\n    location /api/reports/ {\n        proxy_pass http://api_backend;\n        proxy_read_timeout 120s;  # 2 minutos para reportes\n    }\n}",
                "explanation": "El cliente solicita un reporte anual que requiere procesar 5 millones de registros con múltiples JOINs complejos. El backend ejecuta una query SQL no optimizada que tarda 90 segundos. nginx está configurado con proxy_read_timeout de 60 segundos. La conexión TCP se establece correctamente, el backend recibe el request y comienza a procesar, pero después de 60 segundos sin recibir ninguna respuesta, nginx alcanza el timeout y devuelve 504 Gateway Timeout al cliente. El backend continúa procesando y finalmente termina después de 90 segundos, pero el cliente ya se desconectó. Las soluciones incluyen: optimizar la query con índices apropiados, implementar paginación, o aumentar timeouts para operaciones legítimas largas."
            },
            {
                "scenario": "Backend bloqueado esperando servicio externo",
                "request": "POST /api/payment/process HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"amount\": 99.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_visa_4242\"\n}",
                "response": "HTTP/1.1 504 Gateway Timeout\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nContent-Length: 145\n\n{\n  \"error\": \"Gateway Timeout\",\n  \"message\": \"Payment processing timed out\",\n  \"request_id\": \"req_abc123\",\n  \"support\": \"Contact support@example.com\"\n}\n\nCódigo del backend (Node.js):\n\napp.post('/api/payment/process', async (req, res) => {\n    const { amount, currency, card_token } = req.body;\n    const requestId = generateRequestId();\n    \n    try {\n        // Llamar a API externa de procesamiento de pagos\n        const paymentResult = await fetch('https://api.payment-provider.com/v1/charges', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${PAYMENT_API_KEY}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                amount: amount * 100,\n                currency,\n                source: card_token\n            })\n            // PROBLEMA: Sin timeout configurado\n        });\n        \n        const result = await paymentResult.json();\n        res.json({ status: 'success', transaction_id: result.id });\n        \n    } catch (error) {\n        res.status(500).json({ error: 'Payment processing failed' });\n    }\n});\n\nTimeline:\n\n15:44:00 - Cliente envía POST /api/payment/process\n15:44:00 - nginx conecta a backend (OK)\n15:44:00 - Backend recibe request\n15:44:01 - Backend llama a api.payment-provider.com\n15:44:02 - API externa recibe request\n15:44:30 - ⏱️ TIMEOUT nginx (30s alcanzado)\n15:44:30 - nginx devuelve 504 al cliente\n15:44:35 - API externa responde (pero cliente ya se fue)\n\nSOLUCIÓN - Implementar timeout en llamadas externas:\n\nconst { AbortController } = require('node-abort-controller');\n\napp.post('/api/payment/process', async (req, res) => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 25000);\n    \n    try {\n        const paymentResult = await fetch('https://api.payment-provider.com/v1/charges', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${PAYMENT_API_KEY}`,\n                'Idempotency-Key': requestId\n            },\n            body: JSON.stringify({ amount: amount * 100, currency, source: card_token }),\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        const result = await paymentResult.json();\n        res.json({ status: 'success', transaction_id: result.id });\n        \n    } catch (error) {\n        if (error.name === 'AbortError') {\n            return res.status(504).json({\n                error: 'Gateway Timeout',\n                message: 'Payment processing timed out',\n                request_id: requestId\n            });\n        }\n        res.status(500).json({ error: 'Payment failed' });\n    }\n});",
                "explanation": "El backend procesa un pago llamando a una API externa que está lenta y tarda 35 segundos en responder. nginx tiene configurado proxy_read_timeout de 30 segundos. Después de 30 segundos sin recibir respuesta del backend, nginx alcanza el timeout y devuelve 504 Gateway Timeout al cliente. El backend continúa esperando la respuesta de la API externa, que finalmente llega, pero el cliente ya se desconectó. Esto crea un problema crítico: el cliente cree que el pago falló, pero puede haberse procesado exitosamente. La solución es implementar timeouts en llamadas a APIs externas (menor que el timeout de nginx) y usar claves de idempotencia para prevenir cargos duplicados."
            },
            {
                "scenario": "Timeout configurado demasiado corto para operación legítima",
                "request": "POST /api/video/transcode HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"video_id\": \"vid_4k_1080p\",\n  \"output_format\": \"mp4\",\n  \"resolution\": \"1080p\"\n}",
                "response": "HTTP/1.1 504 Gateway Timeout\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nContent-Length: 178\n\n{\n  \"error\": \"Gateway Timeout\",\n  \"message\": \"Video transcoding timed out\",\n  \"request_id\": \"req_xyz789\",\n  \"suggestion\": \"Use async API for long-running operations\"\n}\n\nConfiguración nginx (INCORRECTA):\n\nserver {\n    location /api/ {\n        proxy_pass http://backend;\n        proxy_read_timeout 30s;  # ❌ 30s para TODO\n    }\n}\n\nTimeline:\n\n16:29:30 - Cliente solicita transcodificación video 4K\n16:29:30 - Backend inicia FFmpeg\n16:30:00 - ⏱️ TIMEOUT nginx (30s)\n16:30:00 - nginx devuelve 504\n16:38:00 - Transcodificación completa (8.5 minutos)\n\nSOLUCIONES:\n\n1. Timeouts diferenciados:\n\nserver {\n    location /api/ {\n        proxy_read_timeout 30s;\n    }\n    \n    location /api/video/transcode {\n        proxy_read_timeout 600s;  # 10 minutos\n    }\n}\n\n2. API asíncrona (RECOMENDADO):\n\napp.post('/api/video/transcode/start', async (req, res) => {\n    const jobId = generateUUID();\n    await transcodeQueue.add({ jobId, ...req.body });\n    \n    res.status(202).json({\n        job_id: jobId,\n        status_url: `/api/video/status/${jobId}`\n    });\n});\n\napp.get('/api/video/status/:jobId', async (req, res) => {\n    const job = await transcodeQueue.getJob(req.params.jobId);\n    const state = await job.getState();\n    \n    res.json({\n        status: state,\n        progress: job.progress()\n    });\n});",
                "explanation": "El cliente solicita transcodificar un video 4K a 1080p, operación que legítimamente toma 5-10 minutos. nginx está configurado con proxy_read_timeout de solo 30 segundos para TODOS los endpoints. El backend inicia FFmpeg y comienza la transcodificación, pero después de 30 segundos, nginx alcanza el timeout y devuelve 504, aunque la transcodificación está progresando normalmente. Las soluciones incluyen: configurar timeouts diferenciados por tipo de operación, o preferiblemente, implementar API asíncrona donde el cliente inicia el job y hace polling del estado."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.5",
        "relatedHeaders": [
            "Retry-After"
        ],
        "relatedCodes": [
            408,
            502,
            503
        ],
        "technicalNotes": "El código 504 indica específicamente que un gateway/proxy no recibió respuesta a tiempo del upstream. Diferencias críticas: 504 Gateway Timeout = proxy conectó OK pero backend no respondió a tiempo; 502 Bad Gateway = proxy no pudo conectar o recibió respuesta inválida; 503 Service Unavailable = servidor temporalmente sobrecargado; 408 Request Timeout = cliente tardó demasiado enviando request. IMPORTANTE: En 504, la conexión TCP se estableció correctamente - el problema es que el backend está tardando demasiado en procesar y responder. Causas comunes: (1) Backend procesando operación lenta (queries complejas, cálculos pesados); (2) Backend bloqueado esperando recurso externo (API, base de datos); (3) Timeout configurado muy corto para operación legítima; (4) Deadlocks o resource contention en backend; (5) Red lenta entre proxy y backend. nginx timeouts relevantes: proxy_connect_timeout (establecer conexión), proxy_send_timeout (enviar request), proxy_read_timeout (recibir respuesta - este causa 504). Apache: ProxyTimeout. Best practices: (1) Configurar timeouts diferenciados por tipo de operación; (2) Implementar APIs asíncronas para operaciones largas (job queue + polling); (3) Optimizar procesamiento lento (índices DB, caching); (4) Timeouts en llamadas a servicios externos (menor que proxy timeout); (5) Monitorear tiempos de respuesta por endpoint; (6) Usar claves de idempotencia para operaciones críticas; (7) Circuit breakers para dependencias externas. Cliente debe: NO reintentar automáticamente operaciones no idempotentes (pagos, órdenes), implementar polling para operaciones asíncronas, usar timeouts razonables. 504 indica problema de RENDIMIENTO que debe investigarse - no es normal en operaciones bien diseñadas.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768880543/504_hckv39.png",
                "alt": "Imagen que representa el nombre del código 504 Gateway Timeout"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768880348/67-removebg-preview_gmpnmq.png",
                "alt": "Imagen del código 504 Gateway Timeout"
            }
        ]
    },
    {
        "code": 505,
        "status": "HTTP Version Not Supported",
        "category": "Server Error",
        "description": "El código 505 HTTP Version Not Supported es un código de estado HTTP estándar que indica que el servidor no soporta o se niega a soportar la versión del protocolo HTTP que fue usada en la solicitud. El servidor está diciendo: 'Entiendo que es una solicitud HTTP, pero la versión específica del protocolo que estás usando no la soporto'. Es importante entender que el 505 NO significa que la solicitud esté mal formada - el problema es específicamente con la versión de HTTP declarada en la línea de solicitud (HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3). A diferencia de errores como 400 Bad Request (solicitud mal formada) o 501 Not Implemented (método no implementado), el 505 es específico para incompatibilidad de versiones del protocolo HTTP. Las causas más comunes incluyen: cliente intentando usar HTTP/2 o HTTP/3 en servidor que solo soporta HTTP/1.1, servidor legacy que no reconoce versiones modernas de HTTP, versión HTTP mal formada o no estándar en la línea de solicitud, proxy o gateway que no soporta la versión solicitada, o configuración del servidor limitando versiones permitidas. El código 505 es relativamente raro en la práctica moderna porque la mayoría de servidores soportan múltiples versiones de HTTP y los clientes típicamente negocian la versión automáticamente. Sin embargo, puede aparecer en: servidores muy antiguos, proxies legacy, configuraciones de seguridad restrictivas, o cuando se usa HTTP/3 (QUIC) en infraestructura que no lo soporta. Los clientes que reciben 505 deben hacer downgrade a una versión anterior de HTTP (típicamente HTTP/1.1) y reintentar.",
        "useCases": [
            "Cliente solicita HTTP/2 en servidor que solo soporta HTTP/1.1",
            "Cliente solicita HTTP/3 en servidor sin soporte QUIC",
            "Versión HTTP mal formada o no estándar en request line",
            "Servidor legacy que no reconoce HTTP/1.1 o superior",
            "Proxy que no puede manejar versión HTTP solicitada",
            "Configuración de servidor bloqueando versiones específicas",
            "Cliente especifica versión futura o experimental no soportada"
        ],
        "examples": [
            {
                "scenario": "Cliente HTTP/2 conectando a servidor HTTP/1.1 only",
                "request": "GET /api/data HTTP/2.0\nHost: legacy.example.com\nUser-Agent: ModernBrowser/1.0\nAccept: application/json",
                "response": "HTTP/1.1 505 HTTP Version Not Supported\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: Apache/2.2.15\nContent-Type: text/html\nContent-Length: 245\n\n<html>\n<head><title>505 HTTP Version Not Supported</title></head>\n<body>\n<h1>505 HTTP Version Not Supported</h1>\n<p>The server does not support HTTP/2.0</p>\n<p>Supported versions: HTTP/1.0, HTTP/1.1</p>\n<p>Please use HTTP/1.1 and retry your request.</p>\n</body>\n</html>\n\nConfiguración del servidor (Apache 2.2 legacy):\n\n# Apache 2.2 (2005-2013) - NO soporta HTTP/2\n# HTTP/2 requiere Apache 2.4.17+ con mod_http2\n\n<VirtualHost *:80>\n    ServerName legacy.example.com\n    DocumentRoot /var/www/legacy\n    \n    # Apache 2.2 solo soporta:\n    # - HTTP/1.0 (RFC 1945)\n    # - HTTP/1.1 (RFC 2616)\n    \n    # Si cliente solicita HTTP/2.0 → 505\n    \n    <Directory /var/www/legacy>\n        Options Indexes FollowSymLinks\n        AllowOverride None\n        Order allow,deny\n        Allow from all\n    </Directory>\n</VirtualHost>\n\nContexto técnico:\n\nHTTP/2.0 características NO disponibles en servidor legacy:\n- Multiplexing (múltiples requests en una conexión)\n- Server Push\n- Header compression (HPACK)\n- Binary protocol (vs texto en HTTP/1.1)\n- Stream prioritization\n\nEscenario:\n\nCliente (navegador moderno) intenta conectar:\n1. Cliente detecta soporte TLS/SSL\n2. Durante TLS handshake, cliente anuncia soporte HTTP/2 vía ALPN\n3. Servidor NO tiene HTTP/2 → negocia HTTP/1.1\n4. Pero si cliente fuerza HTTP/2.0 en request line → 505\n\nTimeline:\n\n14:30:00 - Cliente intenta HTTP/2\n14:30:00 - Servidor recibe \"GET /api/data HTTP/2.0\"\n14:30:00 - Servidor no reconoce HTTP/2.0\n14:30:00 - Servidor devuelve 505 HTTP Version Not Supported\n14:30:01 - Cliente hace downgrade a HTTP/1.1\n14:30:01 - Cliente reintenta: \"GET /api/data HTTP/1.1\"\n14:30:01 - Servidor procesa exitosamente → 200 OK\n\nLog del servidor:\n\n[Wed Jan 17 14:30:00 2024] [error] [client 203.0.113.10] Unsupported HTTP version: HTTP/2.0\n[Wed Jan 17 14:30:00 2024] [error] [client 203.0.113.10] Supported versions: HTTP/1.0, HTTP/1.1\n\nSOLUCIONES:\n\n1. Actualizar servidor para soportar HTTP/2:\n\n# Apache 2.4.17+ con mod_http2\n<VirtualHost *:443>\n    ServerName modern.example.com\n    \n    # Habilitar HTTP/2\n    Protocols h2 h2c http/1.1\n    # h2 = HTTP/2 sobre TLS\n    # h2c = HTTP/2 en texto plano (cleartext)\n    # http/1.1 = fallback\n    \n    # Requiere TLS para HTTP/2\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/server.crt\n    SSLCertificateKeyFile /etc/ssl/private/server.key\n    \n    # Configuración HTTP/2\n    H2Direct on\n    H2Push on\n    H2PushPriority * after\n    H2MaxSessionStreams 100\n    \n    DocumentRoot /var/www/modern\n</VirtualHost>\n\n# nginx con HTTP/2\nserver {\n    listen 443 ssl http2;  # HTTP/2 habilitado\n    server_name modern.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    \n    location / {\n        root /var/www/modern;\n    }\n}\n\n2. Cliente con fallback automático:\n\n// JavaScript - Fetch API automáticamente hace downgrade\nfetch('https://legacy.example.com/api/data')\n    .then(response => {\n        // Navegador automáticamente negocia versión HTTP\n        // Si servidor no soporta HTTP/2 → usa HTTP/1.1\n        return response.json();\n    })\n    .catch(error => {\n        console.error('Request failed:', error);\n    });\n\n// cURL - Especificar versión HTTP\n# Forzar HTTP/1.1\ncurl --http1.1 https://legacy.example.com/api/data\n\n# Intentar HTTP/2, fallback a HTTP/1.1\ncurl --http2 https://legacy.example.com/api/data\n\n# Solo HTTP/2, fallar si no está disponible\ncurl --http2-prior-knowledge https://legacy.example.com/api/data\n\n3. Proxy con traducción de versiones:\n\n# nginx como proxy con downgrade HTTP/2 → HTTP/1.1\nserver {\n    listen 443 ssl http2;  # Acepta HTTP/2 de clientes\n    server_name proxy.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/proxy.crt;\n    ssl_certificate_key /etc/nginx/ssl/proxy.key;\n    \n    location / {\n        # Proxy a backend que solo soporta HTTP/1.1\n        proxy_pass http://legacy_backend;\n        proxy_http_version 1.1;  # Forzar HTTP/1.1 al backend\n        \n        # Cliente usa HTTP/2 con proxy\n        # Proxy usa HTTP/1.1 con backend\n        # Transparent para ambos\n        \n        proxy_set_header Host $host;\n        proxy_set_header Connection \"\";\n    }\n}\n\nupstream legacy_backend {\n    # Servidor legacy HTTP/1.1 only\n    server legacy.internal:80;\n    keepalive 32;\n}",
                "explanation": "Un cliente moderno intenta conectar a un servidor legacy (Apache 2.2) usando HTTP/2.0. El servidor no tiene soporte para HTTP/2 (requiere Apache 2.4.17+) y devuelve 505 HTTP Version Not Supported, indicando que solo soporta HTTP/1.0 y HTTP/1.1. El cliente inteligente detecta el 505, hace downgrade a HTTP/1.1, y reintenta exitosamente. Las soluciones incluyen: actualizar el servidor para soportar HTTP/2, que los clientes implementen fallback automático (la mayoría de navegadores y librerías ya lo hacen), o usar un proxy moderno que acepte HTTP/2 de clientes pero traduzca a HTTP/1.1 para backends legacy."
            },
            {
                "scenario": "Versión HTTP mal formada o no estándar",
                "request": "GET /api/data HTTP/3.0\nHost: api.example.com\nUser-Agent: CustomClient/1.0\nAccept: application/json\n\n[Cliente especifica HTTP/3.0 pero sobre conexión TCP en lugar de QUIC]",
                "response": "HTTP/1.1 505 HTTP Version Not Supported\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nContent-Length: 198\n\n{\n  \"error\": \"HTTP Version Not Supported\",\n  \"message\": \"HTTP/3.0 is not supported on this endpoint\",\n  \"supported_versions\": [\"HTTP/1.0\", \"HTTP/1.1\", \"HTTP/2.0\"],\n  \"note\": \"HTTP/3 requires QUIC protocol\"\n}\n\nConfiguración nginx:\n\nserver {\n    listen 80;\n    listen 443 ssl http2;  # HTTP/1.1 y HTTP/2 sobre TLS\n    server_name api.example.com;\n    \n    # HTTP/3 requiere configuración separada con QUIC\n    # listen 443 quic reuseport;  # No configurado\n    \n    ssl_certificate /etc/nginx/ssl/api.crt;\n    ssl_certificate_key /etc/nginx/ssl/api.key;\n    \n    location / {\n        # Solo HTTP/1.0, HTTP/1.1, HTTP/2 soportados\n        # HTTP/3 NO está habilitado\n        \n        proxy_pass http://backend;\n    }\n}\n\nProblemas con HTTP/3:\n\n1. HTTP/3 usa QUIC (sobre UDP), no TCP:\n   - HTTP/1.1 y HTTP/2 → TCP\n   - HTTP/3 → UDP (puerto 443)\n   - No se puede mezclar\n\n2. Requiere configuración específica:\n   - Compilar nginx con soporte QUIC\n   - Abrir puerto UDP 443\n   - Configurar Alt-Svc header\n\n3. Cliente debe descubrir soporte HTTP/3:\n   - Primera conexión: HTTP/1.1 o HTTP/2\n   - Servidor envía: Alt-Svc: h3=\":443\"\n   - Conexiones futuras: cliente intenta HTTP/3\n\nOtros casos de versiones mal formadas:\n\n# Versión completamente inválida\nGET /api/data HTTP/99.9  ❌\n→ 505 HTTP Version Not Supported\n\n# Formato incorrecto\nGET /api/data HTTPS/1.1  ❌\n→ 400 Bad Request (no 505)\n\n# Versión experimental\nGET /api/data HTTP/4.0  ❌\n→ 505 HTTP Version Not Supported\n\nSOLUCIÓN - Habilitar HTTP/3:\n\n# nginx compilado con soporte QUIC\nserver {\n    # HTTP/1.1 y HTTP/2 sobre TCP\n    listen 443 ssl http2;\n    \n    # HTTP/3 sobre QUIC (UDP)\n    listen 443 quic reuseport;\n    \n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/api.crt;\n    ssl_certificate_key /etc/nginx/ssl/api.key;\n    \n    # Anunciar soporte HTTP/3 a clientes\n    add_header Alt-Svc 'h3=\":443\"; ma=86400';\n    \n    # Configuración QUIC\n    ssl_early_data on;\n    quic_retry on;\n    \n    location / {\n        proxy_pass http://backend;\n    }\n}\n\nCliente detectando y usando HTTP/3:\n\n// Primera conexión (HTTP/2)\nconst response1 = await fetch('https://api.example.com/api/data');\n\n// Servidor responde con:\n// Alt-Svc: h3=\":443\"; ma=86400\n\n// Cliente almacena esta información\n\n// Conexiones futuras (HTTP/3 si está disponible)\nconst response2 = await fetch('https://api.example.com/api/data');\n// Navegador automáticamente intenta HTTP/3 sobre QUIC\n// Si falla, hace fallback a HTTP/2",
                "explanation": "Un cliente personalizado intenta usar HTTP/3.0 pero lo hace sobre una conexión TCP estándar. HTTP/3 requiere QUIC (protocolo sobre UDP), no TCP. El servidor recibe la solicitud con versión HTTP/3.0 pero no tiene habilitado soporte QUIC/HTTP3, por lo que devuelve 505 HTTP Version Not Supported, indicando que solo soporta HTTP/1.0, HTTP/1.1 y HTTP/2.0. Para soportar HTTP/3 correctamente, el servidor necesita: compilarse con soporte QUIC, configurar listeners UDP en puerto 443, y anunciar disponibilidad HTTP/3 via header Alt-Svc. Los clientes deben descubrir HTTP/3 a través de Alt-Svc en lugar de asumirlo directamente."
            },
            {
                "scenario": "Configuración de seguridad bloqueando versiones antiguas",
                "request": "GET /api/secure/data HTTP/1.0\nHost: secure.example.com\nAuthorization: Bearer token_abc\nAccept: application/json",
                "response": "HTTP/1.1 505 HTTP Version Not Supported\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: SecureProxy/1.0\nContent-Type: application/json\nContent-Length: 187\n\n{\n  \"error\": \"HTTP Version Not Supported\",\n  \"message\": \"HTTP/1.0 is not allowed for security reasons\",\n  \"required_version\": \"HTTP/1.1 or higher\",\n  \"reason\": \"HTTP/1.0 lacks required security features\"\n}\n\nConfiguración nginx bloqueando HTTP/1.0:\n\nserver {\n    listen 443 ssl http2;\n    server_name secure.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/secure.crt;\n    ssl_certificate_key /etc/nginx/ssl/secure.key;\n    \n    # Configuración de seguridad estricta\n    ssl_protocols TLSv1.2 TLSv1.3;  # Solo TLS moderno\n    ssl_prefer_server_ciphers on;\n    \n    location / {\n        # Bloquear HTTP/1.0 por razones de seguridad\n        if ($server_protocol = \"HTTP/1.0\") {\n            return 505 '{\"error\":\"HTTP Version Not Supported\",\"message\":\"HTTP/1.0 not allowed\"}';\n        }\n        \n        # Solo permitir HTTP/1.1 y HTTP/2\n        proxy_pass http://backend;\n    }\n}\n\nRazones para bloquear HTTP/1.0:\n\n1. Falta de Host header (opcional en HTTP/1.0):\n   - Problemas con virtual hosting\n   - Vulnerabilidades de seguridad\n\n2. Sin soporte para chunked transfer encoding:\n   - No puede manejar respuestas de tamaño desconocido\n   - Requiere Content-Length siempre\n\n3. Sin persistent connections por defecto:\n   - Connection: keep-alive es extensión\n   - Rendimiento pobre\n\n4. Sin soporte para caching apropiado:\n   - Cache-Control no existe en HTTP/1.0\n   - Solo Pragma y Expires\n\n5. Vulnerabilidades conocidas:\n   - HTTP Request Smuggling más fácil\n   - Menor resistencia a ataques\n\nAlternativa - nginx con validación estricta:\n\nmap $server_protocol $allowed_protocol {\n    default 0;\n    \"HTTP/1.1\" 1;\n    \"HTTP/2.0\" 1;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name secure.example.com;\n    \n    location / {\n        # Verificar versión permitida\n        if ($allowed_protocol = 0) {\n            return 505;\n        }\n        \n        proxy_pass http://backend;\n    }\n}\n\nCliente debe usar versión moderna:\n\n# cURL - Forzar HTTP/1.1 o superior\ncurl --http1.1 https://secure.example.com/api/data\ncurl --http2 https://secure.example.com/api/data\n\n# Python requests (usa HTTP/1.1 por defecto)\nimport requests\nresponse = requests.get('https://secure.example.com/api/data')\n\n# Si recibe 505, actualizar cliente\ntry:\n    response = requests.get('https://secure.example.com/api/data')\n    response.raise_for_status()\nexcept requests.HTTPError as e:\n    if e.response.status_code == 505:\n        print('HTTP version not supported. Update your client.')\n        # Asegurar que requests usa HTTP/1.1+\n        # requests siempre usa HTTP/1.1 mínimo",
                "explanation": "Un cliente antiguo intenta conectar usando HTTP/1.0 a un servidor con políticas de seguridad estrictas. El servidor está configurado para bloquear HTTP/1.0 porque carece de características de seguridad importantes (Host header obligatorio, soporte chunked encoding, mejor caching). El servidor devuelve 505 HTTP Version Not Supported indicando que requiere HTTP/1.1 o superior. Esto es común en APIs modernas que priorizan seguridad sobre compatibilidad con clientes muy antiguos. El cliente debe actualizar para usar al menos HTTP/1.1."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.6.6",
        "relatedHeaders": [
            "Alt-Svc"
        ],
        "relatedCodes": [
            400,
            426,
            501
        ],
        "technicalNotes": "El código 505 indica específicamente que el servidor no soporta la versión HTTP usada en la solicitud. Diferencias críticas: 505 HTTP Version Not Supported = versión HTTP no soportada; 501 Not Implemented = método HTTP no implementado; 426 Upgrade Required = cliente debe cambiar a protocolo diferente (WebSocket, TLS); 400 Bad Request = request mal formado (incluyendo línea de solicitud inválida). Versiones HTTP existentes: HTTP/0.9 (1991, obsoleto), HTTP/1.0 (1996, RFC 1945), HTTP/1.1 (1997, RFC 2616/7230-7235), HTTP/2 (2015, RFC 7540), HTTP/3 (2022, RFC 9114). IMPORTANTE: La mayoría de servidores modernos soportan múltiples versiones y negocian automáticamente. HTTP/2 requiere: TLS (generalmente), ALPN para negociación, servidor con soporte habilitado. HTTP/3 requiere: QUIC protocol (UDP, no TCP), configuración específica, discovery via Alt-Svc header. Causas de 505: (1) Servidor legacy sin HTTP/2/HTTP/3; (2) Cliente especifica versión no soportada; (3) Políticas de seguridad bloqueando versiones antiguas; (4) Versión mal formada en request line; (5) HTTP/3 sin soporte QUIC. Best practices: Servidores deben soportar al menos HTTP/1.1 y HTTP/2, clientes deben implementar fallback automático, usar ALPN para negociación de versión en TLS, anunciar HTTP/3 via Alt-Svc, nunca asumir versión sin negociación. Debugging: verificar versión en request line, revisar soporte del servidor (nginx: listen 443 ssl http2), verificar ALPN durante TLS handshake, confirmar que HTTP/3 usa QUIC no TCP. Cliente debe: hacer downgrade automático si recibe 505, preferir versiones modernas pero soportar fallback, respetar Alt-Svc para HTTP/3 discovery. 505 es RARO en práctica moderna - la mayoría de infraestructura negocia versiones automáticamente.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768880541/505_dl0gcv.png",
                "alt": "Imagen que representa el nombre del código 505 HTTP Version Not Supported"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768880346/68-removebg-preview_zrshf3.png",
                "alt": "Imagen del código 505 HTTP Version Not Supported"
            }
        ]
    },
    {
        "code": 506,
        "status": "Variant Also Negotiates",
        "category": "Server Error",
        "description": "El código 506 Variant Also Negotiates es un código de estado HTTP estándar que indica que el servidor tiene un error de configuración interno relacionado con la negociación de contenido (content negotiation). El servidor está diciendo: 'Detecté un problema circular o recursivo en mi configuración de negociación de contenido que me impide seleccionar la variante apropiada para responder'. Es importante entender que el 506 NO es un error del cliente - es un error de CONFIGURACIÓN del servidor. Este código es extremadamente raro en la práctica y ocurre cuando el servidor está configurado con Transparent Content Negotiation (TCN) y detecta que la negociación entraría en un ciclo infinito o referencia circular. Las causas incluyen: configuración circular de variantes (variante A apunta a variante B que apunta de vuelta a A), negociador de contenido mal configurado que se referencia a sí mismo, conflictos en headers de negociación (Accept, Accept-Language, Accept-Encoding), o implementación incorrecta del protocolo TCN. El 506 es casi exclusivo de servidores con TCN habilitado (RFC 2295) - la mayoría de servidores modernos usan negociación simple sin TCN y nunca generan este código. Si recibes un 506, indica un problema serio de configuración del servidor que debe corregirse inmediatamente.",
        "useCases": [
            "Configuración circular de variantes de contenido",
            "Negociador TCN detecta referencia recursiva",
            "Variante apunta a sí misma en negociación",
            "Conflicto en configuración de content negotiation",
            "Implementación incorrecta de Transparent Content Negotiation",
            "Headers de negociación generan loop infinito"
        ],
        "examples": [
            {
                "scenario": "Configuración circular de variantes",
                "request": "GET /document HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAccept-Language: es, en\nAccept-Encoding: gzip",
                "response": "HTTP/1.1 506 Variant Also Negotiates\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: Apache/2.4.41\nContent-Type: text/html\nContent-Length: 234\n\n<html>\n<head><title>506 Variant Also Negotiates</title></head>\n<body>\n<h1>506 Variant Also Negotiates</h1>\n<p>The server has an internal configuration error.</p>\n<p>Circular variance detected in content negotiation.</p>\n</body>\n</html>\n\nConfiguración Apache con TCN (INCORRECTA):\n\n# httpd.conf\n<VirtualHost *:80>\n    ServerName api.example.com\n    \n    # Habilitar Transparent Content Negotiation\n    Options +MultiViews\n    \n    <Directory /var/www/api>\n        # PROBLEMA: Configuración circular\n        \n        # document.json → variante en español\n        <Files \"document.json\">\n            LanguagePriority es en\n            ForceLanguagePriority Prefer Fallback\n        </Files>\n        \n        # document.es.json apunta de vuelta a document.json\n        # Esto crea un ciclo: document.json → document.es.json → document.json\n        \n        # Apache detecta el ciclo → 506\n    </Directory>\n</VirtualHost>\n\nEstructura de archivos problemática:\n\n/var/www/api/\n├── document.json          # Variante base\n├── document.es.json       # Variante español (apunta a base)\n├── document.en.json       # Variante inglés\n└── .htaccess             # Configuración con error\n\n# .htaccess con configuración circular\nAddLanguage es .es\nAddLanguage en .en\n\n# PROBLEMA: Redirección circular\nRedirect /document.es.json /document.json\nRedirect /document.json /document.es.json\n\nTimeline:\n\n14:30:00 - Cliente solicita /document con Accept-Language: es\n14:30:00 - Servidor inicia content negotiation\n14:30:00 - Encuentra document.json (base)\n14:30:00 - Detecta variante española document.es.json\n14:30:00 - document.es.json tiene redirect a document.json\n14:30:00 - document.json tiene redirect a document.es.json\n14:30:00 - Servidor detecta ciclo infinito\n14:30:00 - Servidor aborta con 506 Variant Also Negotiates\n\nLog del servidor:\n\n[Wed Jan 17 14:30:00 2024] [error] [client 203.0.113.10] Negotiation: discovered variant negotiation loop for /document\n[Wed Jan 17 14:30:00 2024] [error] Circular reference detected: document.json <-> document.es.json\n\nSOLUCIÓN - Configuración correcta:\n\n# Estructura de archivos sin ciclos\n/var/www/api/\n├── document.json          # Variante base (inglés por defecto)\n├── document.es.json       # Variante español\n├── document.fr.json       # Variante francés\n└── .htaccess\n\n# .htaccess correcto\nOptions +MultiViews\nAddLanguage es .es\nAddLanguage en .json\nAddLanguage fr .fr\n\nLanguagePriority en es fr\nForceLanguagePriority Prefer Fallback\n\n# Sin redirects circulares\n# Cada variante es independiente\n\n# Comportamiento correcto:\n# Accept-Language: es → document.es.json\n# Accept-Language: en → document.json\n# Accept-Language: fr → document.fr.json",
                "explanation": "El servidor Apache está configurado con Transparent Content Negotiation y tiene una configuración circular: document.json redirige a document.es.json, que a su vez redirige de vuelta a document.json. Cuando el cliente solicita el recurso con Accept-Language: es, el servidor intenta negociar la variante apropiada, detecta el ciclo infinito, y devuelve 506 Variant Also Negotiates. La solución es eliminar los redirects circulares y tener cada variante como archivo independiente sin referencias cruzadas."
            },
            {
                "scenario": "TCN con configuración de variantes incorrecta",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAccept: application/json, application/xml\nTCN: list\nNegotiate: trans",
                "response": "HTTP/1.1 506 Variant Also Negotiates\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: CustomServer/1.0\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"error\": \"Variant Also Negotiates\",\n  \"message\": \"Content negotiation configuration error\",\n  \"detail\": \"Recursive variant reference detected\",\n  \"contact\": \"admin@example.com\"\n}\n\nConfiguración TCN problemática:\n\n// Server-side TCN implementation (Node.js)\nconst variants = {\n    'data.json': {\n        type: 'application/json',\n        language: 'en',\n        encoding: 'gzip',\n        alternates: ['data.xml']  // Apunta a data.xml\n    },\n    'data.xml': {\n        type: 'application/xml',\n        language: 'en',\n        encoding: 'gzip',\n        alternates: ['data.json']  // Apunta de vuelta a data.json ❌\n    }\n};\n\napp.get('/api/data', (req, res) => {\n    const accept = req.headers['accept'];\n    const tcn = req.headers['tcn'];\n    \n    if (tcn === 'list') {\n        // Transparent Content Negotiation habilitado\n        const selected = negotiateVariant(accept, variants);\n        \n        if (selected.circular) {\n            // Ciclo detectado\n            return res.status(506).json({\n                error: 'Variant Also Negotiates',\n                message: 'Content negotiation configuration error',\n                detail: 'Recursive variant reference detected'\n            });\n        }\n        \n        res.sendFile(selected.file);\n    }\n});\n\nfunction negotiateVariant(accept, variants) {\n    const visited = new Set();\n    let current = 'data.json';\n    \n    while (true) {\n        if (visited.has(current)) {\n            // Ciclo detectado\n            return { circular: true };\n        }\n        \n        visited.add(current);\n        const variant = variants[current];\n        \n        if (matchesAccept(variant.type, accept)) {\n            return { file: current };\n        }\n        \n        if (variant.alternates.length > 0) {\n            current = variant.alternates[0];\n        } else {\n            break;\n        }\n    }\n    \n    return { circular: true };\n}\n\nSOLUCIÓN - TCN sin ciclos:\n\nconst variants = {\n    'data.json': {\n        type: 'application/json',\n        language: 'en',\n        quality: 1.0,\n        alternates: []  // Sin referencias circulares\n    },\n    'data.xml': {\n        type: 'application/xml',\n        language: 'en',\n        quality: 0.9,\n        alternates: []  // Independiente\n    },\n    'data.yaml': {\n        type: 'application/x-yaml',\n        language: 'en',\n        quality: 0.8,\n        alternates: []\n    }\n};\n\napp.get('/api/data', (req, res) => {\n    const accept = req.headers['accept'];\n    \n    // Negociación simple basada en calidad\n    const selected = Object.entries(variants)\n        .filter(([_, v]) => matchesAccept(v.type, accept))\n        .sort((a, b) => b[1].quality - a[1].quality)[0];\n    \n    if (selected) {\n        res.type(selected[1].type);\n        res.sendFile(selected[0]);\n    } else {\n        res.status(406).send('Not Acceptable');\n    }\n});",
                "explanation": "Un servidor implementa Transparent Content Negotiation (TCN) con variantes que se referencian mutuamente: data.json lista a data.xml como alternativa, y data.xml lista a data.json. Cuando el cliente solicita con TCN habilitado, el servidor intenta negociar la mejor variante, entra en un ciclo infinito entre las dos, detecta la recursión, y devuelve 506. La solución es configurar las variantes sin referencias cruzadas, cada una siendo independiente, y usar quality values para priorización."
            },
            {
                "scenario": "Negociación simple mal configurada generando 506",
                "request": "GET /content HTTP/1.1\nHost: www.example.com\nAccept-Language: es-MX, es, en\nAccept-Encoding: gzip, deflate",
                "response": "HTTP/1.1 506 Variant Also Negotiates\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: text/plain\nContent-Length: 89\n\nContent negotiation error: variant configuration results in circular reference\n\nConfiguración nginx problemática:\n\nlocation /content {\n    # PROBLEMA: Reglas de rewrite circulares\n    \n    # Si pide español, redirige a /content.es\n    if ($http_accept_language ~* \"es\") {\n        rewrite ^/content$ /content.es last;\n    }\n    \n    # Si pide inglés desde /content.es, vuelve a /content\n    if ($http_accept_language ~* \"en\") {\n        rewrite ^/content.es$ /content last;\n    }\n    \n    # Si Accept-Language tiene ambos → ciclo infinito\n    # Accept-Language: es, en → loop entre /content y /content.es\n}\n\nlocation /content.es {\n    # Similar configuración problemática\n    if ($http_accept_language ~* \"en\") {\n        rewrite ^/content.es$ /content last;\n    }\n    \n    try_files /content.es.html =404;\n}\n\nSOLUCIÓN - Negociación sin ciclos:\n\nmap $http_accept_language $content_variant {\n    default \"/content.en.html\";\n    \"~*^es\" \"/content.es.html\";\n    \"~*^fr\" \"/content.fr.html\";\n}\n\nlocation /content {\n    # Una sola regla, sin ciclos\n    try_files $content_variant /content.en.html;\n}\n\nlocation ~ ^/content\\.(es|en|fr)\\.html$ {\n    # Servir archivos directamente\n    root /var/www;\n}",
                "explanation": "nginx está configurado con reglas de rewrite que crean un ciclo: si el cliente envía Accept-Language con múltiples idiomas (es, en), las reglas entran en loop entre /content y /content.es. El servidor detecta el ciclo y devuelve 506. La solución es usar una configuración declarativa con map que selecciona la variante apropiada en una sola evaluación, sin rewrites que puedan crear ciclos."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2295 (Transparent Content Negotiation), RFC 2296",
        "relatedHeaders": [
            "TCN",
            "Negotiate",
            "Alternates",
            "Vary"
        ],
        "relatedCodes": [
            300,
            406,
            510
        ],
        "technicalNotes": "El código 506 es específico de Transparent Content Negotiation (TCN) definido en RFC 2295. Diferencias: 506 Variant Also Negotiates = configuración circular en negociación; 300 Multiple Choices = múltiples variantes disponibles (cliente elige); 406 Not Acceptable = ninguna variante satisface los requisitos del cliente; 510 Not Extended = extensiones requeridas no soportadas. IMPORTANTE: 506 es EXTREMADAMENTE RARO - la mayoría de servidores usan negociación simple (MultiViews en Apache, try_files en nginx) sin TCN formal. TCN permite que variantes se referencien entre sí con headers Alternates, pero configuración incorrecta causa ciclos. Causas: (1) Variante A lista B como alternativa, B lista A; (2) Cadena de referencias que vuelve al inicio; (3) Rewrites circulares basados en Accept headers; (4) Configuración incorrecta de LanguagePriority/ForceLanguagePriority. Best practices: (1) Evitar TCN a menos que sea necesario; (2) Usar negociación simple con archivos independientes; (3) Nunca crear referencias bidireccionales entre variantes; (4) Validar configuración con herramientas de lint; (5) Preferir content negotiation del lado del cliente (API versioning en URL). Debugging: revisar logs para detectar loops, verificar que cada variante sea independiente, eliminar Alternates headers circulares. Alternativas modernas: content negotiation vía URL (/api/v1/data.json), query parameters (?format=json), subdominios (api.example.com vs www.example.com). 506 indica error de CONFIGURACIÓN del servidor que debe corregirse - no es error del cliente ni temporal.",
        "images": []
    },
    {
        "code": 507,
        "status": "Insufficient Storage",
        "category": "Server Error",
        "description": "El código 507 Insufficient Storage es un código de estado HTTP que indica que el servidor no puede almacenar la representación necesaria para completar la solicitud porque no tiene suficiente espacio de almacenamiento disponible. El servidor está diciendo: 'No puedo procesar tu solicitud porque me quedé sin espacio de almacenamiento'. Es importante entender que el 507 NO es un error temporal común - indica que el servidor literalmente no tiene espacio en disco, memoria, o cuota disponible para completar la operación. A diferencia del 500 (error interno genérico) o 503 (sobrecarga temporal), el 507 específicamente señala un problema de CAPACIDAD DE ALMACENAMIENTO. Este código es más común en: servidores WebDAV (donde se almacenan archivos), sistemas de almacenamiento en la nube, servicios de upload de archivos, o aplicaciones que generan contenido que debe persistirse. Las causas incluyen: disco duro lleno en el servidor, cuota de almacenamiento del usuario excedida, límite de inodes alcanzado, partición o filesystem sin espacio, memoria insuficiente para operaciones en RAM, o límites de almacenamiento configurados alcanzados. El 507 indica un problema que requiere intervención - liberar espacio, aumentar capacidad, o limpiar archivos antiguos.",
        "useCases": [
            "Disco del servidor completamente lleno",
            "Usuario excedió su cuota de almacenamiento",
            "Filesystem sin espacio disponible para nuevos archivos",
            "Límite de inodes alcanzado (demasiados archivos)",
            "WebDAV PROPFIND/PUT sin espacio suficiente",
            "Upload de archivo cuando storage está lleno",
            "Base de datos sin espacio para nuevos registros",
            "Partición temporal sin capacidad para procesamiento"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo con disco lleno",
                "request": "PUT /files/large-video.mp4 HTTP/1.1\nHost: storage.example.com\nContent-Type: video/mp4\nContent-Length: 2147483648\nAuthorization: Bearer user_token_123\n\n[Intento de subir archivo de 2GB]",
                "response": "HTTP/1.1 507 Insufficient Storage\nDate: Wed, 17 Jan 2024 14:30:00 GMT\nServer: nginx/1.24.0\nContent-Type: application/json\nContent-Length: 198\n\n{\n  \"error\": \"Insufficient Storage\",\n  \"message\": \"Server has run out of storage space\",\n  \"available_space\": \"45 MB\",\n  \"required_space\": \"2048 MB\",\n  \"suggestion\": \"Contact administrator or delete old files\"\n}\n\nCódigo del servidor (Node.js/Express):\n\nconst express = require('express');\nconst fs = require('fs');\nconst diskusage = require('diskusage');\nconst app = express();\n\napp.put('/files/:filename', async (req, res) => {\n    const filename = req.params.filename;\n    const filepath = `/var/uploads/${filename}`;\n    const contentLength = parseInt(req.headers['content-length']);\n    \n    try {\n        // Verificar espacio disponible ANTES de intentar escribir\n        const disk = await diskusage.check('/var/uploads');\n        const availableBytes = disk.available;\n        const availableMB = Math.floor(availableBytes / 1024 / 1024);\n        const requiredMB = Math.floor(contentLength / 1024 / 1024);\n        \n        if (availableBytes < contentLength) {\n            // No hay suficiente espacio\n            return res.status(507).json({\n                error: 'Insufficient Storage',\n                message: 'Server has run out of storage space',\n                available_space: `${availableMB} MB`,\n                required_space: `${requiredMB} MB`,\n                suggestion: 'Contact administrator or delete old files'\n            });\n        }\n        \n        // Hay espacio suficiente, proceder con upload\n        const writeStream = fs.createWriteStream(filepath);\n        \n        req.pipe(writeStream);\n        \n        writeStream.on('finish', () => {\n            res.status(201).json({\n                message: 'File uploaded successfully',\n                filename,\n                size: contentLength\n            });\n        });\n        \n        writeStream.on('error', (error) => {\n            if (error.code === 'ENOSPC') {\n                // No space left on device (espacio agotado durante escritura)\n                res.status(507).json({\n                    error: 'Insufficient Storage',\n                    message: 'Storage space exhausted during upload'\n                });\n            } else {\n                res.status(500).json({ error: 'Upload failed' });\n            }\n        });\n        \n    } catch (error) {\n        console.error('Upload error:', error);\n        res.status(500).json({ error: 'Internal Server Error' });\n    }\n});\n\nEstado del servidor:\n\nFilesystem      Size  Used  Avail Use% Mounted on\n/dev/sda1       100G   99G    45M  99%  /var/uploads\n\n# Disco casi lleno:\n# Total: 100GB\n# Usado: 99GB\n# Disponible: 45MB\n# Cliente intenta subir: 2GB\n# 45MB < 2GB → 507 Insufficient Storage\n\nLog del servidor:\n\n[2024-01-17 14:30:00] WARN: Low disk space on /var/uploads: 45MB remaining\n[2024-01-17 14:30:00] ERROR: Upload rejected - insufficient storage\n[2024-01-17 14:30:00] INFO: File upload failed for large-video.mp4 (2048MB required, 45MB available)\n\nSOLUCIONES:\n\n1. Monitoreo y alertas de disco:\n\n# Script de monitoreo\n#!/bin/bash\nTHRESHOLD=90\nPARTITION=\"/var/uploads\"\n\nUSAGE=$(df -h $PARTITION | tail -1 | awk '{print $5}' | sed 's/%//')\n\nif [ $USAGE -gt $THRESHOLD ]; then\n    echo \"ALERT: Disk usage at ${USAGE}% on ${PARTITION}\"\n    # Enviar alerta\n    curl -X POST https://alerts.example.com/notify \\\n        -d \"disk_usage=${USAGE}&partition=${PARTITION}\"\nfi\n\n2. Limpieza automática de archivos antiguos:\n\nconst cron = require('node-cron');\n\n// Ejecutar limpieza diaria a las 2 AM\ncron.schedule('0 2 * * *', async () => {\n    const disk = await diskusage.check('/var/uploads');\n    const usagePercent = ((disk.total - disk.available) / disk.total) * 100;\n    \n    if (usagePercent > 85) {\n        console.log(`Disk usage at ${usagePercent}%, cleaning old files...`);\n        \n        // Eliminar archivos más antiguos de 30 días\n        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n        const files = await fs.promises.readdir('/var/uploads');\n        \n        for (const file of files) {\n            const stats = await fs.promises.stat(`/var/uploads/${file}`);\n            if (stats.mtime.getTime() < thirtyDaysAgo) {\n                await fs.promises.unlink(`/var/uploads/${file}`);\n                console.log(`Deleted old file: ${file}`);\n            }\n        }\n    }\n});\n\n3. Cuotas por usuario:\n\nconst userQuotas = {\n    'user_123': { limit: 10 * 1024 * 1024 * 1024, used: 0 }, // 10GB\n    'user_456': { limit: 5 * 1024 * 1024 * 1024, used: 0 }   // 5GB\n};\n\napp.put('/files/:filename', async (req, res) => {\n    const userId = req.user.id;\n    const quota = userQuotas[userId];\n    const fileSize = parseInt(req.headers['content-length']);\n    \n    if (quota.used + fileSize > quota.limit) {\n        return res.status(507).json({\n            error: 'Insufficient Storage',\n            message: 'User storage quota exceeded',\n            quota_limit: `${quota.limit / 1024 / 1024} MB`,\n            quota_used: `${quota.used / 1024 / 1024} MB`,\n            file_size: `${fileSize / 1024 / 1024} MB`\n        });\n    }\n    \n    // Proceder con upload...\n});",
                "explanation": "El cliente intenta subir un video de 2GB a un servidor que solo tiene 45MB de espacio disponible en disco. El servidor verifica el espacio disponible antes de aceptar el upload, detecta que no hay suficiente capacidad (45MB < 2GB), y devuelve 507 Insufficient Storage indicando cuánto espacio está disponible vs cuánto se necesita. Esto previene que el upload falle a mitad de camino y corrompa el filesystem. Las soluciones incluyen: monitoreo proactivo de espacio en disco con alertas, limpieza automática de archivos antiguos, y sistemas de cuotas por usuario."
            },
            {
                "scenario": "WebDAV MKCOL sin espacio disponible",
                "request": "MKCOL /webdav/new-collection/ HTTP/1.1\nHost: dav.example.com\nAuthorization: Basic dXNlcjpwYXNz\nContent-Length: 0",
                "response": "HTTP/1.1 507 Insufficient Storage\nDate: Wed, 17 Jan 2024 15:45:00 GMT\nServer: Apache/2.4.41 (Unix) DAV/2\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 312\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:error xmlns:D=\"DAV:\">\n  <D:insufficient-storage>\n    <D:description>The server does not have sufficient storage space to create the collection.</D:description>\n    <D:available-space>0 bytes</D:available-space>\n  </D:insufficient-storage>\n</D:error>\n\nConfiguración Apache WebDAV:\n\n<VirtualHost *:80>\n    ServerName dav.example.com\n    DocumentRoot /var/webdav\n    \n    <Directory /var/webdav>\n        Dav On\n        Options Indexes\n        AuthType Basic\n        AuthName \"WebDAV Storage\"\n        AuthUserFile /etc/apache2/.htpasswd\n        Require valid-user\n        \n        # Límites de almacenamiento\n        LimitRequestBody 104857600  # 100MB max file size\n    </Directory>\n    \n    # Logs específicos de WebDAV\n    CustomLog /var/log/apache2/webdav-access.log combined\n    ErrorLog /var/log/apache2/webdav-error.log\n</VirtualHost>\n\nEscenario:\n\n# Estado del filesystem\ndf -h /var/webdav\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sdb1        50G   50G     0 100% /var/webdav\n\n# Inodes también agotados\ndf -i /var/webdav\nFilesystem     Inodes  IUsed  IFree IUse% Mounted on\n/dev/sdb1      3.2M    3.2M      0  100% /var/webdav\n\nLog de Apache:\n\n[Wed Jan 17 15:45:00 2024] [error] [client 198.51.100.10] (28)No space left on device: Cannot create collection /var/webdav/new-collection/\n[Wed Jan 17 15:45:00 2024] [error] WebDAV MKCOL failed: insufficient storage\n\nSOLUCIÓN:\n\n# Verificar qué está consumiendo espacio\ndu -sh /var/webdav/* | sort -rh | head -10\n\n# Limpiar archivos temporales\nfind /var/webdav -name \"*.tmp\" -delete\n\n# Aumentar capacidad\nlvextend -L +50G /dev/vg0/webdav\nresize2fs /dev/vg0/webdav",
                "explanation": "Un cliente WebDAV intenta crear una nueva colección (directorio) usando el método MKCOL, pero el servidor no tiene espacio disponible en el filesystem (100% usado) ni inodes libres. Apache WebDAV detecta la falta de espacio y devuelve 507 Insufficient Storage con un XML describiendo el problema. La solución es liberar espacio eliminando archivos innecesarios o aumentar la capacidad del volumen de almacenamiento."
            },
            {
                "scenario": "Cuota de usuario excedida en servicio cloud",
                "request": "POST /api/upload HTTP/1.1\nHost: cloud.example.com\nContent-Type: multipart/form-data\nAuthorization: Bearer user_token_xyz\nContent-Length: 524288000\n\n[Intento de subir archivo de 500MB]",
                "response": "HTTP/1.1 507 Insufficient Storage\nDate: Wed, 17 Jan 2024 16:30:00 GMT\nServer: CloudStorage/1.0\nContent-Type: application/json\nContent-Length: 245\n\n{\n  \"error\": \"Insufficient Storage\",\n  \"message\": \"Storage quota exceeded\",\n  \"quota\": {\n    \"limit\": \"5 GB\",\n    \"used\": \"4.8 GB\",\n    \"available\": \"200 MB\",\n    \"file_size\": \"500 MB\"\n  },\n  \"upgrade_url\": \"https://cloud.example.com/upgrade\"\n}\n\nImplementación de cuotas (Python/Flask):\n\nfrom flask import Flask, request, jsonify\nimport os\n\napp = Flask(__name__)\n\nUSER_QUOTAS = {\n    'user_xyz': {\n        'limit': 5 * 1024 * 1024 * 1024,  # 5GB\n        'used': 4.8 * 1024 * 1024 * 1024   # 4.8GB usado\n    }\n}\n\n@app.route('/api/upload', methods=['POST'])\ndef upload_file():\n    user_id = request.user_id\n    quota = USER_QUOTAS.get(user_id)\n    file_size = int(request.headers.get('Content-Length', 0))\n    \n    if not quota:\n        return jsonify({'error': 'User not found'}), 404\n    \n    available = quota['limit'] - quota['used']\n    \n    if file_size > available:\n        return jsonify({\n            'error': 'Insufficient Storage',\n            'message': 'Storage quota exceeded',\n            'quota': {\n                'limit': f\"{quota['limit'] / 1024 / 1024 / 1024:.1f} GB\",\n                'used': f\"{quota['used'] / 1024 / 1024 / 1024:.1f} GB\",\n                'available': f\"{available / 1024 / 1024:.0f} MB\",\n                'file_size': f\"{file_size / 1024 / 1024:.0f} MB\"\n            },\n            'upgrade_url': 'https://cloud.example.com/upgrade'\n        }), 507\n    \n    # Proceder con upload\n    file = request.files['file']\n    file.save(f'/storage/{user_id}/{file.filename}')\n    \n    # Actualizar cuota usada\n    quota['used'] += file_size\n    \n    return jsonify({\n        'message': 'File uploaded successfully',\n        'quota_remaining': f\"{(quota['limit'] - quota['used']) / 1024 / 1024:.0f} MB\"\n    }), 201\n\nCliente manejando 507:\n\nasync function uploadFile(file) {\n    try {\n        const formData = new FormData();\n        formData.append('file', file);\n        \n        const response = await fetch('/api/upload', {\n            method: 'POST',\n            body: formData,\n            headers: {\n                'Authorization': `Bearer ${token}`\n            }\n        });\n        \n        if (response.status === 507) {\n            const data = await response.json();\n            \n            showQuotaExceededDialog({\n                used: data.quota.used,\n                limit: data.quota.limit,\n                available: data.quota.available,\n                fileSize: data.quota.file_size,\n                upgradeUrl: data.upgrade_url\n            });\n            \n            return;\n        }\n        \n        if (response.ok) {\n            showSuccess('File uploaded successfully');\n        }\n        \n    } catch (error) {\n        console.error('Upload failed:', error);\n    }\n}",
                "explanation": "Un usuario de un servicio de almacenamiento en la nube intenta subir un archivo de 500MB pero solo tiene 200MB disponibles en su cuota de 5GB (ha usado 4.8GB). El servidor verifica la cuota antes de aceptar el upload y devuelve 507 Insufficient Storage con detalles sobre la cuota excedida y un link para actualizar el plan. El cliente puede mostrar un diálogo informando al usuario sobre el límite alcanzado y ofreciendo opciones para liberar espacio o aumentar la cuota."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.5",
        "relatedHeaders": [
            "Content-Length"
        ],
        "relatedCodes": [
            413,
            500,
            503
        ],
        "technicalNotes": "El código 507 es parte de la extensión WebDAV (RFC 4918) pero se usa en cualquier contexto donde hay limitaciones de almacenamiento. Diferencias: 507 Insufficient Storage = sin espacio de almacenamiento disponible; 413 Payload Too Large = archivo demasiado grande para límite configurado; 500 Internal Server Error = error genérico del servidor; 503 Service Unavailable = servidor temporalmente sobrecargado. IMPORTANTE: 507 indica problema de CAPACIDAD, no de tamaño de archivo individual. Causas comunes: (1) Disco lleno (df -h muestra 100%); (2) Inodes agotados (df -i muestra 100%); (3) Cuota de usuario excedida; (4) Partición sin espacio; (5) Memoria/RAM insuficiente para operaciones. Sistemas afectados: WebDAV servers, servicios de upload (Dropbox, Google Drive), CMSs con uploads, APIs de almacenamiento. Best practices: (1) Verificar espacio ANTES de aceptar uploads; (2) Implementar cuotas por usuario; (3) Monitoreo proactivo con alertas al 80-85% de capacidad; (4) Limpieza automática de archivos temporales/antiguos; (5) Respuestas informativas con espacio disponible/requerido. Prevención: usar LVM para expansion dinámica, configurar alertas de disco, implementar rotación de logs, comprimir archivos antiguos, usar object storage (S3) para escalar. Cliente debe: informar al usuario claramente sobre límite, ofrecer opciones (eliminar archivos, actualizar plan), NO reintentar automáticamente. Monitoreo: df -h (espacio), df -i (inodes), du -sh (uso por directorio), alertas en >85% uso.",
        "images": []
    }
]