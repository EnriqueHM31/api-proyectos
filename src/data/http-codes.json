[
    {
        "code": 100,
        "status": "Continue",
        "category": "Informational",
        "description": "El código 100 Continue es una respuesta provisional que indica que el cliente debe continuar con su solicitud o ignorar esta respuesta si la solicitud ya ha sido completada. Este código se utiliza principalmente en escenarios donde el cliente necesita enviar un cuerpo de solicitud grande y quiere verificar primero si el servidor está dispuesto a aceptarlo antes de enviar todos los datos. El cliente envía los encabezados de la solicitud con un encabezado 'Expect: 100-continue', y el servidor responde con 100 Continue si está listo para recibir el cuerpo de la solicitud. Esto es especialmente útil para optimizar el ancho de banda y evitar enviar grandes cantidades de datos que podrían ser rechazados por el servidor. Por ejemplo, si un cliente intenta subir un archivo de 500MB, puede primero enviar los encabezados para verificar la autenticación y validación antes de transmitir todo el archivo. Si el servidor responde con 100 Continue, el cliente procede a enviar el cuerpo completo. Si el servidor responde con un código de error (como 401 Unauthorized), el cliente puede abortar la transmisión sin haber desperdiciado ancho de banda enviando el archivo completo.",
        "useCases": [
            "Upload de archivos grandes donde se necesita validación previa",
            "APIs que requieren verificación de autenticación antes de procesar cuerpos de solicitud pesados",
            "Optimización de ancho de banda en conexiones lentas",
            "Sistemas de streaming donde se necesita confirmación del servidor antes de enviar datos"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo grande",
                "request": "POST /upload HTTP/1.1\nHost: example.com\nExpect: 100-continue\nContent-Length: 524288000\nContent-Type: application/octet-stream",
                "response": "HTTP/1.1 100 Continue",
                "explanation": "El servidor acepta recibir el archivo, el cliente procede a enviar los 500MB"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611664/404_2_l0oyj5.png",
                "alt": "Imagen que representa el nombre del código 100 Continue"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618710/1-removebg-preview_tkp4yz.png",
                "alt": "Imagen del código 100 Continue"
            }
        ]
    },
    {
        "code": 101,
        "status": "Switching Protocols",
        "category": "Informational",
        "description": "El código 101 Switching Protocols indica que el servidor está cambiando de protocolo según lo solicitado por el cliente a través del encabezado 'Upgrade'. Este mecanismo permite que una conexión establecida inicialmente con HTTP evolucione a un protocolo diferente, como WebSocket, HTTP/2, o cualquier otro protocolo compatible. El servidor envía este código para confirmar que acepta cambiar al protocolo solicitado en el encabezado Upgrade de la solicitud del cliente. Después de enviar esta respuesta, el servidor abandona el protocolo HTTP/1.1 y comienza a comunicarse usando el nuevo protocolo especificado. Este código es fundamental para la implementación de WebSockets, que permite comunicación bidireccional en tiempo real sobre una única conexión TCP. El proceso típico involucra una solicitud HTTP inicial que solicita el upgrade, el servidor responde con 101, y a partir de ese momento la conexión opera bajo el nuevo protocolo. Esto es especialmente valioso en aplicaciones que requieren comunicación en tiempo real, como chats, juegos multijugador, dashboards en vivo, o aplicaciones colaborativas. Es importante notar que no todos los proxies o intermediarios soportan este mecanismo, por lo que la implementación debe considerar compatibilidad.",
        "useCases": [
            "Establecimiento de conexiones WebSocket para comunicación bidireccional en tiempo real",
            "Upgrade de HTTP/1.1 a HTTP/2 para mejorar el rendimiento",
            "Implementación de Server-Sent Events (SSE) en algunos casos",
            "Protocolos personalizados que necesitan una conexión HTTP inicial"
        ],
        "examples": [
            {
                "scenario": "Upgrade a WebSocket",
                "request": "GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13",
                "response": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
                "explanation": "El servidor acepta el upgrade a WebSocket y la conexión ahora usa el protocolo WebSocket"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597106/1_ltkyhn.png",
                "alt": "Imagen que representa el nombre del código 101 Switching Protocols"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618707/2-removebg-preview_jjwrov.png",
                "alt": "Imagen del código 101 Switching Protocols"
            }
        ]
    },
    {
        "code": 102,
        "status": "Processing",
        "category": "Informational",
        "description": "El código 102 Processing es una respuesta provisional que indica que el servidor ha recibido y está procesando la solicitud, pero aún no tiene una respuesta disponible. Este código se utiliza principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para prevenir que el cliente agote el tiempo de espera en operaciones que requieren mucho tiempo de procesamiento. Cuando un servidor WebDAV recibe una solicitud que puede tomar tiempo significativo para completarse (como copiar una gran estructura de directorios, realizar operaciones complejas en múltiples recursos, o procesar transformaciones de archivos grandes), envía este código intermedio para mantener la conexión activa y asegurar al cliente que la solicitud no se ha perdido o estancado. El cliente, al recibir este código, puede resetear su temporizador de timeout y continuar esperando. Es particularmente útil en operaciones como PROPFIND sobre grandes colecciones de recursos, operaciones COPY o MOVE masivas, o cualquier operación que involucre procesamiento extensivo en el servidor. A diferencia de 100 Continue que es sobre el envío de datos, 102 Processing es sobre la ejecución de la operación solicitada.",
        "useCases": [
            "Operaciones WebDAV que toman tiempo significativo (PROPFIND, COPY, MOVE)",
            "Procesamiento de grandes estructuras de archivos en sistemas de gestión de contenido",
            "Operaciones batch sobre múltiples recursos",
            "Transformaciones o conversiones de archivos que requieren tiempo de procesamiento extenso"
        ],
        "examples": [
            {
                "scenario": "Copia masiva de directorios en WebDAV",
                "request": "COPY /documents/folder1/ HTTP/1.1\nHost: webdav.example.com\nDestination: /documents/folder2/\nDepth: infinity",
                "response": "HTTP/1.1 102 Processing",
                "explanation": "El servidor informa que está copiando los archivos recursivamente y el cliente debe seguir esperando"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2518 (WebDAV)",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611761/2_je4oyl.png",
                "alt": "Imagen que representa el nombre del código 102 Processing"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618704/3-removebg-preview_cj1fzy.png",
                "alt": "Imagen del código 102 Processing"
            }
        ]
    },
    {
        "code": 103,
        "status": "Early Hints",
        "category": "Informational",
        "description": "El código 103 Early Hints es una respuesta informativa relativamente nueva que permite al servidor enviar encabezados HTTP preliminares antes de que la respuesta final esté lista. Su propósito principal es mejorar el rendimiento de carga de páginas web al permitir que el navegador comience a pre-cargar recursos críticos mientras el servidor aún está preparando la respuesta completa. Esto es especialmente valioso cuando el servidor necesita tiempo para generar contenido dinámico pero ya sabe qué recursos adicionales (CSS, JavaScript, fuentes, imágenes) serán necesarios. El servidor puede enviar encabezados Link con rel=preload o rel=preconnect, permitiendo que el navegador inicie la descarga de estos recursos en paralelo mientras espera la respuesta HTML principal. Por ejemplo, si un servidor de aplicación necesita consultar una base de datos para generar una página pero ya sabe que necesitará ciertos archivos CSS y JavaScript, puede enviar 103 Early Hints inmediatamente con referencias a esos recursos. Esto reduce significativamente el tiempo de carga percibido y mejora métricas como First Contentful Paint (FCP) y Largest Contentful Paint (LCP). Es particularmente efectivo en sitios con tiempos de procesamiento del servidor variables o consultas de base de datos complejas.",
        "useCases": [
            "Precarga de recursos estáticos (CSS, JS, fuentes) mientras se genera contenido dinámico",
            "Establecimiento anticipado de conexiones a dominios de terceros (CDNs, APIs)",
            "Optimización del rendimiento web y mejora de Core Web Vitals",
            "Reducción del tiempo de carga en aplicaciones con procesamiento del servidor intensivo"
        ],
        "examples": [
            {
                "scenario": "Precarga de recursos críticos",
                "request": "GET /dashboard HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 103 Early Hints\nLink: </styles/critical.css>; rel=preload; as=style\nLink: </scripts/app.js>; rel=preload; as=script\nLink: <https://cdn.example.com>; rel=preconnect\n\n[... el servidor continúa procesando ...]\n\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>...",
                "explanation": "El navegador recibe instrucciones para precargar CSS y JS mientras el servidor genera el HTML del dashboard"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 8297",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597108/3_av4aj8.png",
                "alt": "Imagen que representa el nombre del código 103 Early Hints  "
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618702/4-removebg-preview_gkrmuw.png",
                "alt": "Imagen del código 103 Early Hints"
            }
        ]
    },
    {
        "code": 200,
        "status": "OK",
        "category": "Success",
        "description": "El código 200 OK es la respuesta de éxito estándar y más común en HTTP. Indica que la solicitud ha sido procesada exitosamente y el servidor está devolviendo el resultado solicitado. El significado específico de 'éxito' varía según el método HTTP utilizado: para GET significa que el recurso ha sido recuperado y se transmite en el cuerpo del mensaje; para POST indica que el recurso que describe el resultado de la acción se transmite en el cuerpo del mensaje; para PUT o PATCH significa que el recurso ha sido modificado exitosamente; para DELETE indica que el recurso ha sido eliminado. Este código es el caballo de batalla de las APIs REST y aplicaciones web. La respuesta 200 típicamente incluye el cuerpo del mensaje con el contenido solicitado (HTML, JSON, XML, archivos binarios, etc.) junto con encabezados relevantes como Content-Type, Content-Length, Cache-Control, ETag, entre otros. Es importante notar que 200 no siempre es la respuesta más semántica - por ejemplo, una creación exitosa debería usar 201 Created, y una eliminación exitosa sin contenido debería usar 204 No Content. El uso apropiado de códigos de estado hace que las APIs sean más expresivas y fáciles de consumir.",
        "useCases": [
            "Recuperación exitosa de recursos (GET requests)",
            "Respuestas exitosas de búsquedas o consultas",
            "Actualizaciones parciales exitosas (PATCH)",
            "Cualquier operación exitosa que devuelve contenido en el cuerpo",
            "Respuestas de APIs que devuelven datos JSON o XML"
        ],
        "examples": [
            {
                "scenario": "GET request a una API REST",
                "request": "GET /api/users/123 HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 145\nCache-Control: max-age=3600\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}",
                "explanation": "El servidor devuelve exitosamente los datos del usuario solicitado en formato JSON"
            },
            {
                "scenario": "POST request que procesa datos",
                "request": "POST /api/search HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"query\": \"javascript tutorials\"}",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"results\": [\n    {\"title\": \"JS Basics\", \"url\": \"https://example.com/js-basics\"},\n    {\"title\": \"Advanced JS\", \"url\": \"https://example.com/advanced-js\"}\n  ],\n  \"count\": 2\n}",
                "explanation": "La búsqueda se procesó exitosamente y devuelve los resultados"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613634/1_bikeld.png",
                "alt": "Imagen que representa el nombre del código 200 OK"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619787/5-removebg-preview_wc1wto.png",
                "alt": "Imagen del código 200 OK"
            }
        ]
    },
    {
        "code": 201,
        "status": "Created",
        "category": "Success",
        "description": "El código 201 Created indica que la solicitud ha sido exitosa y ha resultado en la creación de uno o más recursos nuevos. Este código es semánticamente más apropiado que 200 OK cuando se crea un nuevo recurso, típicamente en respuesta a solicitudes POST o PUT. La respuesta 201 debe incluir un encabezado Location que contenga la URI del recurso recién creado, permitiendo al cliente acceder directamente al nuevo recurso sin necesidad de búsquedas adicionales. Opcionalmente, el cuerpo de la respuesta puede contener una representación del recurso creado o una descripción del estado de la creación. Este código es fundamental en APIs RESTful bien diseñadas, donde la creación de recursos es una operación común. Por ejemplo, cuando se crea un nuevo usuario, una nueva publicación de blog, un nuevo pedido de compra, o cualquier entidad en el sistema, 201 es la respuesta apropiada. La inclusión del encabezado Location es crucial porque permite a los clientes saber inmediatamente dónde encontrar el recurso recién creado, especialmente útil cuando el servidor genera IDs automáticamente. Algunas implementaciones también incluyen el recurso completo en el cuerpo de la respuesta para evitar que el cliente tenga que hacer una solicitud GET adicional.",
        "useCases": [
            "Creación de nuevos usuarios en un sistema",
            "Publicación de nuevos contenidos (artículos, posts, comentarios)",
            "Creación de pedidos o transacciones",
            "Registro de nuevas entidades en bases de datos mediante APIs",
            "Upload de archivos o recursos que generan nuevas entradas"
        ],
        "examples": [
            {
                "scenario": "Creación de un nuevo usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/users/456\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"created_at\": \"2024-01-16T14:22:00Z\",\n  \"profile_url\": \"/api/users/456\"\n}",
                "explanation": "El usuario fue creado exitosamente, el servidor asignó el ID 456 y devuelve la ubicación del nuevo recurso"
            },
            {
                "scenario": "Creación de un post en blog",
                "request": "POST /api/posts HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token123\n\n{\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"content\": \"HTTP status codes are...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/posts/789\nContent-Type: application/json\n\n{\n  \"id\": 789,\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"slug\": \"introduction-to-http-status-codes\",\n  \"author_id\": 123,\n  \"created_at\": \"2024-01-16T14:25:00Z\",\n  \"status\": \"published\"\n}",
                "explanation": "El post fue creado y publicado, incluyendo metadatos generados por el servidor como slug y timestamps"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613643/2_hapb2d.png",
                "alt": "Imagen que representa el nombre del código 201 Created"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619783/6-removebg-preview_ytp56u.png",
                "alt": "Imagen del codigo 201 Created"
            }
        ]
    },
    {
        "code": 202,
        "status": "Accepted",
        "category": "Success",
        "description": "El código 202 Accepted indica que la solicitud ha sido aceptada para procesamiento, pero el procesamiento aún no se ha completado. Este código es especialmente útil para operaciones asíncronas donde el servidor acepta la solicitud pero la procesará más tarde, en segundo plano. La respuesta 202 es no-comprometida, lo que significa que el servidor acepta la solicitud pero no garantiza que será procesada exitosamente - el procesamiento real podría fallar posteriormente. Este código es ideal para operaciones de larga duración como procesamiento de archivos grandes, conversiones de video, operaciones batch, envío de emails masivos, generación de reportes complejos, o cualquier tarea que no puede completarse inmediatamente dentro del tiempo de respuesta HTTP típico. La respuesta debería incluir información sobre el estado del procesamiento y cómo el cliente puede verificar el progreso, típicamente mediante un encabezado Location que apunta a un recurso de estado o mediante un cuerpo de respuesta que incluye un ID de tarea que puede ser consultado posteriormente. Muchas APIs modernas usan este patrón para operaciones pesadas, proporcionando endpoints separados para verificar el estado de las tareas en progreso.",
        "useCases": [
            "Procesamiento asíncrono de archivos (conversión de video, compresión de imágenes)",
            "Operaciones batch que toman tiempo significativo",
            "Envío de emails masivos o notificaciones",
            "Generación de reportes complejos o exports de datos",
            "Operaciones que requieren aprobación manual posterior",
            "Tareas en cola que serán procesadas por workers en background"
        ],
        "examples": [
            {
                "scenario": "Upload y procesamiento de video",
                "request": "POST /api/videos HTTP/1.1\nHost: media.example.com\nContent-Type: multipart/form-data\n\n[video file data]",
                "response": "HTTP/1.1 202 Accepted\nLocation: /api/jobs/video-process-999\nContent-Type: application/json\n\n{\n  \"job_id\": \"video-process-999\",\n  \"status\": \"queued\",\n  \"message\": \"Video upload accepted. Processing will begin shortly.\",\n  \"status_url\": \"/api/jobs/video-process-999\",\n  \"estimated_completion\": \"2024-01-16T15:30:00Z\"\n}",
                "explanation": "El video fue recibido y está en cola para procesamiento. El cliente puede verificar el estado usando la URL proporcionada"
            },
            {
                "scenario": "Generación de reporte complejo",
                "request": "POST /api/reports/generate HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\n\n{\n  \"type\": \"annual_sales\",\n  \"year\": 2024,\n  \"format\": \"pdf\",\n  \"include_charts\": true\n}",
                "response": "HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n  \"task_id\": \"report-gen-12345\",\n  \"status\": \"processing\",\n  \"progress_url\": \"/api/tasks/report-gen-12345/status\",\n  \"webhook_url\": null,\n  \"message\": \"Report generation started. You will be notified when complete.\"\n}",
                "explanation": "El servidor acepta la solicitud de generación de reporte y la procesa en background"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.3",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613646/3_clmvyi.png",
                "alt": "Imagen que representa el nombre del código 202 Accepted"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619780/7-removebg-preview_mh2ybs.png",
                "alt": "Imagen del código 202 Accepted"
            }
        ]
    },
    {
        "code": 203,
        "status": "Non-Authoritative Information",
        "category": "Success",
        "description": "El código 203 Non-Authoritative Information indica que la solicitud fue exitosa pero la información incluida en la respuesta proviene de una copia local o de terceros, no del servidor origen original. Este código es utilizado principalmente por proxies HTTP o cachés que modifican o transforman la respuesta del servidor origen. Aunque la respuesta es exitosa (similar a 200 OK), el código 203 advierte al cliente que los metadatos (encabezados) pueden haber sido modificados por un intermediario y pueden no ser exactamente los mismos que el servidor origen habría proporcionado. El cuerpo de la entidad puede ser idéntico al de una respuesta 200, pero los encabezados podrían ser diferentes. Este código es poco común en la práctica moderna pero es útil en escenarios donde proxies realizan transformaciones, como conversión de formatos de imagen, compresión adicional, añadir encabezados de seguridad, o modificar metadatos. Por ejemplo, un proxy de optimización podría comprimir imágenes antes de enviarlas al cliente y usar 203 para indicar que aunque el contenido es válido, ha sido procesado. También puede ser usado en escenarios de mirror servers o CDNs que sirven contenido desde múltiples ubicaciones y quieren indicar que la respuesta no viene directamente del servidor origen.",
        "useCases": [
            "Respuestas servidas por proxies que modifican metadatos",
            "CDNs o mirrors que sirven contenido almacenado en caché con encabezados modificados",
            "Proxies de transformación que optimizan contenido (compresión de imágenes, minificación)",
            "Sistemas de caché que añaden encabezados adicionales a las respuestas",
            "Servicios de agregación que combinan datos de múltiples fuentes"
        ],
        "examples": [
            {
                "scenario": "Proxy que modifica encabezados de imagen",
                "request": "GET /images/photo.jpg HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: image/jpeg\nContent-Length: 45000\nX-Proxy-Optimized: true\nX-Original-Size: 120000\nVia: 1.1 proxy.example.com\n\n[compressed image data]",
                "explanation": "Un proxy interceptó la imagen, la comprimió, y modificó los encabezados para reflejar el nuevo tamaño"
            },
            {
                "scenario": "CDN sirviendo contenido con metadatos adicionales",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: application/json\nX-Cache: HIT\nX-CDN-Server: edge-server-42\nAge: 3600\n\n{\"data\": \"cached content\"}",
                "explanation": "El CDN sirve contenido en caché y añade encabezados propios que no venían del servidor origen"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.4",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613641/4_jesleh.png",
                "alt": "Imagen que representa el nombre del código 203 Non-Authoritative Information"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619769/8-removebg-preview_cd7hdi.png",
                "alt": "Imagen del código 203 Non-Authoritative Information"
            }
        ]
    },
    {
        "code": 204,
        "status": "No Content",
        "category": "Success",
        "description": "El código 204 No Content indica que el servidor ha procesado exitosamente la solicitud pero no devuelve ningún contenido en el cuerpo de la respuesta. Este código es semánticamente diferente de 200 OK en que explícitamente comunica que no hay contenido para devolver, lo cual es la intención, no un error. La respuesta 204 no debe contener un cuerpo de mensaje - el mensaje termina después de los encabezados. Este código es extremadamente útil en APIs REST para operaciones que modifican el estado del servidor pero no necesitan devolver datos al cliente, como eliminaciones exitosas, actualizaciones donde el cliente ya tiene todos los datos necesarios, o acciones que simplemente cambian el estado sin generar nueva información. Es también común en solicitudes PUT o PATCH donde el cliente envía la representación completa del recurso y no necesita que el servidor la devuelva. El código 204 ahorra ancho de banda al no enviar cuerpos de respuesta innecesarios y hace que las APIs sean más eficientes. En aplicaciones web, una respuesta 204 típicamente no causa que el navegador actualice la página actual, lo cual es útil para operaciones AJAX que modifican datos en el servidor sin necesitar recargar la interfaz.",
        "useCases": [
            "Eliminación exitosa de recursos (DELETE requests)",
            "Actualizaciones que no requieren devolver el recurso modificado",
            "Operaciones de guardado automático donde no se necesita confirmación con datos",
            "Acciones que cambian estado del servidor sin generar nueva información",
            "Heartbeats o keep-alive requests",
            "Operaciones batch donde solo importa el éxito, no los detalles"
        ],
        "examples": [
            {
                "scenario": "Eliminación de un recurso",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token123",
                "response": "HTTP/1.1 204 No Content\nDate: Tue, 16 Jan 2024 15:00:00 GMT",
                "explanation": "El usuario fue eliminado exitosamente, no hay contenido adicional que devolver"
            },
            {
                "scenario": "Actualización de preferencias de usuario",
                "request": "PUT /api/users/123/preferences HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"theme\": \"dark\",\n  \"language\": \"es\",\n  \"notifications\": true\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "Las preferencias fueron actualizadas exitosamente, el cliente ya tiene los datos que envió"
            },
            {
                "scenario": "Guardado automático de documento",
                "request": "PATCH /api/documents/456/autosave HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\n\n{\n  \"content\": \"Updated document content...\",\n  \"last_modified\": \"2024-01-16T15:05:00Z\"\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "El documento fue guardado automáticamente sin necesidad de respuesta con contenido"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.5",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613653/5_efixbc.png",
                "alt": "Imagen que representa el nombre del código 204 No Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619773/9-removebg-preview_wavvrt.png",
                "alt": "Imagen del código 204 No Content"
            }
        ]
    },
    {
        "code": 205,
        "status": "Reset Content",
        "category": "Success",
        "description": "El código 205 Reset Content indica que el servidor ha procesado exitosamente la solicitud y está instruyendo al agente de usuario (típicamente un navegador) a resetear la vista del documento que causó la solicitud a su estado original. A diferencia de 204 No Content, que simplemente no devuelve contenido, 205 específicamente solicita que el cliente reinicie la interfaz de usuario. Este código es particularmente útil en aplicaciones de formularios web donde, después de enviar datos exitosamente, se desea limpiar el formulario para permitir al usuario ingresar nuevos datos sin necesidad de recargar la página completa. Por ejemplo, en un formulario de entrada de datos repetitiva (como ingreso de inventario, registro de múltiples transacciones, o captura de datos en serie), después de cada envío exitoso, el servidor puede responder con 205 para resetear el formulario automáticamente. Al igual que 204, la respuesta 205 no debe contener un cuerpo de mensaje. La diferencia clave es la semántica: 204 dice 'éxito, sin más información', mientras que 205 dice 'éxito, y por favor resetea tu interfaz'. En la práctica moderna, este código es poco utilizado ya que muchas aplicaciones manejan el reseteo de formularios directamente en el cliente con JavaScript, pero sigue siendo válido y útil para aplicaciones tradicionales basadas en formularios HTML.",
        "useCases": [
            "Formularios de entrada de datos repetitiva donde se quiere limpiar campos después del envío",
            "Aplicaciones de encuestas o cuestionarios que permiten múltiples respuestas",
            "Sistemas de captura de datos en serie (inventario, transacciones, registros)",
            "Formularios de búsqueda donde se quiere limpiar los criterios después de ejecutar la búsqueda",
            "Interfaces de administración con formularios que se usan repetidamente"
        ],
        "examples": [
            {
                "scenario": "Formulario de entrada de inventario",
                "request": "POST /inventory/add HTTP/1.1\nHost: warehouse.example.com\nContent-Type: application/x-www-form-urlencoded\n\nproduct_id=ABC123&quantity=50&location=warehouse-a",
                "response": "HTTP/1.1 205 Reset Content\nDate: Tue, 16 Jan 2024 15:10:00 GMT",
                "explanation": "El item fue agregado al inventario y el navegador debe limpiar el formulario para la siguiente entrada"
            },
            {
                "scenario": "Formulario de comentarios/feedback",
                "request": "POST /feedback/submit HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n  \"rating\": 5,\n  \"comment\": \"Excellent service!\",\n  \"category\": \"support\"\n}",
                "response": "HTTP/1.1 205 Reset Content",
                "explanation": "El feedback fue registrado y el formulario debe resetearse para permitir otro envío"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.6",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613651/6_blwgmz.png",
                "alt": "Imagen que representa el nombre del código 205 Reset Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619776/10-removebg-preview_lt16pz.png",
                "alt": "Imagen del código 205 Reset Content"
            }
        ]
    },
    {
        "code": 206,
        "status": "Partial Content",
        "category": "Success",
        "description": "El código 206 Partial Content indica que el servidor está entregando solo una parte del recurso solicitado debido a un encabezado Range enviado por el cliente. Este código es fundamental para la descarga de archivos grandes, streaming de video/audio, y para permitir la reanudación de descargas interrumpidas. Cuando un cliente solicita un rango específico de bytes de un recurso (por ejemplo, bytes 0-1023 de un archivo de 100MB), el servidor responde con 206 y solo los bytes solicitados. La respuesta debe incluir encabezados Content-Range que especifican qué porción del recurso se está enviando y el tamaño total del recurso, y Content-Length que indica el tamaño de la porción actual. Este mecanismo es esencial para aplicaciones de streaming donde el cliente puede solicitar chunks específicos de un video o audio, para administradores de descargas que dividen archivos grandes en múltiples segmentos para descargar en paralelo, y para reanudar descargas interrumpidas solicitando solo la porción faltante. Los navegadores modernos y reproductores de video utilizan extensivamente este código para permitir la búsqueda dentro de videos (cuando mueves la barra de progreso), para cargar solo las porciones visibles de archivos PDF grandes, o para implementar lazy loading eficiente de recursos multimedia.",
        "useCases": [
            "Streaming de video y audio (permitiendo seek/skip)",
            "Descarga resumible de archivos grandes",
            "Descarga paralela de archivos en múltiples segmentos",
            "Visualización de porciones específicas de documentos grandes (PDFs)",
            "Optimización de ancho de banda cargando solo lo necesario",
            "Implementación de lazy loading para contenido multimedia"
        ],
        "examples": [
            {
                "scenario": "Solicitud de rango de bytes de un video",
                "request": "GET /videos/movie.mp4 HTTP/1.1\nHost: cdn.example.com\nRange: bytes=1000000-2999999",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: video/mp4\nContent-Length: 2000000\nContent-Range: bytes 1000000-2999999/500000000\nAccept-Ranges: bytes\n\n[2MB de datos de video]",
                "explanation": "El servidor envía 2MB específicos del video (del byte 1M al byte 3M) de un total de 500MB"
            },
            {
                "scenario": "Reanudación de descarga interrumpida",
                "request": "GET /downloads/software.zip HTTP/1.1\nHost: downloads.example.com\nRange: bytes=50000000-",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: application/zip\nContent-Length: 50000000\nContent-Range: bytes 50000000-99999999/100000000\nAccept-Ranges: bytes\n\n[50MB restantes del archivo]",
                "explanation": "La descarga se reanuda desde el byte 50M hasta el final del archivo de 100MB"
            },
            {
                "scenario": "Descarga paralela con múltiples rangos",
                "request": "GET /files/large-dataset.dat HTTP/1.1\nHost: data.example.com\nRange: bytes=0-10485759,10485760-20971519",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=BOUNDARY_STRING\nContent-Length: 20971520\n\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 0-10485759/1073741824\n\n[primeros 10MB]\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 10485760-20971519/1073741824\n\n[siguientes 10MB]\n--BOUNDARY_STRING--",
                "explanation": "El cliente solicita dos rangos simultáneos para descarga paralela"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613659/7_ts5rgr.png",
                "alt": "Imagen que representa el nombre del código 206 Partial Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619763/11-removebg-preview_krzu2a.png",
                "alt": "Imagen del código 206 Partial Content"
            }
        ]
    },
    {
        "code": 207,
        "status": "Multi-Status",
        "category": "Success",
        "description": "El código 207 Multi-Status es utilizado principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para transmitir información sobre múltiples recursos cuando la operación sobre varios recursos puede tener resultados variados. A diferencia de otros códigos de estado que aplican a toda la respuesta, 207 indica que el cuerpo del mensaje contiene un documento XML con múltiples códigos de estado de respuesta, uno para cada recurso o sub-operación involucrada. Esto es esencial cuando se realizan operaciones sobre colecciones de recursos donde algunos pueden tener éxito y otros fallar. Por ejemplo, al intentar eliminar una carpeta con 10 archivos, 5 podrían eliminarse exitosamente (200), 3 podrían estar bloqueados (423), y 2 podrían no existir (404). El código 207 permite comunicar todos estos estados diferentes en una sola respuesta estructurada. El cuerpo de la respuesta típicamente contiene XML con elementos <response> para cada recurso, cada uno con su propio <status> y potencialmente <propstat> para propiedades. Esto hace que las operaciones batch sean más eficientes y permite al cliente manejar éxitos y fallos parciales de manera granular sin necesidad de múltiples requests individuales.",
        "useCases": [
            "Operaciones WebDAV sobre múltiples archivos o carpetas (PROPFIND, COPY, MOVE, DELETE)",
            "Operaciones batch en APIs que procesan múltiples recursos",
            "Sincronización de colecciones de recursos donde algunos pueden fallar",
            "Consultas de propiedades sobre múltiples recursos simultáneamente",
            "Operaciones de backup o restauración de múltiples archivos"
        ],
        "examples": [
            {
                "scenario": "PROPFIND sobre una colección de archivos",
                "request": "PROPFIND /documents/ HTTP/1.1\nHost: webdav.example.com\nDepth: 1\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <getcontentlength/>\n    <getlastmodified/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 1234\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/documents/file1.pdf</href>\n    <propstat>\n      <prop>\n        <getcontentlength>4500</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 12:00:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/file2.docx</href>\n    <propstat>\n      <prop>\n        <getcontentlength>15000</getcontentlength>\n        <getlastmodified>Tue, 16 Jan 2024 09:30:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/protected.txt</href>\n    <propstat>\n      <status>HTTP/1.1 403 Forbidden</status>\n    </propstat>\n  </response>\n</multistatus>",
                "explanation": "El servidor devuelve propiedades de múltiples archivos, algunos exitosos (200) y uno con acceso denegado (403)"
            },
            {
                "scenario": "Operación COPY batch sobre múltiples recursos",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup-folder/\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/source-folder/document1.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/document2.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/locked-file.dat</href>\n    <status>HTTP/1.1 423 Locked</status>\n  </response>\n</multistatus>",
                "explanation": "Algunos archivos se copiaron exitosamente mientras uno estaba bloqueado"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613656/8_gh0rl4.png",
                "alt": "Imagen que representa el nombre del código 207 Multi-Status"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619766/12-removebg-preview_xsybjn.png",
                "alt": "Imagen del código 207 Multi-Status"
            }
        ]
    },
    {
        "code": 208,
        "status": "Already Reported",
        "category": "Success",
        "description": "El código 208 Already Reported es utilizado exclusivamente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para evitar la enumeración repetida de recursos internos en respuestas Multi-Status. Este código representa una optimización crítica cuando se trabaja con bindings WebDAV, que son esencialmente referencias o enlaces a recursos que pueden aparecer en múltiples ubicaciones dentro de una jerarquía de carpetas. Cuando un cliente realiza una operación PROPFIND con profundidad infinita sobre una colección que contiene múltiples bindings (enlaces, referencias, o aliases) apuntando al mismo recurso subyacente, sin el código 208 la respuesta incluiría información completa del mismo recurso múltiples veces, una por cada binding. Esto no solo infla innecesariamente el tamaño de la respuesta XML sino que también consume recursos de procesamiento tanto en el servidor como en el cliente. El código 208 permite al servidor reportar el recurso completo la primera vez que lo encuentra durante el traversal de la jerarquía, y luego usar 208 Already Reported para las referencias subsecuentes al mismo recurso. Esto es análogo a cómo los lenguajes de programación manejan referencias circulares en estructuras de datos - la primera vez que encuentras un objeto lo procesas completamente, las siguientes veces solo indicas 'ya vimos esto'. En sistemas de archivos modernos con soporte para hard links, enlaces simbólicos, o sistemas distribuidos donde el mismo archivo puede ser accesible desde múltiples rutas virtuales, este código es esencial para mantener las respuestas manejables. La implementación correcta de 208 requiere que el servidor mantenga un registro de qué recursos ya ha incluido en la respuesta actual para evitar duplicación. Es importante notar que este código solo tiene sentido en el contexto de una respuesta 207 Multi-Status y específicamente en operaciones WebDAV que pueden atravesar colecciones con múltiples referencias.",
        "useCases": [
            "Operaciones PROPFIND recursivas sobre colecciones con bindings WebDAV duplicados",
            "Prevención de duplicación en listados de recursos en sistemas con hard links",
            "Optimización de respuestas en traversal de jerarquías con enlaces simbólicos",
            "Reducción del tamaño de respuestas XML en operaciones sobre estructuras complejas de carpetas",
            "Sistemas de archivos distribuidos donde el mismo recurso tiene múltiples rutas de acceso",
            "Implementaciones de versionado donde múltiples versiones pueden compartir contenido subyacente"
        ],
        "examples": [
            {
                "scenario": "PROPFIND recursivo con bindings duplicados",
                "request": "PROPFIND /workspace/projects/ HTTP/1.1\nHost: webdav.example.com\nDepth: infinity\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <displayname/>\n    <getcontentlength/>\n    <getcontenttype/>\n    <resourcetype/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/workspace/projects/shared-library/utils.js</href>\n    <propstat>\n      <prop>\n        <displayname>utils.js</displayname>\n        <getcontentlength>45000</getcontentlength>\n        <getcontenttype>application/javascript</getcontenttype>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/workspace/projects/project-a/lib/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-b/dependencies/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-c/shared/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El archivo utils.js es compartido por múltiples proyectos mediante bindings. Se reporta completamente solo la primera vez, las subsecuentes referencias usan 208 para evitar duplicación innecesaria de datos."
            },
            {
                "scenario": "Traversal de sistema con hard links",
                "request": "PROPFIND /storage/backups/ HTTP/1.1\nHost: dav.example.com\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/storage/backups/2024-01/database.dump</href>\n    <propstat>\n      <prop>\n        <displayname>database.dump</displayname>\n        <getcontentlength>524288000</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 02:00:00 GMT</getlastmodified>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/storage/backups/2024-02/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/storage/backups/latest/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El mismo archivo de backup está vinculado en múltiples directorios mediante hard links para deduplicación. Solo se reporta una vez con sus propiedades completas."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 5842, Section 7.1",
        "relatedCodes": [
            207
        ],
        "technicalNotes": "Este código solo es válido dentro del contexto de una respuesta 207 Multi-Status. El servidor debe implementar lógica para rastrear qué recursos ya han sido reportados durante el traversal de la jerarquía actual. No debe usarse fuera del contexto WebDAV.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613636/9_vly4qs.png",
                "alt": "Imagen que representa el nombre del código 208 Already Reported"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619797/13-removebg-preview_snc3fy.png",
                "alt": "Imagen del código 208 Already Reported"
            }
        ]
    },
    {
        "code": 214,
        "status": "Transformation Applied",
        "category": "Success (Warning Code)",
        "description": "El código 214 Transformation Applied es un código de advertencia HTTP que se transmite a través del encabezado Warning, no como código de estado HTTP principal. Los códigos de advertencia proporcionan información adicional sobre el estado de la respuesta que puede no ser evidente solo con el código de estado. El 214 específicamente informa al cliente que un intermediario (proxy, gateway, CDN) ha aplicado alguna transformación al contenido del mensaje antes de entregarlo. Estas transformaciones pueden ser dramáticas o sutiles: desde conversión de formatos de imagen (JPEG a WebP), transcodificación de video para diferentes dispositivos, compresión agresiva, minificación de código, aplicación de filtros de contenido, hasta modificación de resoluciones o tasas de bits. A diferencia del código de estado 203 Non-Authoritative Information que indica modificación de metadatos (encabezados), el código 214 se enfoca específicamente en transformaciones del cuerpo del mensaje. El formato del encabezado Warning es: 'Warning: 214 agent \"Transformation Applied\" \"descripción detallada\"' donde 'agent' identifica el intermediario que aplicó la transformación y la descripción explica qué se modificó. Esto es crucial para transparencia, debugging, y cumplimiento de políticas de contenido. Por ejemplo, un desarrollador depurando por qué una imagen se ve diferente en producción vs desarrollo puede ver el warning 214 y entender que un CDN está optimizando las imágenes. O un sistema de validación de contenido puede verificar que las transformaciones aplicadas cumplen con políticas corporativas. Los proxies modernos de optimización web, CDNs con procesamiento inteligente de assets, y gateways de adaptación de contenido para diferentes tipos de red (3G, 4G, 5G, WiFi) utilizan extensivamente este mecanismo. Es especialmente importante en contextos móviles donde los operadores de red pueden aplicar optimizaciones agresivas para reducir consumo de datos.",
        "useCases": [
            "Proxies de optimización que comprimen imágenes para reducir ancho de banda en redes lentas",
            "CDNs que convierten formatos de imagen a WebP o AVIF para navegadores compatibles",
            "Transcodificación automática de video según capacidades del dispositivo cliente",
            "Minificación y bundling de archivos JavaScript/CSS por intermediarios",
            "Aplicación de filtros de contenido corporativos o gubernamentales",
            "Adaptación de resolución de imágenes según tipo de conexión (WiFi vs móvil)",
            "Compresión adicional aplicada por operadores móviles en redes congestionadas",
            "Conversión de documentos a formatos más ligeros (por ejemplo, reducir calidad de PDFs)"
        ],
        "examples": [
            {
                "scenario": "CDN optimizando imagen para móvil",
                "request": "GET /assets/hero-image.jpg HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0...)\nAccept: image/webp,image/jpeg,*/*",
                "response": "HTTP/1.1 200 OK\nContent-Type: image/webp\nContent-Length: 28000\nWarning: 214 cdn.example.com \"Transformation Applied\" \"Original JPEG (150KB) converted to WebP format and compressed to 28KB for mobile optimization\"\nVary: Accept, User-Agent\nX-Original-Format: image/jpeg\nX-Original-Size: 153600\nVia: 1.1 cdn.example.com\n\n[WebP image data]",
                "explanation": "El CDN detectó un iPhone con soporte para WebP, convirtió la imagen original JPEG, aplicó compresión agresiva, y notificó la transformación mediante Warning 214."
            },
            {
                "scenario": "Proxy de operador móvil comprimiendo contenido",
                "request": "GET /download/whitepaper.pdf HTTP/1.1\nHost: docs.example.com\nVia: 1.1 mobile-proxy.carrier.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/pdf\nContent-Length: 450000\nWarning: 214 mobile-proxy.carrier.com \"Transformation Applied\" \"PDF images recompressed to reduce file size from 2.5MB to 450KB for data saving on mobile network\"\nX-Data-Saver-Applied: true\nX-Original-Size: 2621440\n\n[compressed PDF data]",
                "explanation": "El proxy del operador móvil aplicó compresión agresiva al PDF para ahorrar datos del plan del usuario."
            },
            {
                "scenario": "Transcodificación de video adaptativa",
                "request": "GET /videos/tutorial.mp4 HTTP/1.1\nHost: media.example.com\nUser-Agent: Mozilla/5.0 (Linux; Android 12...)",
                "response": "HTTP/1.1 200 OK\nContent-Type: video/mp4\nContent-Length: 15000000\nWarning: 214 video-gateway.example.com \"Transformation Applied\" \"Video transcoded from 1080p H.265 to 480p H.264 for Android device with limited bandwidth\"\nX-Original-Resolution: 1920x1080\nX-Original-Codec: hevc\nX-Transcoded-Resolution: 854x480\nX-Transcoded-Codec: h264\n\n[transcoded video data]",
                "explanation": "El gateway de video detectó un dispositivo Android en una conexión lenta y transcodificó el video a menor resolución y codec más compatible."
            },
            {
                "scenario": "Minificación de JavaScript por proxy corporativo",
                "request": "GET /js/app.js HTTP/1.1\nHost: cdn.example.com\nVia: 1.1 corporate-proxy.company.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/javascript\nContent-Length: 85000\nWarning: 214 corporate-proxy.company.com \"Transformation Applied\" \"JavaScript minified and comments removed, reduced from 245KB to 85KB\"\nX-Original-Size: 250880\nX-Minified: true\n\n[minified JavaScript code]",
                "explanation": "Un proxy corporativo minificó automáticamente el JavaScript para optimizar el ancho de banda de la red empresarial."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7234, Section 5.5",
        "headerFormat": "Warning: 214 agent \"Transformation Applied\" \"detailed description\"",
        "relatedHeaders": [
            "Via",
            "X-Original-Size",
            "X-Transformed-By",
            "Vary"
        ],
        "technicalNotes": "Este es un código de advertencia (Warning code), no un código de estado HTTP. Se transmite mediante el encabezado Warning. Múltiples advertencias pueden estar presentes en una sola respuesta. Los códigos de advertencia en el rango 2xx indican que no hubo error pero hay información adicional importante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613638/10_rezx3u.png",
                "alt": "Imagen que representa el nombre del código 214 Transformation Applied"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619790/14-removebg-preview_ypwtjm.png",
                "alt": "Imagen del código 214 Transformation Applied"
            }
        ]
    },
    {
        "code": 226,
        "status": "IM Used",
        "category": "Success",
        "description": "El código 226 IM Used (Instance Manipulation Used) indica que el servidor ha cumplido exitosamente con una solicitud GET para un recurso, pero en lugar de devolver la representación completa del recurso, está devolviendo el resultado de aplicar una o más manipulaciones de instancia (Instance Manipulations o IM) a la instancia actual del recurso. Este código es parte del framework de delta encoding especificado en RFC 3229, un mecanismo sofisticado diseñado para optimizar dramáticamente el uso de ancho de banda cuando los clientes solicitan recursos que han cambiado solo parcialmente desde una versión anterior que ya poseen. El concepto fundamental es simple pero poderoso: si tienes la versión 1 de un documento de 10MB y el servidor tiene la versión 2, en lugar de descargar los 10MB completos nuevamente, el servidor puede enviar solo un 'delta' (diferencia) de quizás 500KB que describe los cambios. El cliente entonces aplica este delta a su versión local para reconstruir la versión 2. El encabezado A-IM (Accept Instance Manipulation) en la solicitud especifica qué tipos de deltas o manipulaciones el cliente puede procesar (por ejemplo: vcdiff, gdiff, diffe, gzip). El servidor responde con 226 y el encabezado IM indica qué manipulación fue aplicada, mientras que Delta-Base identifica la versión base usada para calcular el delta. Este mecanismo es especialmente valioso para documentos grandes que evolucionan incrementalmente: bases de datos, archivos de configuración extensos, imágenes satelitales con actualizaciones periódicas, datasets científicos, o código fuente versionado. Aunque técnicamente poderoso, 226 es raramente implementado en la web moderna porque requiere soporte sofisticado tanto del cliente como del servidor, incluyendo algoritmos de diff/patch, gestión de versiones, y lógica de fallback. Muchos desarrolladores prefieren soluciones más simples como versionado de recursos con ETags para cacheo, o dividir recursos grandes en chunks más pequeños.",
        "useCases": [
            "Sincronización eficiente de archivos grandes con cambios incrementales (bases de datos, logs)",
            "Actualización de datasets científicos o geoespaciales que cambian parcialmente",
            "Distribución de actualizaciones de software mediante deltas en lugar de instaladores completos",
            "APIs que sirven documentos versionados donde el cliente probablemente tiene versiones anteriores",
            "Sistemas de colaboración en documentos grandes con control de versiones",
            "Optimización de ancho de banda en enlaces satelitales o conexiones lentas costosas",
            "Sincronización de repositorios de código fuente sobre HTTP (similar a Git pero vía HTTP puro)"
        ],
        "examples": [
            {
                "scenario": "Delta encoding con formato vcdiff",
                "request": "GET /datasets/weather-data.csv HTTP/1.1\nHost: data.example.com\nA-IM: vcdiff, diffe\nIf-None-Match: \"v2024-01-15-abc123\"\nAccept-Encoding: gzip",
                "response": "HTTP/1.1 226 IM Used\nETag: \"v2024-01-16-def456\"\nIM: vcdiff\nDelta-Base: \"v2024-01-15-abc123\"\nContent-Type: application/x-vcdiff\nContent-Encoding: gzip\nContent-Length: 125000\nCache-Control: private, must-revalidate\n\n[gzipped vcdiff delta data]",
                "explanation": "El cliente tiene los datos meteorológicos del 15 de enero. El servidor envía solo los cambios del 16 de enero usando formato vcdiff comprimido con gzip, reduciendo la transferencia de 50MB completos a solo 125KB de delta."
            },
            {
                "scenario": "Actualización incremental de documento JSON grande",
                "request": "GET /api/products-catalog.json HTTP/1.1\nHost: api.example.com\nA-IM: json-patch, json-merge-patch\nIf-None-Match: \"catalog-v105\"",
                "response": "HTTP/1.1 226 IM Used\nETag: \"catalog-v106\"\nIM: json-patch\nDelta-Base: \"catalog-v105\"\nContent-Type: application/json-patch+json\nContent-Length: 3500\n\n[\n  {\"op\": \"replace\", \"path\": \"/products/42/price\", \"value\": 29.99},\n  {\"op\": \"replace\", \"path\": \"/products/42/stock\", \"value\": 150},\n  {\"op\": \"add\", \"path\": \"/products/999\", \"value\": {\n    \"id\": 999,\n    \"name\": \"New Product\",\n    \"price\": 49.99,\n    \"stock\": 50\n  }},\n  {\"op\": \"remove\", \"path\": \"/products/123\"}\n]",
                "explanation": "En lugar de enviar todo el catálogo de productos (5MB), el servidor envía un JSON Patch (3.5KB) con solo los cambios: actualizaciones de precio/stock de un producto, adición de un producto nuevo, y eliminación de un producto descontinuado."
            },
            {
                "scenario": "Sincronización de base de datos SQLite",
                "request": "GET /db/application.db HTTP/1.1\nHost: sync.example.com\nA-IM: gdiff\nIf-None-Match: \"db-snapshot-20240115-120000\"\nRange: bytes=0-",
                "response": "HTTP/1.1 226 IM Used\nETag: \"db-snapshot-20240116-140000\"\nIM: gdiff\nDelta-Base: \"db-snapshot-20240115-120000\"\nContent-Type: application/x-gdiff\nContent-Length: 450000\n\n[gdiff binary delta data]",
                "explanation": "El cliente sincroniza una base de datos SQLite de 250MB. Solo han cambiado algunas tablas (nuevas filas, actualizaciones). El servidor calcula un delta binario de 450KB usando gdiff, evitando transferir los 250MB completos."
            },
            {
                "scenario": "Fallback cuando delta no es posible",
                "request": "GET /documents/report.pdf HTTP/1.1\nHost: docs.example.com\nA-IM: vcdiff\nIf-None-Match: \"report-v1\"",
                "response": "HTTP/1.1 200 OK\nETag: \"report-v5\"\nContent-Type: application/pdf\nContent-Length: 2500000\nVary: A-IM, If-None-Match\n\n[complete PDF file]",
                "explanation": "El cliente tiene la versión 1 pero la versión actual es 5. Los cambios son tan extensos que el delta sería casi tan grande como el archivo completo, o el servidor no tiene la versión intermedia. Se envía el archivo completo con código 200 en lugar de 226."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 3229, Section 10.4.1",
        "relatedHeaders": [
            "A-IM (Accept-Instance-Manipulation)",
            "IM (Instance-Manipulation)",
            "Delta-Base",
            "If-None-Match",
            "ETag"
        ],
        "deltaFormats": {
            "vcdiff": "Binary delta encoding format (RFC 3284), muy eficiente para archivos binarios",
            "gdiff": "Generic diff format, usado para diferencias binarias",
            "diffe": "Ed-style diff, basado en comandos de edición",
            "json-patch": "RFC 6902, para documentos JSON estructurados",
            "json-merge-patch": "RFC 7396, merge patches para JSON"
        },
        "technicalNotes": "El servidor debe almacenar versiones anteriores o calcular deltas on-the-fly. La implementación requiere algoritmos sofisticados de diff/patch. Si calcular el delta es más costoso que enviar el recurso completo, el servidor debe usar 200 OK. Los clientes deben implementar lógica de fallback para cuando 200 se recibe en lugar de 226.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613648/11_ozqx4y.png",
                "alt": "Imagen que representa el nombre del código 226 IM Used"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619794/15-removebg-preview_yxl4gy.png",
                "alt": "Imagen del código 226 IM Used"
            }
        ]
    },
    {
        "code": 300,
        "status": "Multiple Choices",
        "category": "Redirection",
        "description": "El código 300 Multiple Choices indica que el recurso solicitado corresponde a múltiples representaciones diferentes, cada una con su propia ubicación específica, y se está proporcionando información para que el agente de usuario (o el usuario final) pueda seleccionar una representación preferida y redirigir su solicitud a esa ubicación. Este código representa una situación de negociación de contenido donde el servidor no puede o no quiere tomar automáticamente la decisión sobre cuál variante servir. Es fundamentalmente diferente de otros códigos de redirección porque no impone una única redirección, sino que ofrece opciones. La respuesta debe incluir una lista de las alternativas disponibles junto con sus ubicaciones y características distintivas, permitiendo que el cliente (o usuario) haga una elección informada. Por ejemplo, un documento podría estar disponible en múltiples formatos (PDF, HTML, DOCX), idiomas (inglés, español, francés), o versiones (para principiantes, intermedio, avanzado). El servidor podría responder con 300 y proporcionar enlaces a todas estas variantes. El cuerpo de la respuesta típicamente contiene un documento HTML con enlaces a las diferentes opciones, o puede usar el encabezado Location para sugerir una opción preferida mientras lista otras alternativas en el cuerpo. En la práctica moderna, 300 es raramente utilizado porque los servidores generalmente implementan negociación de contenido automática basada en encabezados Accept, Accept-Language, Accept-Encoding del cliente, eligiendo la mejor representación y devolviéndola directamente con código 200 OK, o usando redirecciones 302/303 para dirigir automáticamente a una variante específica. Sin embargo, 300 sigue siendo útil en escenarios donde la elección tiene implicaciones significativas que no pueden ser determinadas automáticamente, como diferentes niveles de detalle de documentación, versiones con diferentes licencias, o formatos que requieren diferentes aplicaciones.",
        "useCases": [
            "Documentos disponibles en múltiples formatos que requieren elección explícita del usuario",
            "Contenido multilingüe donde el servidor no puede determinar automáticamente el idioma preferido",
            "Diferentes versiones de un recurso (simplificada, completa, técnica) donde la elección depende del contexto",
            "Recursos con múltiples licencias donde el usuario debe seleccionar términos específicos",
            "APIs que ofrecen múltiples endpoints para la misma funcionalidad con diferentes características",
            "Contenido disponible en diferentes niveles de calidad o resolución",
            "Archivos disponibles desde múltiples servidores mirror donde el usuario debe elegir el más cercano"
        ],
        "examples": [
            {
                "scenario": "Documento en múltiples formatos",
                "request": "GET /documentation/user-guide HTTP/1.1\nHost: docs.example.com\nAccept: */*",
                "response": "HTTP/1.1 300 Multiple Choices\nLocation: /documentation/user-guide.html\nContent-Type: text/html; charset=utf-8\nVary: Accept\n\n<!DOCTYPE html>\n<html>\n<head><title>Multiple Formats Available</title></head>\n<body>\n  <h1>User Guide - Multiple Formats</h1>\n  <p>This documentation is available in several formats:</p>\n  <ul>\n    <li><a href=\"/documentation/user-guide.html\">HTML Version</a></li>\n    <li><a href=\"/documentation/user-guide.pdf\">PDF Version</a></li>\n    <li><a href=\"/documentation/user-guide.epub\">EPUB Version</a></li>\n    <li><a href=\"/documentation/user-guide.docx\">DOCX Version</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El servidor ofrece el mismo contenido en cuatro formatos diferentes. El encabezado Location sugiere HTML como opción predeterminada, pero el usuario puede elegir cualquier formato según sus necesidades."
            },
            {
                "scenario": "Contenido multilingüe sin preferencia clara",
                "request": "GET /welcome HTTP/1.1\nHost: www.example.com\nAccept-Language: *",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: text/html; charset=utf-8\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head><title>Language Selection</title></head>\n<body>\n  <h1>Please select your language</h1>\n  <ul>\n    <li><a href=\"/welcome?lang=en\" hreflang=\"en\">English</a></li>\n    <li><a href=\"/welcome?lang=es\" hreflang=\"es\">Español</a></li>\n    <li><a href=\"/welcome?lang=fr\" hreflang=\"fr\">Français</a></li>\n    <li><a href=\"/welcome?lang=de\" hreflang=\"de\">Deutsch</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El cliente no especificó una preferencia clara de idioma, por lo que el servidor presenta todas las opciones de idioma disponibles para que el usuario elija."
            },
            {
                "scenario": "API con múltiples versiones",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: application/json\nLocation: /api/v3/data\n\n{\n  \"message\": \"Multiple API versions available\",\n  \"versions\": [\n    {\n      \"version\": \"v1\",\n      \"url\": \"/api/v1/data\",\n      \"status\": \"deprecated\"\n    },\n    {\n      \"version\": \"v2\",\n      \"url\": \"/api/v2/data\",\n      \"status\": \"stable\"\n    },\n    {\n      \"version\": \"v3\",\n      \"url\": \"/api/v3/data\",\n      \"status\": \"recommended\"\n    }\n  ]\n}",
                "explanation": "El endpoint base de la API devuelve información sobre todas las versiones disponibles, permitiendo que el cliente elija según sus necesidades de estabilidad versus características nuevas."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.1",
        "relatedHeaders": [
            "Location",
            "Vary",
            "Content-Type",
            "Link"
        ],
        "technicalNotes": "Aunque especificado en HTTP/1.0, es raramente usado en la práctica moderna. La mayoría de los servidores implementan content negotiation automática usando encabezados Accept-* y devuelven 200 OK con la mejor representación, o usan 302/303 para redirigir automáticamente.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/300_gepcv9.png",
                "alt": "Imagen que representa el nombre del código 300 Multiple Choices"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/16-removebg-preview_pobkgs.png",
                "alt": "Imagen del código 300 Multiple Choices"
            }
        ]
    },
    {
        "code": 301,
        "status": "Moved Permanently",
        "category": "Redirection",
        "description": "El código 301 Moved Permanently indica que el recurso solicitado ha sido movido permanentemente a una nueva ubicación URI, y todas las referencias futuras a este recurso deben usar una de las URIs devueltas. Este es uno de los códigos de redirección más importantes y ampliamente utilizados en HTTP, fundamental para SEO, mantenimiento de sitios web, y reorganización de estructuras de URLs. La palabra clave aquí es 'permanentemente' - este código comunica tanto a navegadores como a motores de búsqueda que el cambio es definitivo y no temporal. Los motores de búsqueda como Google, cuando encuentran un 301, transferirán el 'link juice' (valor SEO) del URL antiguo al nuevo, actualizarán sus índices, y eventualmente dejarán de rastrear el URL antiguo. Los navegadores típicamente almacenan en caché redirecciones 301, lo que significa que en visitas futuras pueden ir directamente al nuevo URL sin siquiera consultar el servidor sobre el URL antiguo. La respuesta debe incluir un encabezado Location con la nueva URI del recurso. Es crucial usar 301 correctamente: solo debe usarse cuando estás absolutamente seguro de que el movimiento es permanente. Si hay alguna posibilidad de que el recurso regrese al URL original en el futuro, usa 302 o 307 en su lugar. Las aplicaciones comunes incluyen: migración de HTTP a HTTPS, cambio de nombres de dominio, reestructuración de sitios web, consolidación de contenido duplicado, normalización de URLs (con/sin www, con/sin trailing slash), y redirección de páginas antiguas a nuevas versiones. Un uso inadecuado de 301 puede causar problemas graves: si rediriges permanentemente y luego intentas restaurar el URL original, los navegadores con caché pueden seguir redirigiendo automáticamente incluso después de que hayas eliminado la redirección del servidor.",
        "useCases": [
            "Migración permanente de HTTP a HTTPS para todo un sitio web",
            "Cambio de nombre de dominio (example.com a newbrand.com)",
            "Reestructuración de URLs (/old-page.html a /new-structure/page)",
            "Consolidación de contenido duplicado hacia una URL canónica",
            "Normalización de URLs (www.example.com a example.com o viceversa)",
            "Redirección de trailing slash (/page a /page/ o viceversa)",
            "Movimiento permanente de recursos a CDN o subdominios",
            "Redirección de páginas de productos discontinuados a categorías o alternativas",
            "Migración de plataformas (WordPress a Jamstack, cambio de CMS)",
            "Internacionalización (example.com/page a example.com/en/page)"
        ],
        "examples": [
            {
                "scenario": "Migración HTTP a HTTPS",
                "request": "GET /secure-page HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/secure-page\nContent-Type: text/html; charset=UTF-8\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"https://example.com/secure-page\">here</a>.</p>\n</body>\n</html>",
                "explanation": "El sitio ha migrado permanentemente a HTTPS. Todas las solicitudes HTTP son redirigidas a sus equivalentes HTTPS. Los motores de búsqueda actualizarán sus índices para usar HTTPS."
            },
            {
                "scenario": "Cambio de nombre de dominio",
                "request": "GET /products/widget-x HTTP/1.1\nHost: oldcompany.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://newcompany.com/products/widget-x\nCache-Control: max-age=31536000, immutable",
                "explanation": "La empresa cambió de nombre y dominio. Redirección permanente con caché de 1 año para maximizar eficiencia. Los motores de búsqueda transferirán el valor SEO al nuevo dominio."
            },
            {
                "scenario": "Reestructuración de URLs SEO-friendly",
                "request": "GET /page.php?id=123&category=electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://shop.example.com/electronics/products/smartphone-pro-123\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Moved</title>\n  <link rel=\"canonical\" href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">\n</head>\n<body>\n  <h1>This page has moved permanently</h1>\n  <p>New URL: <a href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">Smartphone Pro</a></p>\n</body>\n</html>",
                "explanation": "URLs antiguas con parámetros query son redirigidas permanentemente a URLs amigables para SEO. Incluye canonical tag para reforzar la URL correcta."
            },
            {
                "scenario": "Normalización www vs non-www",
                "request": "GET / HTTP/1.1\nHost: www.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/\nStrict-Transport-Security: max-age=31536000; includeSubDomains",
                "explanation": "Normalización permanente hacia versión sin www. Incluye HSTS para forzar HTTPS en futuras visitas y mejorar la seguridad."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.2",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Vary",
            "Link",
            "Deprecation",
            "Sunset"
        ],
        "technicalNotes": "En HTTP/1.0, la especificación permitía que navegadores cambiaran el método de POST a GET al seguir un 301. HTTP/1.1 clarificó que el método debe preservarse, pero muchos navegadores aún cambian POST a GET por compatibilidad histórica. Para comportamiento predecible con POST requests, usa 308 en su lugar. Los navegadores cachean 301 agresivamente incluso sin Cache-Control explícito.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/301_wdshbj.png",
                "alt": "Imagen que representa el nombre del código 301 Moved Permanently"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/17-removebg-preview_uthv3h.png",
                "alt": "Imagen del código 301 Moved Permanently"
            }
        ]
    },
    {
        "code": 302,
        "status": "Found",
        "category": "Redirection",
        "description": "El código 302 Found (originalmente 'Moved Temporarily' en HTTP/1.0) indica que el recurso solicitado reside temporalmente bajo una URI diferente. A diferencia de 301 que señala un cambio permanente, 302 comunica que el recurso puede volver a su ubicación original en el futuro, o que su ubicación temporal puede cambiar. Esta distinción es crucial tanto para navegadores como para motores de búsqueda. Los navegadores generalmente NO cachean redirecciones 302 de forma agresiva, lo que significa que seguirán consultando el URL original en futuras visitas. Los motores de búsqueda mantienen el URL original en sus índices y continúan rastreándolo, no transfieren el 'link juice' al URL de destino. El encabezado Location especifica la URI temporal donde el recurso puede encontrarse actualmente. El código 302 es históricamente ambiguo en cuanto al manejo del método HTTP: aunque la especificación HTTP/1.1 dice que el método de solicitud no debe cambiar al seguir la redirección, en la práctica la mayoría de los navegadores cambian POST a GET cuando siguen un 302. Esta inconsistencia llevó a la creación de códigos más específicos: 303 See Other (explícitamente cambia a GET) y 307 Temporary Redirect (explícitamente preserva el método). Sin embargo, 302 sigue siendo extremadamente común en la web moderna y es el código de redirección temporal por defecto en muchos frameworks y servidores web. Los casos de uso típicos incluyen: redirecciones post-login, redirecciones después de operaciones POST (pattern Post-Redirect-Get), mantenimiento temporal de sitios, A/B testing, distribución de carga entre servidores, redirecciones basadas en geolocalización, y páginas temporales de campaña de marketing.",
        "useCases": [
            "Redirección post-login a dashboard o página de perfil",
            "Patrón Post-Redirect-Get (PRG) para prevenir reenvíos de formularios",
            "Mantenimiento temporal del sitio (redirigir a página de mantenimiento)",
            "A/B testing y experimentos de usuario",
            "Redirecciones basadas en geolocalización o detección de idioma",
            "Páginas temporales de campaña de marketing o eventos",
            "Distribución temporal de carga entre servidores espejo",
            "Redirecciones condicionales basadas en cookies, sesión, o headers",
            "URLs cortas temporales para campañas (bit.ly, tinyurl)",
            "Redirección durante migraciones graduales (canary deployments)"
        ],
        "examples": [
            {
                "scenario": "Redirección post-login",
                "request": "POST /login HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=john&password=secret123",
                "response": "HTTP/1.1 302 Found\nLocation: https://example.com/dashboard\nSet-Cookie: session_id=abc123xyz; HttpOnly; Secure; SameSite=Lax\nCache-Control: no-store, no-cache, must-revalidate",
                "explanation": "Después de autenticación exitosa, el usuario es redirigido temporalmente a su dashboard. Se establece una cookie de sesión y se previene el cacheo de la redirección."
            },
            {
                "scenario": "Patrón Post-Redirect-Get (PRG)",
                "request": "POST /orders/create HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"product_id\": 456,\n  \"quantity\": 2\n}",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/orders/confirmation/789\nX-Order-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"order_id\": 789\n}",
                "explanation": "Después de crear la orden (POST), el servidor redirige a una página de confirmación (GET). Esto previene que el usuario reenvíe la orden accidentalmente al refrescar la página."
            },
            {
                "scenario": "Página de mantenimiento temporal",
                "request": "GET /products/electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/maintenance\nRetry-After: 3600\nCache-Control: no-cache, no-store\n\n<!DOCTYPE html>\n<html>\n<head><title>Temporary Maintenance</title></head>\n<body>\n  <h1>Scheduled Maintenance</h1>\n  <p>We're performing system upgrades. Please check back in 1 hour.</p>\n</body>\n</html>",
                "explanation": "Durante mantenimiento, las páginas redirigen temporalmente a una página de mantenimiento. Retry-After sugiere cuándo reintentar. La redirección es temporal porque las páginas normales volverán después del mantenimiento."
            },
            {
                "scenario": "Redirección basada en geolocalización",
                "request": "GET / HTTP/1.1\nHost: www.globalshop.com\nAccept-Language: es-MX\nX-Forwarded-For: 189.203.10.5",
                "response": "HTTP/1.1 302 Found\nLocation: https://www.globalshop.com/mx/\nVary: Accept-Language, X-Forwarded-For\nSet-Cookie: geo_region=mx; Path=/; Max-Age=86400\nCache-Control: private, no-cache",
                "explanation": "El servidor detecta que el usuario está en México y redirige temporalmente a la versión mexicana del sitio. La redirección es temporal porque el usuario podría estar viajando o usando VPN."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.3",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "Set-Cookie"
        ],
        "technicalNotes": "302 es históricamente ambiguo: la especificación dice preservar el método, pero la mayoría de los navegadores cambian POST a GET. Para comportamiento explícito: usa 303 (fuerza GET) o 307 (preserva método). Las redirecciones 302 generalmente NO se cachean agresivamente. Los motores de búsqueda mantienen el URL original en índices y no transfieren SEO value.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701320/302_pr9ato.png",
                "alt": "Imagen que representa el nombre del código 302 Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/18-removebg-preview_qckrk0.png",
                "alt": "Imagen del código 302 Found"
            }
        ]
    },
    {
        "code": 303,
        "status": "See Other",
        "category": "Redirection",
        "description": "El código 303 See Other indica que el servidor está redirigiendo al cliente a un recurso diferente, identificado por el URI en el encabezado Location, y que la respuesta a la solicitud original puede ser encontrada allí usando una solicitud GET. La característica distintiva y crucial de 303 es que SIEMPRE requiere que el cliente use el método GET para la solicitud redirigida, sin importar qué método HTTP se usó en la solicitud original. Esto lo hace perfectamente adecuado para el patrón Post-Redirect-Get (PRG), una de las mejores prácticas más importantes en desarrollo web. El código 303 fue introducido en HTTP/1.1 específicamente para eliminar la ambigüedad del código 302, que teóricamente debería preservar el método pero en la práctica los navegadores lo cambian a GET. Con 303, este comportamiento está explícitamente codificado en la especificación: si un servidor responde con 303 a una solicitud POST, el navegador DEBE hacer una solicitud GET al URL en el encabezado Location. Esto resuelve el problema clásico de 'duplicación de envíos de formularios' donde un usuario envía un formulario (POST), ve la página de confirmación, y luego al refrescar el navegador, se le pregunta si quiere reenviar el formulario. Con 303, el flujo es: (1) usuario envía formulario con POST, (2) servidor procesa y responde 303 con Location a página de confirmación, (3) navegador hace GET a esa página de confirmación, (4) usuario ve confirmación y puede refrescar sin problemas porque ahora es un GET simple. El código 303 es semánticamente diferente de 302 y 307: mientras que 302 es ambiguo y 307 preserva explícitamente el método, 303 explícitamente cambia a GET. Es la elección correcta para cualquier situación donde procesas una operación de modificación de estado (POST, PUT, DELETE) y quieres redirigir al usuario a una representación del resultado.",
        "useCases": [
            "Implementación del patrón Post-Redirect-Get (PRG) después de envíos de formularios",
            "Redirección después de operaciones POST, PUT, DELETE en APIs REST",
            "Confirmaciones de operaciones que modifican estado (creación, actualización, eliminación)",
            "Redirección después de procesamiento de pagos o transacciones",
            "Redirigir desde endpoint de acción a vista de recurso",
            "Prevenir reenvíos accidentales de formularios al refrescar navegador",
            "Redirección de operaciones asíncronas completadas a página de resultados",
            "Upload de archivos seguido de redirección a página de vista previa"
        ],
        "examples": [
            {
                "scenario": "Patrón Post-Redirect-Get clásico",
                "request": "POST /contact HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&email=john%40example.com&message=Hello",
                "response": "HTTP/1.1 303 See Other\nLocation: https://example.com/contact/thank-you\nCache-Control: no-cache, no-store, must-revalidate\nX-Message-ID: msg_123456\n\n<!DOCTYPE html>\n<html>\n<head><title>Message Sent</title></head>\n<body>\n  <p>Your message has been sent successfully.</p>\n  <p>Redirecting to confirmation page...</p>\n</body>\n</html>",
                "explanation": "Después de procesar el formulario de contacto (POST), el servidor redirige con 303 a una página de agradecimiento. El navegador hará GET a /contact/thank-you. Si el usuario refresca, solo re-hace el GET, no reenvía el formulario."
            },
            {
                "scenario": "Creación de recurso en API REST",
                "request": "POST /api/articles HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token_abc123\n\n{\n  \"title\": \"Understanding HTTP 303\",\n  \"content\": \"The 303 status code is...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://blog.example.com/api/articles/789\nX-Article-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"message\": \"Article published successfully\",\n  \"article_id\": 789,\n  \"view_url\": \"/api/articles/789\"\n}",
                "explanation": "El artículo fue creado exitosamente. En lugar de devolver 201 Created, el servidor usa 303 para indicar que el cliente debe hacer GET a /api/articles/789 para ver el recurso completo. Esto separa claramente la operación de creación (POST) de la recuperación (GET)."
            },
            {
                "scenario": "Procesamiento de pago con redirección",
                "request": "POST /checkout/process-payment HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_visa_1234\",\n  \"cart_id\": \"cart_xyz789\"\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://shop.example.com/orders/confirmation/ord_456\nX-Order-ID: ord_456\nX-Transaction-ID: txn_789xyz\nSet-Cookie: cart_id=; Max-Age=0; Path=/\nCache-Control: no-store, no-cache\n\n{\n  \"status\": \"payment_successful\",\n  \"order_id\": \"ord_456\",\n  \"confirmation_url\": \"/orders/confirmation/ord_456\"\n}",
                "explanation": "Después de procesar el pago exitosamente, el servidor redirige con 303 a la página de confirmación de orden. Esto previene que el usuario accidentalmente procese el pago dos veces si refresca la página."
            },
            {
                "scenario": "Eliminación de recurso con redirección a lista",
                "request": "DELETE /api/users/123 HTTP/1.1\nHost: admin.example.com\nAuthorization: Bearer admin_token_xyz\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 303 See Other\nLocation: https://admin.example.com/api/users\nX-Deleted-User-ID: 123\nCache-Control: no-cache\n\n{\n  \"status\": \"deleted\",\n  \"message\": \"User account deleted successfully\",\n  \"deleted_user_id\": 123,\n  \"redirect_to\": \"/api/users\"\n}",
                "explanation": "Después de eliminar el usuario (DELETE), el servidor redirige con 303 a la lista de usuarios. El cliente hará GET a /api/users para ver la lista actualizada sin el usuario eliminado."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.4",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "X-Request-ID",
            "X-Resource-ID"
        ],
        "technicalNotes": "303 fue introducido en HTTP/1.1 para resolver la ambigüedad de 302. El método SIEMPRE cambia a GET - esto no es un bug, es la característica principal. Los navegadores SIEMPRE cambian el método a GET cuando siguen una redirección 303, sin importar el método original (POST, PUT, DELETE). Si necesitas preservar el método, usa 307 en su lugar.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/303_b4nnly.png",
                "alt": "Imagen que representa el nombre del código 303 See Other"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685324/19-removebg-preview_akkhp7.png",
                "alt": "Imagen del código 303 See Other"
            }
        ]
    },
    {
        "code": 304,
        "status": "Not Modified",
        "category": "Redirection",
        "description": "El código 304 Not Modified es un código de estado especial que indica que el recurso no ha sido modificado desde la versión especificada por los encabezados de solicitud condicional del cliente (If-Modified-Since, If-None-Match), y por lo tanto el cliente puede usar su copia en caché. Este código es fundamental para la optimización del rendimiento web y el ahorro de ancho de banda. A diferencia de otros códigos de redirección, 304 no redirige a una ubicación diferente, sino que instruye al cliente a usar la copia que ya tiene almacenada localmente. El flujo típico funciona así: (1) cliente hace una solicitud inicial GET y recibe 200 OK con el recurso completo más encabezados ETag y/o Last-Modified, (2) cliente almacena el recurso en caché junto con estos validadores, (3) en solicitudes subsecuentes, cliente incluye If-None-Match (con el ETag) y/o If-Modified-Since (con la fecha), (4) servidor verifica si el recurso cambió comparando con los validadores, (5) si NO cambió, servidor responde 304 sin cuerpo de mensaje - solo headers, (6) cliente usa su versión cacheada. Esto ahorra ancho de banda significativo porque solo se transmiten headers (aproximadamente 200-500 bytes) en lugar del recurso completo (que podría ser megabytes). La respuesta 304 NUNCA debe contener un cuerpo de mensaje - el mensaje termina inmediatamente después de los encabezados. Debe incluir headers que habrían sido enviados con 200 OK si el recurso hubiera sido modificado, específicamente: Date, ETag, Cache-Control, Expires, Vary. El código 304 es esencial para: carga eficiente de sitios web con muchos assets estáticos, APIs que sirven datos que cambian infrecuentemente, distribución de contenido mediante CDNs, reducción de carga en servidores de origen, mejora de velocidad percibida por usuarios, y optimización de consumo de datos en dispositivos móviles.",
        "useCases": [
            "Validación de caché para assets estáticos (imágenes, CSS, JavaScript)",
            "APIs que sirven datos que cambian infrecuentemente",
            "Verificación de actualizaciones de recursos sin transferir todo el contenido",
            "Optimización de rendimiento en sitios web con muchos recursos",
            "Reducción de ancho de banda en aplicaciones móviles",
            "Implementación de polling eficiente para verificar cambios",
            "CDN edge caching y validación con servidores origen",
            "Sincronización eficiente de recursos entre cliente y servidor"
        ],
        "examples": [
            {
                "scenario": "Validación con ETag - recurso no modificado",
                "request": "GET /assets/logo.png HTTP/1.1\nHost: cdn.example.com\nIf-None-Match: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: max-age=0",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:00:00 GMT\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: public, max-age=31536000, immutable\nVary: Accept-Encoding\nX-Cache: HIT",
                "explanation": "El cliente tiene logo.png con ETag específico. El servidor verifica que el archivo no ha cambiado (mismo ETag) y responde 304. El navegador usa su copia cacheada. No se transmite la imagen, ahorrando ancho de banda significativo."
            },
            {
                "scenario": "Validación con Last-Modified - recurso no modificado",
                "request": "GET /api/products.json HTTP/1.1\nHost: api.example.com\nIf-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:05:00 GMT\nLast-Modified: Mon, 15 Jan 2024 10:00:00 GMT\nCache-Control: private, must-revalidate, max-age=3600\nVary: Accept",
                "explanation": "El cliente pregunta si products.json cambió desde el 15 de enero. No ha cambiado, entonces el servidor responde 304. Cliente usa su copia cacheada, ahorrando potencialmente varios MB de datos JSON."
            },
            {
                "scenario": "Validación con ETag - recurso SÍ modificado",
                "request": "GET /news/latest-article HTTP/1.1\nHost: blog.example.com\nIf-None-Match: \"old-etag-abc123\"\nAccept: text/html",
                "response": "HTTP/1.1 200 OK\nDate: Tue, 16 Jan 2024 19:10:00 GMT\nETag: \"new-etag-xyz789\"\nLast-Modified: Tue, 16 Jan 2024 18:00:00 GMT\nContent-Type: text/html; charset=utf-8\nCache-Control: public, max-age=600\n\n<!DOCTYPE html>\n<html>\n<head><title>Breaking News Updated!</title></head>\n<body>\n  <article>\n    <h1>Major Update to Story</h1>\n    <p>New information has emerged...</p>\n  </article>\n</body>\n</html>",
                "explanation": "El artículo fue actualizado (ETag diferente), entonces el servidor responde 200 OK con el contenido completo actualizado y nuevo ETag. El cliente reemplaza su caché con la nueva versión."
            },
            {
                "scenario": "API polling eficiente",
                "request": "GET /api/notifications HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nIf-None-Match: W/\"notifications-hash-abc\"\nX-Polling-Interval: 30",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:20:00 GMT\nETag: W/\"notifications-hash-abc\"\nCache-Control: private, no-cache, must-revalidate\nX-Poll-Interval: 30",
                "explanation": "Cliente hace polling cada 30 segundos para notificaciones. No hay nuevas notificaciones, entonces 304. Esto es muchísimo más eficiente que transferir la lista completa de notificaciones en cada poll."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7232, Section 4.1",
        "relatedHeaders": [
            "If-Modified-Since",
            "If-None-Match",
            "ETag",
            "Last-Modified",
            "Date",
            "Cache-Control",
            "Expires",
            "Vary"
        ],
        "technicalNotes": "La respuesta 304 NUNCA debe incluir un cuerpo de mensaje. DEBE incluir Date header. DEBE incluir ETag y/o Last-Modified si estaban en la respuesta 200 original. DEBE incluir Cache-Control y Expires si aplican. NO debe incluir Content-Length porque no hay cuerpo. Los navegadores automáticamente incluyen If-None-Match/If-Modified-Since cuando revalidan recursos cacheados.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/304_ot5mbk.png",
                "alt": "Imagen que representa el nombre del código 304 Not Modified"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/20-removebg-preview_mnc4wo.png",
                "alt": "Imagen del código 304 Not Modified"
            }
        ]
    },
    {
        "code": 305,
        "status": "Use Proxy",
        "category": "Redirection",
        "description": "El código 305 Use Proxy indica que el recurso solicitado debe ser accedido a través de un proxy especificado en el encabezado Location. Este código fue definido en versiones anteriores de la especificación HTTP pero ha sido DEPRECADO en HTTP/1.1 debido a serias preocupaciones de seguridad. El código 305 fue diseñado originalmente para permitir que los servidores indiquen a los clientes que deben acceder a un recurso específico a través de un proxy particular. Sin embargo, esta funcionalidad presentaba riesgos significativos de seguridad ya que permitía que servidores potencialmente maliciosos obligaran a los clientes a enrutar su tráfico a través de proxies no confiables, lo que podría resultar en ataques man-in-the-middle, interceptación de datos sensibles, modificación de contenido, o redirección a sitios maliciosos. Debido a estos riesgos, la mayoría de los navegadores modernos y clientes HTTP ignoran completamente el código 305 y nunca lo implementaron correctamente. El código fue formalmente deprecado y las implementaciones modernas NO deben usarlo ni responder a él. En lugar de 305, las configuraciones de proxy deben ser manejadas a nivel de sistema operativo, configuración de red, o mediante configuración explícita del usuario en la aplicación cliente (como las configuraciones de proxy en navegadores). La especificación HTTP/1.1 revisada recomienda explícitamente NO usar este código bajo ninguna circunstancia. Si un servidor necesita comunicar información sobre proxies, debe hacerlo a través de otros mecanismos más seguros como encabezados informativos personalizados, documentación fuera de banda, o configuración manual del cliente. El código 305 representa un ejemplo importante en la evolución de HTTP de cómo consideraciones de seguridad pueden llevar a la deprecación de características que parecían útiles pero resultaron ser vectores de ataque potenciales.",
        "useCases": [
            "NINGUNO - Este código está DEPRECADO y NO debe ser usado",
            "Históricamente fue diseñado para indicar uso de proxy, pero fue abandonado por riesgos de seguridad",
            "No tiene casos de uso válidos en implementaciones modernas"
        ],
        "examples": [
            {
                "scenario": "Ejemplo histórico (NO usar en producción)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 305 Use Proxy\nLocation: http://proxy.example.com:8080\n\n[Este código está DEPRECADO y no debe ser usado]",
                "explanation": "Este es solo un ejemplo histórico de cómo se habría usado 305. En la práctica moderna, este código NUNCA debe ser usado debido a graves riesgos de seguridad. Los navegadores modernos lo ignoran completamente."
            },
            {
                "scenario": "Respuesta moderna correcta (usar configuración de proxy apropiada)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nX-Proxy-Info: For proxy configuration, see https://example.com/proxy-setup\n\n{\n  \"message\": \"Resource accessed successfully\",\n  \"proxy_documentation\": \"https://example.com/proxy-setup\"\n}",
                "explanation": "En lugar de usar 305 deprecado, proporciona información sobre configuración de proxy a través de documentación o headers informativos. La configuración de proxy debe manejarse a nivel de cliente, no mediante respuestas HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1 (DEPRECADO)",
        "specification": "RFC 7231, Section 6.4.5 (marcado como deprecado)",
        "relatedHeaders": [
            "Location"
        ],
        "technicalNotes": "Este código está OFICIALMENTE DEPRECADO desde HTTP/1.1. Fue removido de la especificación debido a serias preocupaciones de seguridad. Los navegadores modernos NO lo implementan y lo ignoran. Representaba un vector de ataque para man-in-the-middle. NUNCA debe ser usado en implementaciones nuevas. Las configuraciones de proxy deben manejarse a nivel de sistema operativo, configuración de red del usuario, o PAC (Proxy Auto-Config) files, NO mediante respuestas HTTP.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/305_paioqd.png",
                "alt": "Imagen que representa el nombre del código 305 Use Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/21-removebg-preview_vr87er.png",
                "alt": "Imagen del código 305 Use Proxy"
            }
        ]
    },
    {
        "code": 306,
        "status": "Switch Proxy",
        "category": "Redirection",
        "description": "El código 306 Switch Proxy es un código de estado que ya no se utiliza en las especificaciones HTTP modernas y está completamente OBSOLETO. Este código fue definido en una versión preliminar de la especificación HTTP/1.1 pero nunca llegó a ser parte del estándar oficial final. Originalmente, el código 306 estaba destinado a indicar que las solicitudes subsecuentes deben usar el proxy especificado, similar en concepto al deprecado 305 Use Proxy, pero con la intención de que fuera utilizado en solicitudes futuras en lugar de la solicitud actual. Sin embargo, debido a las mismas preocupaciones graves de seguridad que llevaron a la deprecación del código 305, el código 306 fue eliminado completamente de la especificación antes de su finalización. El código 306 nunca fue ampliamente implementado por navegadores o servidores web, y hoy en día no tiene ningún significado definido en HTTP. Si un servidor envía un código 306, los clientes modernos no sabrán cómo manejarlo correctamente. En la especificación oficial RFC 7231 de HTTP/1.1, el código 306 simplemente está marcado como '(Unused)' - no utilizado. El espacio del código 306 fue reservado pero nunca se le asignó un significado oficial, y permanece sin uso en todas las versiones modernas de HTTP. Esto representa un caso interesante en el desarrollo de estándares donde un código fue propuesto, asignado un número, pero luego abandonado antes de la ratificación final del estándar. A diferencia del 305 que fue oficialmente deprecado después de ser parte del estándar, el 306 simplemente nunca llegó a existir oficialmente. En implementaciones modernas, este código no debe ser usado bajo ninguna circunstancia y si se encuentra en respuestas, debe ser tratado como un error desconocido o no válido.",
        "useCases": [
            "NINGUNO - Este código está completamente OBSOLETO y nunca fue parte del estándar oficial",
            "No tiene significado definido en HTTP moderno",
            "Fue abandonado antes de la finalización de HTTP/1.1",
            "No debe ser usado en ninguna implementación"
        ],
        "examples": [
            {
                "scenario": "Código obsoleto sin uso oficial",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 306 (Unused)\n\n[Este código NO tiene significado oficial y NO debe ser usado]",
                "explanation": "El código 306 nunca fue oficialmente definido en el estándar HTTP final. Si un servidor responde con 306, los clientes modernos no sabrán cómo manejarlo. Este código simplemente no debe ser usado."
            },
            {
                "scenario": "Manejo correcto en cliente moderno",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "Si un cliente recibe 306:\n- Debe tratarlo como un código de estado desconocido\n- Puede registrar un error o advertencia\n- No debe intentar interpretarlo como una redirección válida\n- Debería fallar la solicitud o usar comportamiento de fallback",
                "explanation": "Los clientes modernos correctamente implementados no tienen lógica especial para manejar 306 porque nunca fue parte del estándar. Si se encuentra, indica un problema de configuración del servidor."
            }
        ],
        "httpVersion": "HTTP/1.1 (NUNCA OFICIALIZADO)",
        "specification": "RFC 7231 - marcado como '(Unused)' / Sin uso oficial",
        "relatedHeaders": [],
        "technicalNotes": "El código 306 fue propuesto en borradores tempranos de HTTP/1.1 pero fue eliminado antes de la especificación final. En RFC 7231, aparece listado como '306 (Unused)' indicando que el número está reservado pero sin significado asignado. A diferencia del 305 que fue deprecado después de uso, el 306 simplemente nunca existió oficialmente. NO debe ser implementado ni usado en sistemas modernos. Su presencia en listados de códigos HTTP es puramente histórica.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701322/306_egqdxk.png",
                "alt": "Imagen que representa el nombre del código 306 Switch Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/22-removebg-preview_q8lfzw.png",
                "alt": "Imagen del código 306 Switch Proxy"
            }
        ]
    },
    {
        "code": 307,
        "status": "Temporary Redirect",
        "category": "Redirection",
        "description": "El código 307 Temporary Redirect indica que el recurso solicitado reside temporalmente bajo una URI diferente, y el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. Esta es la diferencia crítica y el propósito principal del código 307: garantizar que el método HTTP se preserve durante la redirección. Mientras que el código 302 Found es históricamente ambiguo (la especificación dice preservar el método, pero los navegadores cambian POST a GET en la práctica), el código 307 elimina toda ambigüedad al requerir explícitamente que el método se mantenga idéntico. Si la solicitud original fue POST, la solicitud redirigida también debe ser POST. Si fue DELETE, la redirigida también debe ser DELETE. Esto es esencial en escenarios donde el método HTTP tiene significado semántico importante y cambiarlo podría causar comportamiento incorrecto o inseguro. Por ejemplo, si un cliente envía una solicitud POST con datos importantes a un servidor que responde con redirección, es crucial que esos datos sean enviados al nuevo destino también con POST, no convertidos a GET (que podría perder los datos del cuerpo o exponerlos en la URL). El código 307 fue introducido en HTTP/1.1 específicamente para proporcionar una versión sin ambigüedades del 302 que preserve el método. Al igual que 302, el 307 indica que la redirección es temporal, no permanente, por lo que los motores de búsqueda deben mantener el URL original en sus índices y los navegadores no deben cachear la redirección de forma agresiva. Los casos de uso comunes incluyen: mantenimiento temporal donde se necesita redirigir solicitudes POST, balanceo de carga que preserva el método de la solicitud, redirecciones de API donde el método es crítico para la semántica de la operación, y cualquier escenario de redirección temporal donde cambiar el método HTTP sería semánticamente incorrecto o podría causar pérdida de datos.",
        "useCases": [
            "Redirecciones temporales donde preservar el método HTTP es crítico",
            "Mantenimiento temporal de APIs que manejan POST, PUT, DELETE",
            "Balanceo de carga entre servidores manteniendo el método original",
            "Redirecciones de APIs RESTful donde el método define la operación",
            "Migración gradual de endpoints preservando semántica del método",
            "Redirección temporal de uploads (POST con archivos)",
            "Failover entre servidores sin cambiar la naturaleza de la solicitud",
            "Testing A/B de APIs donde el método debe mantenerse consistente"
        ],
        "examples": [
            {
                "scenario": "Redirección POST preservando el método",
                "request": "POST /api/orders HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"product_id\": 789,\n  \"quantity\": 3,\n  \"customer_id\": 456,\n  \"shipping_address\": \"123 Main St\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-backup.example.com/api/orders\nRetry-After: 120\nCache-Control: no-cache, no-store\nX-Redirect-Reason: primary_server_maintenance\n\n{\n  \"message\": \"Primary server under maintenance\",\n  \"redirect_to\": \"https://api-backup.example.com/api/orders\",\n  \"note\": \"Your request will be resubmitted automatically\"\n}",
                "explanation": "El servidor principal está en mantenimiento temporal. La redirección 307 asegura que el navegador/cliente reenvíe la solicitud POST completa con todos los datos del pedido al servidor de backup, sin cambiar a GET que perdería los datos."
            },
            {
                "scenario": "Balanceo de carga con método preservado",
                "request": "PUT /api/users/123/profile HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john.new@example.com\",\n  \"phone\": \"+1234567890\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-node-2.example.com/api/users/123/profile\nX-Load-Balancer: round-robin\nX-Target-Node: node-2\nCache-Control: no-cache\n\n{\n  \"status\": \"redirecting\",\n  \"target_server\": \"node-2\",\n  \"message\": \"Request being routed to optimal server node\"\n}",
                "explanation": "El load balancer redirige temporalmente la solicitud PUT a otro nodo del cluster. El código 307 garantiza que la solicitud PUT con los datos de actualización del perfil se envíe al nuevo servidor, no se convierta en GET."
            },
            {
                "scenario": "Upload de archivo con redirección temporal",
                "request": "POST /api/uploads HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data; boundary=----Boundary\nContent-Length: 5242880\n\n------Boundary\nContent-Disposition: form-data; name=\"file\"; filename=\"report.pdf\"\nContent-Type: application/pdf\n\n[5MB de datos del archivo PDF]\n------Boundary--",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://storage-region-2.example.com/api/uploads\nX-Storage-Region: us-west-2\nX-Redirect-Reason: region_optimization\nRetry-After: 0\n\n{\n  \"message\": \"Redirecting to optimal storage region\",\n  \"target_region\": \"us-west-2\",\n  \"note\": \"File upload will be resubmitted automatically\"\n}",
                "explanation": "El sistema de storage detecta que el usuario está más cerca de otra región y redirige temporalmente. El código 307 asegura que el POST con el archivo completo se reenvíe al servidor de la nueva región sin perder datos."
            },
            {
                "scenario": "Mantenimiento de API con DELETE preservado",
                "request": "DELETE /api/articles/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_abc\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-maintenance.example.com/api/articles/456\nX-Maintenance-Mode: true\nX-Estimated-Duration: 1800\nCache-Control: no-store\n\n{\n  \"status\": \"maintenance_redirect\",\n  \"message\": \"Main API under scheduled maintenance\",\n  \"maintenance_endpoint\": \"https://api-maintenance.example.com\",\n  \"operation_will_complete\": true\n}",
                "explanation": "Durante mantenimiento programado, las solicitudes DELETE son redirigidas a un servidor de mantenimiento que puede procesarlas. El 307 preserva el método DELETE para que la operación de eliminación se ejecute correctamente en el nuevo servidor."
            },
            {
                "scenario": "Migración gradual de endpoints",
                "request": "PATCH /api/v2/settings/notifications HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\n\n{\n  \"email_notifications\": false,\n  \"push_notifications\": true\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://new-api.example.com/api/v2/settings/notifications\nX-Migration-Phase: gradual-rollout\nX-Legacy-Endpoint: deprecated\nDeprecation: true\nLink: <https://docs.example.com/api-migration>; rel=\"deprecation\"\n\n{\n  \"message\": \"This endpoint is being migrated to new infrastructure\",\n  \"new_location\": \"https://new-api.example.com/api/v2/settings/notifications\",\n  \"migration_guide\": \"https://docs.example.com/api-migration\"\n}",
                "explanation": "Durante una migración gradual de API, el endpoint antiguo redirige temporalmente al nuevo con 307, preservando el método PATCH y los datos de actualización de configuración."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.7",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "X-Redirect-Reason"
        ],
        "technicalNotes": "El código 307 fue introducido en HTTP/1.1 para eliminar la ambigüedad del 302. La diferencia clave es que 307 GARANTIZA que el método HTTP se preserve (POST sigue siendo POST, PUT sigue siendo PUT, etc.), mientras que 302 en la práctica causa que navegadores cambien POST a GET. Para redirecciones temporales donde el método debe preservarse, siempre usa 307. Para redirecciones temporales donde cambiar a GET es aceptable o deseado, usa 302 o mejor aún 303. Los navegadores NO cachean 307 agresivamente, similar a 302. Los motores de búsqueda mantienen el URL original en índices.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701321/307_zejcdc.png",
                "alt": "Imagen que representa el nombre del código 307 Temporary Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/23-removebg-preview_lguvh9.png",
                "alt": "Imagen del código 307 Temporary Redirect"
            }
        ]
    },
    {
        "code": 308,
        "status": "Permanent Redirect",
        "category": "Redirection",
        "description": "El código 308 Permanent Redirect indica que el recurso solicitado ha sido movido permanentemente a una nueva URI especificada en el encabezado Location, y todas las futuras solicitudes deben usar la nueva URI. Además, y esto es lo más importante, el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. El código 308 es a 301 lo que 307 es a 302: proporciona una versión sin ambigüedades que garantiza la preservación del método HTTP. Mientras que el código 301 Moved Permanently es históricamente ambiguo (muchos navegadores cambian POST a GET al seguir un 301, aunque la especificación dice preservar el método), el código 308 elimina completamente esta ambigüedad. Si la solicitud original fue POST, la redirigida debe ser POST. Si fue PUT, la redirigida debe ser PUT. Si fue DELETE, la redirigida debe ser DELETE. Esta garantía es crítica para APIs RESTful y aplicaciones donde el método HTTP tiene significado semántico importante. El código 308 fue estandarizado más recientemente que otros códigos de redirección (en RFC 7538 de 2015) para llenar un vacío en la especificación HTTP. Combina dos propiedades importantes: (1) permanencia - como 301, indica que el cambio es definitivo y permanente, los motores de búsqueda deben actualizar índices, los navegadores pueden cachear la redirección, y el valor SEO debe transferirse al nuevo URL; (2) preservación del método - como 307, garantiza que el método HTTP no cambie durante la redirección. Los casos de uso típicos incluyen: reestructuración permanente de APIs donde los métodos deben preservarse, migración permanente de endpoints RESTful, consolidación de servicios manteniendo semántica de métodos HTTP, cambios de infraestructura permanentes donde POST/PUT/DELETE deben mantenerse, y cualquier redirección permanente donde cambiar el método sería semánticamente incorrecto o causaría pérdida de datos.",
        "useCases": [
            "Reestructuración permanente de APIs RESTful preservando métodos HTTP",
            "Migración permanente de endpoints donde POST, PUT, DELETE deben mantenerse",
            "Cambio permanente de dominio para APIs con operaciones de escritura",
            "Consolidación de servicios manteniendo semántica RESTful",
            "Deprecación definitiva de endpoints antiguos hacia nuevos con misma funcionalidad",
            "Migración de infraestructura permanente (on-premise a cloud) preservando métodos",
            "Reorganización de URLs en APIs donde el método HTTP es parte de la semántica",
            "Versioning de APIs con redirección permanente preservando operaciones"
        ],
        "examples": [
            {
                "scenario": "Migración permanente de API endpoint con POST",
                "request": "POST /api/v1/users HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane@example.com\",\n  \"role\": \"admin\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v2/users\nCache-Control: max-age=31536000\nDeprecation: true\nSunset: Mon, 01 Jan 2025 00:00:00 GMT\n\n{\n  \"message\": \"API v1 has been permanently moved to v2\",\n  \"new_endpoint\": \"https://api.example.com/v2/users\",\n  \"documentation\": \"https://docs.example.com/api/v2\",\n  \"note\": \"Please update your integration to use the new endpoint\"\n}",
                "explanation": "La API v1 ha sido permanentemente reemplazada por v2. El código 308 asegura que la solicitud POST con los datos del nuevo usuario se reenvíe al nuevo endpoint manteniendo POST, no convirtiéndose a GET que perdería los datos."
            },
            {
                "scenario": "Cambio permanente de dominio con PUT preservado",
                "request": "PUT /api/products/789 HTTP/1.1\nHost: shop-api.oldcompany.com\nContent-Type: application/json\nAuthorization: Bearer token_abc\n\n{\n  \"name\": \"Updated Product Name\",\n  \"price\": 99.99,\n  \"stock\": 150,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.newcompany.com/api/products/789\nCache-Control: public, max-age=31536000, immutable\nX-Company-Rebrand: true\nLink: <https://www.newcompany.com/api-migration>; rel=\"alternate\"\n\n{\n  \"status\": \"permanent_redirect\",\n  \"message\": \"Our company has rebranded. API permanently moved to new domain.\",\n  \"new_location\": \"https://api.newcompany.com\",\n  \"migration_complete\": true\n}",
                "explanation": "La empresa cambió de marca y dominio permanentemente. El 308 garantiza que la solicitud PUT para actualizar el producto se reenvíe al nuevo dominio manteniendo el método PUT y todos los datos de actualización."
            },
            {
                "scenario": "Reestructuración permanente con DELETE preservado",
                "request": "DELETE /services/old-structure/items/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v3/items/456\nCache-Control: max-age=2592000\nX-API-Restructure: v3-final\n\n{\n  \"message\": \"API structure has been permanently reorganized\",\n  \"old_path\": \"/services/old-structure/items/:id\",\n  \"new_path\": \"/v3/items/:id\",\n  \"operation_preserved\": \"DELETE\",\n  \"note\": \"Your delete operation will complete at the new location\"\n}",
                "explanation": "La estructura de la API fue permanentemente reorganizada. El 308 asegura que la solicitud DELETE se reenvíe a la nueva estructura manteniendo la operación de eliminación, no cambiando a GET."
            },
            {
                "scenario": "Migración cloud permanente con PATCH",
                "request": "PATCH /api/configurations/global HTTP/1.1\nHost: on-premise.example.com\nContent-Type: application/json\n\n{\n  \"maintenance_mode\": false,\n  \"max_connections\": 1000,\n  \"timeout_seconds\": 30\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://cloud-api.example.com/api/configurations/global\nX-Migration-Type: on-premise-to-cloud\nX-Migration-Date: 2024-01-15\nCache-Control: public, max-age=31536000\n\n{\n  \"message\": \"Service permanently migrated to cloud infrastructure\",\n  \"cloud_endpoint\": \"https://cloud-api.example.com\",\n  \"on_premise_shutdown\": \"2024-06-01\",\n  \"benefits\": \"Improved reliability, scalability, and performance\"\n}",
                "explanation": "El servicio fue migrado permanentemente de infraestructura on-premise a cloud. El 308 preserva el método PATCH para que la actualización parcial de configuración se aplique correctamente en el nuevo servidor cloud."
            },
            {
                "scenario": "Consolidación de microservicios con POST",
                "request": "POST /payment-service/api/process HTTP/1.1\nHost: payments.example.com\nContent-Type: application/json\n\n{\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_12345\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://unified-api.example.com/payments/process\nX-Service-Consolidation: microservices-to-unified\nCache-Control: max-age=15552000\n\n{\n  \"message\": \"Payment service consolidated into unified API\",\n  \"new_endpoint\": \"https://unified-api.example.com/payments/process\",\n  \"consolidation_date\": \"2024-01-01\",\n  \"note\": \"All microservices now under unified API gateway\"\n}",
                "explanation": "Múltiples microservicios fueron consolidados en una API unificada permanentemente. El 308 asegura que la solicitud POST de procesamiento de pago con datos sensibles se reenvíe correctamente manteniendo POST."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7538 (2015)",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Deprecation",
            "Sunset",
            "Link"
        ],
        "relatedCodes": [
            301,
            307
        ],
        "technicalNotes": "El código 308 es relativamente nuevo (RFC 7538, 2015) y fue creado para llenar el vacío de un código de redirección permanente que preserve el método HTTP. Es a 301 lo que 307 es a 302. Combina permanencia (como 301) con preservación de método (como 307). Los navegadores modernos lo soportan bien desde ~2015-2016. Al igual que 301, los navegadores y motores de búsqueda deben cachear 308 y actualizar índices. La diferencia crítica con 301 es que 308 GARANTIZA que POST/PUT/DELETE/PATCH se preserven, mientras que 301 históricamente causa que navegadores cambien POST a GET. Para APIs RESTful con redirecciones permanentes, 308 es casi siempre la elección correcta.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/308_ypkqc3.png",
                "alt": "Imagen que representa el nombre del código 308 Permanent Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/24-removebg-preview_ee4zid.png",
                "alt": "Imagen del código 308 Permanent Redirect"
            }
        ]
    },
    {
        "code": 400,
        "status": "Bad Request",
        "category": "Client Error",
        "description": "El código 400 Bad Request indica que el servidor no puede o no procesará la solicitud debido a algo que se percibe como un error del cliente. Este es uno de los códigos de error más comunes y versátiles en HTTP, utilizado como respuesta genérica para una amplia variedad de errores de solicitud del cliente que no encajan en categorías más específicas. El servidor está indicando que la solicitud está malformada, contiene sintaxis inválida, parámetros inválidos, o es imposible de cumplir por razones que son responsabilidad del cliente. Las causas comunes incluyen: JSON o XML mal formado en el cuerpo de la solicitud, parámetros de query string inválidos o que faltan, encabezados HTTP malformados o contradictorios, tamaño de solicitud que excede límites del servidor, errores de codificación de caracteres, valores de datos que no cumplen con reglas de validación, tipos de contenido no soportados, o cualquier otra violación del protocolo HTTP o de las expectativas de la API. A diferencia de errores 5xx que indican problemas del servidor, el 400 señala claramente que el problema está en la solicitud del cliente y que reenviar la misma solicitud sin modificaciones resultará en el mismo error. El cliente debe corregir la solicitud antes de reintentarla. Es importante que las respuestas 400 incluyan información descriptiva en el cuerpo del mensaje explicando qué está mal con la solicitud para ayudar a los desarrolladores a corregir el problema. Una buena respuesta 400 debería especificar: qué campo o parámetro causó el error, qué se esperaba versus qué se recibió, y cómo corregir el problema. En APIs RESTful modernas, es común incluir códigos de error estructurados, mensajes de error detallados, y referencias a documentación. El código 400 es preferible a códigos de error más específicos cuando el error no encaja claramente en categorías como 401 (autenticación), 403 (autorización), 404 (no encontrado), etc.",
        "useCases": [
            "JSON o XML malformado en el cuerpo de la solicitud",
            "Parámetros de query string inválidos, faltantes o mal formateados",
            "Errores de validación de datos de entrada (formatos incorrectos, valores fuera de rango)",
            "Encabezados HTTP contradictorios o malformados",
            "Tamaño de solicitud que excede límites permitidos",
            "Tipo de contenido no soportado o Content-Type incorrecto",
            "Errores de codificación de caracteres en la solicitud",
            "Violaciones de esquema o estructura de datos esperada",
            "Combinaciones inválidas de parámetros",
            "Requests que violan reglas de negocio básicas"
        ],
        "examples": [
            {
                "scenario": "JSON malformado en el cuerpo de la solicitud",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  // Comentario inválido en JSON\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_request_body\",\n  \"message\": \"Request body contains malformed JSON\",\n  \"details\": \"Unexpected token '/' at position 78. JSON does not support comments.\",\n  \"documentation\": \"https://api.example.com/docs/errors/invalid-json\"\n}",
                "explanation": "El JSON en el cuerpo contiene un comentario que no es válido en JSON estándar. El servidor responde con 400 y explica específicamente qué está mal y dónde ocurrió el error."
            },
            {
                "scenario": "Parámetros de validación fallidos",
                "request": "POST /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"AB\",\n  \"price\": -10.50,\n  \"stock\": \"not_a_number\"\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Request validation failed\",\n  \"validation_errors\": [\n    {\n      \"field\": \"name\",\n      \"message\": \"Name must be at least 3 characters long\",\n      \"received\": \"AB\"\n    },\n    {\n      \"field\": \"price\",\n      \"message\": \"Price must be a positive number\",\n      \"received\": -10.50\n    },\n    {\n      \"field\": \"stock\",\n      \"message\": \"Stock must be an integer\",\n      \"received_type\": \"string\"\n    }\n  ]\n}",
                "explanation": "Múltiples campos tienen errores de validación. La respuesta 400 proporciona detalles específicos de cada error, facilitando que el cliente corrija todos los problemas de una vez."
            },
            {
                "scenario": "Parámetros de query string inválidos",
                "request": "GET /api/users?page=abc&limit=-5 HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_query_parameters\",\n  \"message\": \"One or more query parameters are invalid\",\n  \"errors\": [\n    {\n      \"parameter\": \"page\",\n      \"error\": \"Page must be a positive integer\",\n      \"received\": \"abc\"\n    },\n    {\n      \"parameter\": \"limit\",\n      \"error\": \"Limit must be between 1 and 100\",\n      \"received\": -5\n    }\n  ]\n}",
                "explanation": "Los parámetros de paginación contienen valores inválidos. El servidor indica qué parámetros están mal y qué valores son aceptables."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.1",
        "relatedHeaders": [
            "Content-Type",
            "Content-Length"
        ],
        "technicalNotes": "400 es un código de error genérico del cliente. Cuando sea posible, usa códigos más específicos: 401 para autenticación, 403 para autorización, 404 para recursos no encontrados, 405 para métodos no permitidos, 409 para conflictos, 422 para errores de validación semántica. El 400 debe reservarse para errores de sintaxis, malformaciones, o cuando ningún código más específico aplica. Siempre incluye un cuerpo de respuesta descriptivo con detalles del error para facilitar debugging.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712934/400_odwp8l.png",
                "alt": "Imagen que representa el nombre del código 400 Bad Request"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712631/25-removebg-preview_ujorgb.png",
                "alt": "Imagen del código 400 Bad Request"
            }
        ]
    },
    {
        "code": 401,
        "status": "Unauthorized",
        "category": "Client Error",
        "description": "El código 401 Unauthorized indica que la solicitud requiere autenticación del usuario y que las credenciales proporcionadas son inválidas, están ausentes, o han expirado. A pesar de su nombre algo confuso ('Unauthorized'), este código específicamente se refiere a problemas de AUTENTICACIÓN (verificar quién eres), no de AUTORIZACIÓN (verificar qué puedes hacer). El nombre más preciso sería 'Unauthenticated', pero por razones históricas se mantiene como 'Unauthorized'. Cuando un servidor responde con 401, está diciendo: 'No sé quién eres' o 'Las credenciales que proporcionaste no son válidas' o 'Tu sesión ha expirado'. El cliente debe proporcionar credenciales válidas (o renovarlas) para acceder al recurso. La respuesta 401 DEBE incluir un encabezado WWW-Authenticate que especifique el esquema de autenticación que el servidor espera (Basic, Bearer, Digest, etc.). Este encabezado informa al cliente qué tipo de credenciales se requieren y cómo deben ser enviadas. Los escenarios comunes incluyen: intentar acceder a un recurso protegido sin proporcionar token de autenticación, proporcionar un token JWT expirado o inválido, credenciales de usuario/contraseña incorrectas, token de API key inválido o revocado, sesión expirada que necesita renovación, o intentar usar un token de autenticación que fue emitido para otro recurso o dominio. En aplicaciones web modernas, 401 típicamente resulta en redireccionar al usuario a una página de login o mostrar un modal de autenticación. En APIs, puede desencadenar un flujo de renovación de tokens (refresh token flow) o requerir que el usuario vuelva a autenticarse. Es crucial distinguir 401 de 403 Forbidden: usa 401 cuando el problema es que el cliente no está autenticado o sus credenciales son inválidas; usa 403 cuando el cliente está correctamente autenticado pero no tiene permisos para acceder al recurso específico.",
        "useCases": [
            "Acceso a recursos protegidos sin proporcionar token de autenticación",
            "Token JWT expirado que necesita renovación",
            "Credenciales de usuario/contraseña incorrectas en login",
            "API key inválida, revocada o faltante",
            "Sesión de usuario expirada que requiere re-autenticación",
            "Token de autenticación malformado o corrupto",
            "Intentar acceder con credenciales que fueron revocadas",
            "Autenticación de dos factores (2FA) fallida",
            "Token OAuth inválido o expirado",
            "Certificado de cliente inválido o faltante en mTLS"
        ],
        "examples": [
            {
                "scenario": "Acceso sin token de autenticación",
                "request": "GET /api/user/profile HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"authentication_required\",\n  \"message\": \"Authentication is required to access this resource\",\n  \"required_header\": \"Authorization: Bearer <token>\",\n  \"obtain_token\": \"https://api.example.com/auth/login\"\n}",
                "explanation": "La solicitud intenta acceder a un perfil de usuario protegido sin proporcionar ningún token de autenticación. El servidor responde con 401 y el encabezado WWW-Authenticate indicando que se requiere autenticación Bearer."
            },
            {
                "scenario": "Token JWT expirado",
                "request": "GET /api/orders HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired_token.signature",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"The access token expired\"\nContent-Type: application/json\n\n{\n  \"error\": \"token_expired\",\n  \"message\": \"Your access token has expired\",\n  \"expired_at\": \"2024-01-15T10:00:00Z\",\n  \"refresh_endpoint\": \"/auth/refresh\"\n}",
                "explanation": "El token JWT proporcionado es válido estructuralmente pero ha expirado. El servidor indica cuándo expiró y cómo obtener un nuevo token usando el refresh token."
            },
            {
                "scenario": "Credenciales de login incorrectas",
                "request": "POST /auth/login HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"username\": \"john@example.com\",\n  \"password\": \"wrong_password\"\n}",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_credentials\",\n  \"message\": \"The username or password you entered is incorrect\",\n  \"attempts_remaining\": 3,\n  \"lockout_warning\": \"Account will be locked after 5 failed attempts\"\n}",
                "explanation": "El usuario proporcionó credenciales incorrectas. El servidor responde con 401 e información sobre intentos restantes antes de bloqueo de cuenta."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7235, Section 3.1",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization",
            "Proxy-Authenticate",
            "Proxy-Authorization"
        ],
        "technicalNotes": "401 es específicamente para AUTENTICACIÓN (quién eres), no AUTORIZACIÓN (qué puedes hacer). La respuesta DEBE incluir encabezado WWW-Authenticate. Los esquemas comunes son: Basic, Bearer (JWT/OAuth), Digest, OAuth, ApiKey. Distinguir de 403 Forbidden: 401 = no estás autenticado o credenciales inválidas; 403 = estás autenticado pero no autorizado. En aplicaciones web, 401 típicamente resulta en redirect a login; en APIs, puede trigger refresh token flow.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712933/401_bmlwc3.png",
                "alt": "Imagen que representa el nombre del código 401 Unauthorized"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712629/26-removebg-preview_kemtbk.png",
                "alt": "Imagen del código 401 Unauthorized"
            }
        ]
    },
    {
        "code": 402,
        "status": "Payment Required",
        "category": "Client Error",
        "description": "El código 402 Payment Required está RESERVADO para uso futuro y originalmente fue concebido para sistemas de pago digital y micropagos en la web. Este código fue incluido en la especificación original de HTTP con la visión de que la web eventualmente incorporaría sistemas de pago integrados directamente en el protocolo HTTP. La idea era que los servidores pudieran responder con 402 cuando un recurso requiriera pago, y los navegadores tendrían capacidades integradas para manejar transacciones. Sin embargo, más de 30 años después de su creación, el código 402 sigue sin tener una definición formal o implementación estándar. Aunque está reservado oficialmente, NO existe un comportamiento estándar definido para él en las especificaciones HTTP. A pesar de esto, algunas APIs modernas y servicios han comenzado a utilizar 402 de manera no estándar para indicar varios escenarios relacionados con pagos: cuando un usuario ha excedido su cuota de API gratuita y necesita actualizar a un plan de pago, cuando una suscripción ha expirado, cuando se requiere pago para acceder a contenido premium, o cuando un servicio freemium ha alcanzado sus límites gratuitos. Sin embargo, estas implementaciones son completamente no estandarizadas y varían significativamente entre diferentes servicios. Debido a la falta de estándares, muchos desarrolladores y servicios evitan usar 402 y en su lugar optan por códigos alternativos como 403 Forbidden con mensajes explicativos sobre requisitos de pago, 451 Unavailable For Legal Reasons para contenido bloqueado por razones comerciales, o códigos de error personalizados en el rango 4xx. Algunos argumentan que 402 podría ser útil para distinguir problemas de pago de otros errores, pero sin estandarización, su uso sigue siendo experimental y no recomendado para producción crítica.",
        "useCases": [
            "USO NO ESTÁNDAR: Indicar que se ha excedido cuota de API gratuita",
            "USO NO ESTÁNDAR: Suscripción expirada que requiere renovación",
            "USO NO ESTÁNDAR: Contenido premium que requiere pago",
            "USO NO ESTÁNDAR: Límites de freemium alcanzados",
            "NOTA: Ninguno de estos usos está estandarizado oficialmente"
        ],
        "examples": [
            {
                "scenario": "Uso experimental (NO estándar) - Cuota de API excedida",
                "request": "GET /api/premium-data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 402 Payment Required\nContent-Type: application/json\n\n{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"You have exceeded your free tier quota\",\n  \"quota_limit\": 1000,\n  \"quota_used\": 1000,\n  \"upgrade_url\": \"https://billing.example.com/upgrade\",\n  \"note\": \"Non-standard use of 402. Standard practice would be 403 or 429.\"\n}",
                "explanation": "USO EXPERIMENTAL: Este servicio usa 402 para indicar que el usuario gratuito ha excedido su cuota. Sin embargo, este NO es un uso estándar. Sería más apropiado usar 429 (Too Many Requests) o 403 (Forbidden) con información de pago."
            },
            {
                "scenario": "Alternativa ESTÁNDAR recomendada - Usar 403 con contexto de pago",
                "request": "GET /api/premium-features HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"payment_required\",\n  \"message\": \"This feature requires a paid subscription\",\n  \"current_plan\": \"free\",\n  \"required_plan\": \"premium\",\n  \"upgrade_url\": \"https://example.com/upgrade\",\n  \"price\": \"$19.99/month\"\n}",
                "explanation": "MEJOR PRÁCTICA: Usar 403 Forbidden con información detallada sobre requisitos de pago es más estándar y ampliamente entendido que usar el no estandarizado 402."
            },
            {
                "scenario": "Alternativa usando 429 para límites de cuota",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1706745600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded your monthly API quota\",\n  \"reset_date\": \"2024-02-01T00:00:00Z\",\n  \"upgrade_info\": \"https://billing.example.com/upgrade\"\n}",
                "explanation": "MEJOR PRÁCTICA: Para límites de cuota/rate limiting, 429 Too Many Requests es semánticamente más correcto que 402, incluso si el upgrade requiere pago."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.2 (Reserved for future use)",
        "relatedHeaders": [],
        "technicalNotes": "El código 402 está OFICIALMENTE RESERVADO pero NO DEFINIDO en las especificaciones HTTP. No existe comportamiento estándar para este código. Su uso en producción es NO RECOMENDADO. Alternativas estándar: 403 Forbidden (para contenido que requiere pago), 429 Too Many Requests (para límites de cuota), o códigos personalizados 4xx. Muchas empresas evitan 402 completamente debido a la falta de estandarización.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712936/402_vofv3h.png",
                "alt": "Imagen que representa el nombre del código 402 Payment Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712628/27-removebg-preview_sws62c.png",
                "alt": "Imagen del código 402 Payment Required"
            }
        ]
    },
    {
        "code": 403,
        "status": "Forbidden",
        "category": "Client Error",
        "description": "El código 403 Forbidden indica que el servidor entendió la solicitud pero se niega a autorizarla. A diferencia del 401 Unauthorized que se refiere a problemas de AUTENTICACIÓN (quién eres), el 403 se refiere específicamente a problemas de AUTORIZACIÓN (qué tienes permitido hacer). Cuando un servidor responde con 403, está diciendo: 'Sé quién eres (estás autenticado correctamente), pero no tienes permiso para acceder a este recurso' o 'Este recurso está prohibido para ti'. Este es un punto crítico de distinción: 401 significa que no te has identificado o tus credenciales son inválidas, mientras que 403 significa que te identificaste correctamente pero no tienes los permisos necesarios. Un 403 indica que proporcionar credenciales diferentes no ayudará - el acceso está prohibido independientemente de la autenticación. Las causas comunes incluyen: intentar acceder a un recurso para el cual tu rol de usuario no tiene permisos, intentar realizar una operación que excede tus privilegios (por ejemplo, un usuario regular intentando acceder a funciones de administrador), acceder a recursos que están geográficamente restringidos, intentar acceder a contenido que requiere una suscripción o plan de pago superior, violación de políticas de seguridad o control de acceso, acceso bloqueado por firewall de aplicación web (WAF), direcciones IP bloqueadas o en lista negra, intentar acceder a archivos del sistema o directorios protegidos, o violación de límites de rate limiting basados en permisos. A diferencia del 401 que puede ser resuelto proporcionando credenciales válidas, un 403 generalmente requiere que se otorguen permisos adicionales al usuario, que se cambie de plan de suscripción, que se modifiquen políticas de acceso, o que se eliminen restricciones. Las respuestas 403 deben ser cuidadosamente diseñadas para no revelar información sensible sobre la estructura del sistema o existencia de recursos, ya que esto podría ser explotado por atacantes. Es una buena práctica incluir información útil sobre por qué el acceso fue denegado (sin revelar detalles de seguridad sensibles) y qué acciones podría tomar el usuario para obtener acceso.",
        "useCases": [
            "Usuario autenticado intenta acceder a recursos de administrador sin privilegios",
            "Acceso a recursos que requieren roles o permisos específicos que el usuario no tiene",
            "Intentar modificar o eliminar recursos que pertenecen a otro usuario",
            "Acceso a contenido premium sin suscripción adecuada",
            "Restricciones geográficas o de región (geo-blocking)",
            "Límites de rate limiting excedidos para el nivel de usuario",
            "IP bloqueada o en lista negra por razones de seguridad",
            "Violación de políticas de uso o términos de servicio",
            "Acceso a recursos durante horarios restringidos",
            "Intentar realizar operaciones en modo de solo lectura"
        ],
        "examples": [
            {
                "scenario": "Usuario sin privilegios de administrador",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer valid_user_token_not_admin",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"insufficient_permissions\",\n  \"message\": \"You do not have permission to perform this action\",\n  \"required_role\": \"admin\",\n  \"your_role\": \"user\",\n  \"action_attempted\": \"delete_user\",\n  \"contact\": \"Please contact your administrator to request elevated permissions\",\n  \"documentation\": \"https://docs.example.com/permissions/roles\"\n}",
                "explanation": "El usuario está correctamente autenticado (el token es válido) pero su rol de 'user' no tiene permisos para eliminar usuarios. Solo los administradores pueden realizar esta acción. Proporcionar un token diferente de usuario regular no ayudará."
            },
            {
                "scenario": "Acceso a recurso de otro usuario",
                "request": "GET /api/users/456/private-messages HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_123_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"access_denied\",\n  \"message\": \"You are not authorized to access this resource\",\n  \"reason\": \"This resource belongs to another user\",\n  \"resource_owner\": \"user_456\",\n  \"authenticated_as\": \"user_123\",\n  \"allowed_actions\": [\n    \"View your own messages at /api/users/123/private-messages\"\n  ]\n}",
                "explanation": "El usuario 123 está autenticado correctamente pero está intentando acceder a los mensajes privados del usuario 456. Por razones de privacidad y seguridad, esto está prohibido. Solo puede acceder a sus propios mensajes."
            },
            {
                "scenario": "Contenido premium sin suscripción adecuada",
                "request": "GET /api/premium-analytics/advanced-reports HTTP/1.1\nHost: analytics.example.com\nAuthorization: Bearer basic_plan_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"subscription_required\",\n  \"message\": \"This feature requires a premium subscription\",\n  \"current_plan\": \"Basic\",\n  \"required_plan\": \"Premium\",\n  \"feature_name\": \"Advanced Analytics Reports\",\n  \"upgrade_info\": {\n    \"plan_name\": \"Premium Plan\",\n    \"monthly_price\": \"$49.99\",\n    \"annual_price\": \"$499.99 (2 months free)\",\n    \"features\": [\n      \"Advanced analytics reports\",\n      \"Custom dashboards\",\n      \"API access\",\n      \"Priority support\"\n    ],\n    \"upgrade_url\": \"https://analytics.example.com/upgrade\",\n    \"trial_available\": true,\n    \"trial_duration\": \"14 days\"\n  }\n}",
                "explanation": "El usuario está autenticado y tiene una cuenta válida con plan Basic, pero este recurso específico requiere un plan Premium. El acceso está prohibido hasta que actualice su suscripción."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.3",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization"
        ],
        "technicalNotes": "403 es específicamente para AUTORIZACIÓN (qué puedes hacer), no AUTENTICACIÓN (quién eres). La diferencia con 401: 401 = no autenticado o credenciales inválidas (solucionable con login correcto); 403 = autenticado pero sin permisos (proporcionar otras credenciales no ayuda, se necesitan permisos adicionales). No incluyas WWW-Authenticate en 403, ese encabezado es para 401. Por seguridad, considera si deberías devolver 404 en lugar de 403 cuando no quieras revelar que un recurso existe. 403 es apropiado cuando el usuario debe saber que el recurso existe pero no puede accederlo.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712938/403_vobb9m.png",
                "alt": "Imagen que representa el nombre del código 403 Forbidden"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712627/28-removebg-preview_kc6xuc.png",
                "alt": "Imagen del código 403 Forbidden"
            }
        ]
    },
    {
        "code": 404,
        "status": "Not Found",
        "category": "Client Error",
        "description": "El código 404 Not Found es probablemente el código de estado HTTP más conocido y reconocible, incluso fuera de la comunidad técnica. Indica que el servidor no pudo encontrar el recurso solicitado. Es importante entender que 404 significa específicamente que el URI solicitado no corresponde a ningún recurso existente en el servidor, pero no proporciona información sobre si esta ausencia es temporal o permanente. El servidor está diciendo: 'Busqué en la ubicación que especificaste y no hay nada allí'. Esto puede ocurrir por varias razones: el recurso nunca existió en esa ubicación, el recurso existió anteriormente pero fue eliminado, el recurso fue movido a otra ubicación sin configurar una redirección, hay un error tipográfico en la URL, o el usuario no tiene permisos para saber que el recurso existe (en cuyo caso 404 se usa intencionalmente en lugar de 403 por razones de seguridad). El código 404 es apropiado tanto para recursos que definitivamente no existen como para aquellos cuya existencia no debería ser revelada por razones de seguridad o privacidad. Por ejemplo, si un usuario intenta acceder a '/admin/secret-page' pero no tiene permisos, podrías devolver 404 en lugar de 403 para no confirmar que esa página existe. El 404 es distinto del 410 Gone, que específicamente indica que el recurso existió anteriormente pero fue eliminado permanentemente y no regresará. Si sabes con certeza que un recurso fue eliminado permanentemente, 410 es más semántico, pero 404 es aceptable y más comúnmente usado. Las páginas 404 personalizadas son una práctica común en diseño web, ofreciendo navegación útil, búsqueda, o contenido relacionado en lugar de simplemente indicar el error. En APIs RESTful, las respuestas 404 deben incluir información estructurada sobre qué recurso no se encontró y potencialmente sugerencias de recursos similares o acciones alternativas. Es importante que las respuestas 404 sean informativas pero no revelen información sensible del sistema.",
        "useCases": [
            "URL con error tipográfico o mal formada",
            "Recurso que fue eliminado y no existe más",
            "Recurso que nunca existió en la ubicación especificada",
            "ID de recurso inválido en APIs RESTful (producto, usuario, orden que no existe)",
            "Ruta de archivo o directorio inexistente",
            "Endpoint de API que no está definido o fue deprecado",
            "Recurso movido sin redirección configurada",
            "Seguridad: ocultar existencia de recursos sensibles devolviendo 404 en lugar de 403",
            "Páginas que fueron parte de una reestructuración de sitio sin mantener URLs antiguas",
            "Recursos temporales que expiraron (cupones, tokens de verificación vencidos)"
        ],
        "examples": [
            {
                "scenario": "Recurso no encontrado en API REST",
                "request": "GET /api/products/99999 HTTP/1.1\nHost: shop.example.com\nAccept: application/json",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"resource_not_found\",\n  \"message\": \"Product not found\",\n  \"resource_type\": \"product\",\n  \"resource_id\": \"99999\",\n  \"requested_url\": \"/api/products/99999\",\n  \"suggestions\": [\n    \"Verify the product ID is correct\",\n    \"Browse available products at /api/products\",\n    \"Search products at /api/products/search\"\n  ],\n  \"documentation\": \"https://docs.shop.example.com/api/products\"\n}",
                "explanation": "El cliente solicitó un producto con ID 99999 que no existe en la base de datos. El servidor responde con 404 e información útil sobre cómo proceder."
            },
            {
                "scenario": "Página web no encontrada con sugerencias útiles",
                "request": "GET /blog/non-existent-article HTTP/1.1\nHost: www.example.com\nAccept: text/html",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Not Found - Example Blog</title>\n  <meta name=\"robots\" content=\"noindex\">\n</head>\n<body>\n  <h1>404 - Page Not Found</h1>\n  <p>Sorry, we couldn't find the page you're looking for.</p>\n  <h2>You might be interested in:</h2>\n  <ul>\n    <li><a href=\"/blog\">Latest Blog Posts</a></li>\n    <li><a href=\"/blog/popular\">Popular Articles</a></li>\n    <li><a href=\"/search?q=article\">Search our site</a></li>\n  </ul>\n  <p>Or <a href=\"/\">return to homepage</a></p>\n</body>\n</html>",
                "explanation": "La página solicitada no existe. En lugar de un error genérico, se proporciona una página 404 personalizada con navegación útil, enlaces a contenido popular y opción de búsqueda para ayudar al usuario a encontrar lo que busca."
            },
            {
                "scenario": "Endpoint de API inexistente",
                "request": "POST /api/v2/invalid-endpoint HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"data\": \"some data\"\n}",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"endpoint_not_found\",\n  \"message\": \"The requested API endpoint does not exist\",\n  \"requested_path\": \"/api/v2/invalid-endpoint\",\n  \"method\": \"POST\",\n  \"api_version\": \"v2\",\n  \"available_endpoints\": [\n    \"GET /api/v2/users\",\n    \"POST /api/v2/users\",\n    \"GET /api/v2/products\",\n    \"POST /api/v2/orders\"\n  ],\n  \"documentation\": \"https://api.example.com/docs/v2\",\n  \"support\": \"api-support@example.com\"\n}",
                "explanation": "El cliente está intentando acceder a un endpoint que no existe en la API. El servidor responde con 404 y lista de endpoints disponibles para ayudar al desarrollador a corregir la solicitud."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.4",
        "relatedHeaders": [
            "Content-Type",
            "Cache-Control"
        ],
        "relatedCodes": [
            410
        ],
        "technicalNotes": "404 significa que el recurso no fue encontrado en la ubicación solicitada, pero no especifica si es temporal o permanente. Para eliminaciones permanentes conocidas, considera usar 410 Gone en su lugar. Por seguridad, 404 puede ser usado intencionalmente en lugar de 403 Forbidden para no revelar la existencia de recursos sensibles. Las páginas 404 deben incluir meta tag noindex para evitar que sean indexadas por motores de búsqueda. En APIs, siempre proporciona información estructurada sobre qué recurso no se encontró. Considera implementar logging de 404s para detectar enlaces rotos o problemas de integración.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712940/404_xr4mgz.png",
                "alt": "Imagen que representa el nombre del código 404 Not Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712638/29-removebg-preview_pml3fe.png",
                "alt": "Imagen del código 404 Not Found"
            }
        ]
    },
    {
        "code": 405,
        "status": "Method Not Allowed",
        "category": "Client Error",
        "description": "El código 405 Method Not Allowed indica que el servidor reconoce el método HTTP utilizado en la solicitud (GET, POST, PUT, DELETE, PATCH, etc.), pero ese método específico no está permitido para el recurso solicitado. Es crucial entender que esto es diferente de 404 Not Found: con 405, el recurso SÍ existe y fue encontrado, pero el método HTTP que estás intentando usar sobre ese recurso no está soportado o permitido. El servidor está diciendo: 'Conozco este recurso y existe, pero no puedes usar ese método HTTP en él'. Por ejemplo, si tienes un endpoint de API de solo lectura en /api/statistics, podrías permitir GET pero no POST, PUT o DELETE. Si un cliente intenta hacer POST a ese endpoint, recibiría 405. La respuesta 405 DEBE incluir un encabezado Allow que liste los métodos HTTP que SÍ son permitidos para ese recurso. Este encabezado es obligatorio según la especificación HTTP y proporciona información valiosa al cliente sobre cómo interactuar correctamente con el recurso. Por ejemplo: 'Allow: GET, HEAD, OPTIONS'. Las causas comunes de 405 incluyen: intentar usar POST en un endpoint que solo acepta GET, intentar modificar (PUT/PATCH) o eliminar (DELETE) un recurso de solo lectura, usar métodos no implementados en endpoints específicos, o violar restricciones de seguridad que permiten solo ciertos métodos. El código 405 es fundamental en el diseño de APIs RESTful donde diferentes recursos tienen diferentes conjuntos de operaciones permitidas. Por ejemplo, un endpoint de listado podría solo permitir GET, mientras que un endpoint de recurso individual podría permitir GET, PUT, PATCH, DELETE pero no POST. Es importante distinguir 405 de otros códigos: 404 significa que el recurso no existe; 403 significa que existe pero no tienes permiso; 405 significa que existe, puedes tener permiso, pero el método que intentas usar no es válido para este recurso. Las implementaciones bien diseñadas también responden correctamente a solicitudes OPTIONS, que son usadas por navegadores en CORS preflight para descubrir qué métodos están permitidos.",
        "useCases": [
            "Intentar POST en un endpoint de solo lectura que solo acepta GET",
            "Intentar DELETE en un recurso que no puede ser eliminado",
            "Intentar PUT/PATCH en un recurso inmutable o de solo lectura",
            "Usar métodos HTTP no implementados en endpoints específicos de API",
            "Intentar modificar recursos del sistema que son configurables solo por administradores",
            "Endpoints que solo permiten operaciones de consulta (GET) pero no modificaciones",
            "Recursos que solo permiten creación (POST) pero no actualizaciones individuales",
            "Violación de restricciones de diseño REST donde ciertos recursos solo soportan subconjuntos de métodos",
            "Intentar usar métodos HTTP personalizados o no estándar no soportados por el servidor"
        ],
        "examples": [
            {
                "scenario": "Intentar POST en endpoint de solo lectura",
                "request": "POST /api/statistics/daily-summary HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"date\": \"2024-01-16\",\n  \"views\": 5000\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"The POST method is not allowed for this resource\",\n  \"requested_method\": \"POST\",\n  \"requested_resource\": \"/api/statistics/daily-summary\",\n  \"allowed_methods\": [\"GET\", \"HEAD\", \"OPTIONS\"],\n  \"reason\": \"This is a read-only statistics endpoint. Data is automatically generated and cannot be manually posted.\",\n  \"alternatives\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"Retrieve daily statistics summary\",\n      \"example\": \"GET /api/statistics/daily-summary?date=2024-01-16\"\n    }\n  ],\n  \"documentation\": \"https://docs.analytics.example.com/api/statistics\"\n}",
                "explanation": "El endpoint de estadísticas es de solo lectura porque los datos son generados automáticamente por el sistema. El cliente intentó usar POST para crear datos manualmente, lo cual no está permitido. El encabezado Allow indica que solo GET, HEAD y OPTIONS son válidos."
            },
            {
                "scenario": "Intentar DELETE en recurso no eliminable",
                "request": "DELETE /api/system/configuration/core-settings HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, PUT, PATCH, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"DELETE method is not allowed on core system settings\",\n  \"requested_method\": \"DELETE\",\n  \"resource_type\": \"system_configuration\",\n  \"allowed_methods\": [\"GET\", \"PUT\", \"PATCH\", \"OPTIONS\"],\n  \"reason\": \"Core settings cannot be deleted as they are required for system operation. They can only be viewed or modified.\",\n  \"allowed_operations\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"View current core settings\"\n    },\n    {\n      \"method\": \"PUT\",\n      \"description\": \"Replace all core settings\"\n    },\n    {\n      \"method\": \"PATCH\",\n      \"description\": \"Update specific core settings\"\n    }\n  ],\n  \"warning\": \"Modifying core settings requires administrator privileges and can affect system stability\"\n}",
                "explanation": "Las configuraciones centrales del sistema no pueden ser eliminadas porque son esenciales para el funcionamiento del sistema. Solo pueden ser leídas o modificadas. El método DELETE no tiene sentido para este recurso."
            },
            {
                "scenario": "Intentar PUT en endpoint de colección que solo acepta POST",
                "request": "PUT /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"name\": \"New Product\",\n  \"price\": 29.99,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"PUT method is not allowed on the products collection endpoint\",\n  \"requested_method\": \"PUT\",\n  \"requested_resource\": \"/api/products\",\n  \"allowed_methods\": [\"GET\", \"POST\", \"HEAD\", \"OPTIONS\"],\n  \"explanation\": \"PUT is used to update specific resources, not collections. To create a new product, use POST. To update an existing product, use PUT on /api/products/{id}\",\n  \"correct_usage\": [\n    {\n      \"operation\": \"Create new product\",\n      \"method\": \"POST\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"POST /api/products with product data in body\"\n    },\n    {\n      \"operation\": \"Update existing product\",\n      \"method\": \"PUT\",\n      \"endpoint\": \"/api/products/{id}\",\n      \"example\": \"PUT /api/products/123 with updated product data\"\n    },\n    {\n      \"operation\": \"List all products\",\n      \"method\": \"GET\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"GET /api/products?page=1&limit=20\"\n    }\n  ]\n}",
                "explanation": "Según principios REST, PUT se usa en recursos individuales específicos, no en colecciones. Para crear un producto, debe usar POST en /api/products. Para actualizar un producto específico, debe usar PUT en /api/products/{id}."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.5",
        "relatedHeaders": [
            "Allow"
        ],
        "relatedCodes": [
            501
        ],
        "technicalNotes": "405 es diferente de 501 Not Implemented: 405 significa que el servidor soporta el método en general pero no para este recurso específico; 501 significa que el servidor no implementa ese método en absoluto. La respuesta 405 DEBE incluir el encabezado Allow listando los métodos permitidos. Este encabezado es obligatorio según RFC 7231. Las solicitudes OPTIONS deben ser manejadas apropiadamente para CORS preflight, respondiendo con los métodos permitidos. En diseño REST: colecciones típicamente permiten GET y POST; recursos individuales permiten GET, PUT, PATCH, DELETE. No confundir con 403 (tienes permiso pero no autorización) o 404 (recurso no existe).",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712942/405_iq06kt.png",
                "alt": "Imagen que representa el nombre del código 405 Method Not Allowed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712634/30-removebg-preview_mns9bp.png",
                "alt": "Imagen del código 405 Method Not Allowed"
            }
        ]
    },
    {
        "code": 406,
        "status": "Not Acceptable",
        "category": "Client Error",
        "description": "El código 406 Not Acceptable indica que el servidor no puede producir una respuesta que coincida con los criterios de aceptabilidad especificados en los encabezados de la solicitud del cliente, particularmente los encabezados Accept, Accept-Charset, Accept-Encoding, y Accept-Language. Este código es parte del mecanismo de negociación de contenido (content negotiation) en HTTP. Cuando un cliente envía una solicitud, puede especificar qué tipos de contenido acepta mediante estos encabezados. Por ejemplo, un cliente podría decir 'Accept: application/json' indicando que solo puede procesar respuestas en formato JSON. Si el servidor solo puede proporcionar el recurso en formato XML, debe responder con 406 indicando que no puede satisfacer los requisitos del cliente. El servidor está diciendo: 'Tengo el recurso que solicitaste, pero no puedo entregártelo en ninguno de los formatos que me dijiste que aceptas'. Es importante notar que 406 es relativamente raro en la práctica web moderna porque la mayoría de los servidores simplemente ignoran parcial o totalmente las preferencias del cliente cuando no pueden satisfacerlas, y envían una respuesta en un formato por defecto (usualmente con código 200). Sin embargo, en APIs estrictamente diseñadas y sistemas que implementan negociación de contenido rigurosa, 406 es la respuesta correcta cuando hay una incompatibilidad irreconciliable. Los escenarios incluyen: un cliente que solo acepta JSON pero el servidor solo produce XML, un cliente que requiere compresión gzip pero el servidor no la soporta, un cliente que solicita un idioma específico que no está disponible, o un cliente que requiere un conjunto de caracteres no soportado por el servidor. La respuesta 406 puede incluir una lista de las representaciones disponibles para ayudar al cliente a reformular su solicitud, aunque esto no es obligatorio. Es crucial distinguir 406 de 415 Unsupported Media Type: 415 se refiere al Content-Type que el cliente ENVÍA en el cuerpo de la solicitud, mientras que 406 se refiere a lo que el cliente especifica que puede ACEPTAR en la respuesta.",
        "useCases": [
            "Cliente solicita JSON pero servidor solo puede producir XML",
            "Cliente requiere codificación de caracteres no soportada por el servidor",
            "Cliente solicita idioma específico no disponible",
            "Cliente requiere compresión específica no implementada en servidor",
            "APIs estrictas donde formato de respuesta debe coincidir exactamente con Accept header",
            "Cliente especifica calidad de media type que servidor no puede satisfacer",
            "Negociación de contenido falla completamente sin formato común",
            "Cliente requiere nivel de detalle o versión de API no disponible"
        ],
        "examples": [
            {
                "scenario": "Cliente requiere JSON pero servidor solo produce XML",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAuthorization: Bearer valid_token",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"not_acceptable\",\n  \"message\": \"The requested resource cannot be provided in the requested format\",\n  \"requested_formats\": [\"application/json\"],\n  \"available_formats\": [\n    {\n      \"content_type\": \"application/xml\",\n      \"description\": \"XML representation\",\n      \"example_request\": \"Accept: application/xml\"\n    },\n    {\n      \"content_type\": \"text/xml\",\n      \"description\": \"Plain XML\",\n      \"example_request\": \"Accept: text/xml\"\n    }\n  ],\n  \"suggestion\": \"Please modify your Accept header to one of the available formats\",\n  \"documentation\": \"https://api.example.com/docs/content-negotiation\"\n}",
                "explanation": "El cliente especificó que solo acepta JSON (Accept: application/json), pero este servidor legacy solo puede producir XML. Como no hay un formato común, el servidor responde con 406 y lista los formatos disponibles."
            },
            {
                "scenario": "Idioma solicitado no disponible",
                "request": "GET /api/content/article-123 HTTP/1.1\nHost: content.example.com\nAccept: application/json\nAccept-Language: ja-JP",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\nContent-Language: en-US\n\n{\n  \"error\": \"language_not_available\",\n  \"message\": \"The requested content is not available in the requested language\",\n  \"requested_language\": \"ja-JP\",\n  \"available_languages\": [\n    {\n      \"code\": \"en-US\",\n      \"name\": \"English (United States)\",\n      \"is_default\": true\n    },\n    {\n      \"code\": \"es-ES\",\n      \"name\": \"Spanish (Spain)\"\n    },\n    {\n      \"code\": \"fr-FR\",\n      \"name\": \"French (France)\"\n    },\n    {\n      \"code\": \"de-DE\",\n      \"name\": \"German (Germany)\"\n    }\n  ],\n  \"suggestion\": \"Try requesting with Accept-Language: en-US, es-ES, fr-FR, or de-DE\",\n  \"note\": \"If no Accept-Language header is provided, content will be served in English (default)\"\n}",
                "explanation": "El cliente solicitó contenido en japonés (ja-JP), pero ese idioma no está disponible para este recurso. El servidor lista los idiomas disponibles para ayudar al cliente a hacer una solicitud válida."
            },
            {
                "scenario": "Codificación de caracteres no soportada",
                "request": "GET /api/legacy-data HTTP/1.1\nHost: api.example.com\nAccept: text/plain\nAccept-Charset: ISO-8859-1",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"charset_not_supported\",\n  \"message\": \"The requested character encoding is not supported\",\n  \"requested_charset\": \"ISO-8859-1\",\n  \"available_charsets\": [\n    {\n      \"charset\": \"UTF-8\",\n      \"description\": \"Unicode UTF-8 (recommended)\",\n      \"is_default\": true\n    },\n    {\n      \"charset\": \"UTF-16\",\n      \"description\": \"Unicode UTF-16\"\n    }\n  ],\n  \"recommendation\": \"Use Accept-Charset: UTF-8 or omit the header to receive UTF-8 by default\",\n  \"reason\": \"Modern APIs exclusively use Unicode encodings for better international character support\"\n}",
                "explanation": "El cliente solicitó codificación ISO-8859-1 (Latin-1), pero el servidor moderno solo soporta Unicode (UTF-8 y UTF-16). Se recomienda al cliente usar UTF-8 que es el estándar actual."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.6",
        "relatedHeaders": [
            "Accept",
            "Accept-Charset",
            "Accept-Encoding",
            "Accept-Language",
            "Content-Type"
        ],
        "relatedCodes": [
            415
        ],
        "technicalNotes": "406 se refiere a negociación de contenido proactiva basada en lo que el cliente puede ACEPTAR (headers Accept-*). No confundir con 415 Unsupported Media Type que se refiere al Content-Type que el cliente ENVÍA. En la práctica, 406 es raro porque muchos servidores ignoran parcialmente las preferencias del cliente y envían un formato por defecto con 200. Usar 406 indica una implementación estricta de content negotiation. La respuesta puede incluir lista de representaciones disponibles, aunque no es obligatorio. Si el servidor puede producir múltiples formatos pero ninguno coincide con Accept, debe responder 406, no elegir arbitrariamente uno.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712944/406_dlslce.png",
                "alt": "Imagen que representa el nombre del código 406 Not Acceptable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712632/31-removebg-preview_glqv2u.png",
                "alt": "Imagen del código 406 Not Acceptable"
            }
        ]
    },
    {
        "code": 407,
        "status": "Proxy Authentication Required",
        "category": "Client Error",
        "description": "El código 407 Proxy Authentication Required es similar al 401 Unauthorized, pero indica específicamente que el cliente debe autenticarse primero con un servidor proxy antes de que la solicitud pueda ser procesada. Este código es utilizado en escenarios donde la comunicación entre el cliente y el servidor final debe pasar a través de un proxy intermedio que requiere autenticación. El proxy está diciendo: 'Antes de que pueda reenviar tu solicitud al servidor de destino, necesitas autenticarte conmigo'. Esto es común en entornos corporativos donde todo el tráfico HTTP/HTTPS debe pasar por un proxy corporativo que implementa políticas de seguridad, filtrado de contenido, o logging. La respuesta 407 DEBE incluir un encabezado Proxy-Authenticate que especifica el esquema de autenticación que el proxy requiere, similar a cómo 401 usa WWW-Authenticate. Los esquemas comunes incluyen Basic, Digest, NTLM (en entornos Windows/Active Directory), o esquemas personalizados. Cuando un cliente recibe un 407, debe reenviar la solicitud incluyendo un encabezado Proxy-Authorization con las credenciales apropiadas para el proxy. Es importante distinguir entre autenticación de proxy (407) y autenticación de servidor final (401): puede haber escenarios donde ambas son necesarias, primero autenticándose con el proxy (407) y luego con el servidor de destino (401). El código 407 es transparente para muchas aplicaciones modernas porque los navegadores y librerías HTTP manejan automáticamente la autenticación de proxy usando credenciales configuradas a nivel de sistema operativo o aplicación. En entornos empresariales, es común que los administradores configuren credenciales de proxy a nivel de sistema para que todas las aplicaciones puedan usarlas automáticamente. Los proxies pueden requerir autenticación por varias razones: control de acceso y seguridad, rastreo de uso por usuario o departamento, implementación de políticas de uso aceptable, prevención de uso no autorizado de recursos de red, o cumplimiento de requisitos regulatorios. En APIs y aplicaciones server-to-server, manejar 407 correctamente es crucial para funcionar en entornos corporativos donde los proxies son obligatorios.",
        "useCases": [
            "Proxies corporativos que requieren autenticación de empleados",
            "Proxies de red que implementan control de acceso",
            "Proxies de filtrado de contenido en instituciones educativas",
            "Proxies que rastrean y registran uso de internet por usuario",
            "Proxies de caché que requieren identificación de usuarios",
            "Proxies que implementan políticas de uso aceptable",
            "Gateways de seguridad que validan identidad antes de permitir tráfico externo",
            "Proxies que aplican límites de ancho de banda por usuario autenticado"
        ],
        "examples": [
            {
                "scenario": "Proxy corporativo requiere autenticación Basic",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: Basic realm=\"Corporate Proxy\"\nProxy-Connection: close\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>Proxy Authentication Required</title></head>\n<body>\n  <h1>407 Proxy Authentication Required</h1>\n  <p>This request must be authenticated with the corporate proxy before it can be forwarded.</p>\n  <p>Please configure your application with valid proxy credentials.</p>\n  <p>Contact IT Support if you need assistance: support@company.com</p>\n</body>\n</html>",
                "explanation": "Un proxy corporativo interceptó la solicitud al servidor externo. Antes de reenviar la solicitud, requiere que el cliente se autentique usando credenciales corporativas con esquema Basic authentication. El cliente debe reenviar con encabezado Proxy-Authorization."
            },
            {
                "scenario": "Solicitud correcta con autenticación de proxy",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nProxy-Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nVia: 1.1 corporate-proxy.company.com\n\n{\n  \"message\": \"Request successfully forwarded through authenticated proxy\",\n  \"data\": {\n    \"user\": \"authenticated_user\",\n    \"proxy\": \"corporate-proxy.company.com\",\n    \"result\": \"success\"\n  }\n}",
                "explanation": "Después de recibir 407, el cliente reenvió la solicitud incluyendo el encabezado Proxy-Authorization con credenciales válidas. El proxy validó las credenciales y reenvió la solicitud al servidor de destino, que respondió exitosamente. El encabezado Via indica que pasó por el proxy."
            },
            {
                "scenario": "Proxy con autenticación NTLM (entorno Windows)",
                "request": "GET http://internet-resource.example.com/page HTTP/1.1\nHost: internet-resource.example.com",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: NTLM\nProxy-Authenticate: Negotiate\nContent-Type: application/json\n\n{\n  \"error\": \"proxy_authentication_required\",\n  \"message\": \"Authentication with the corporate proxy is required\",\n  \"proxy_server\": \"proxy.corporate.local\",\n  \"authentication_methods\": [\n    {\n      \"method\": \"NTLM\",\n      \"description\": \"Windows integrated authentication\",\n      \"automatic\": true,\n      \"note\": \"Your Windows credentials will be used automatically if configured\"\n    },\n    {\n      \"method\": \"Negotiate\",\n      \"description\": \"Kerberos/NTLM negotiation\",\n      \"automatic\": true\n    }\n  ],\n  \"help\": \"If automatic authentication fails, contact IT: it-support@corporate.local\",\n  \"documentation\": \"https://intranet.corporate.local/proxy-setup\"\n}",
                "explanation": "Un proxy en entorno Windows corporativo ofrece autenticación NTLM y Negotiate (Kerberos). Estos esquemas típicamente usan las credenciales de dominio del usuario de Windows automáticamente, sin requerir entrada manual de credenciales."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7235, Section 3.2",
        "relatedHeaders": [
            "Proxy-Authenticate",
            "Proxy-Authorization",
            "Via",
            "Proxy-Connection"
        ],
        "relatedCodes": [
            401
        ],
        "technicalNotes": "407 es específico para autenticación de PROXY, no del servidor final. Similar a como 401 requiere WWW-Authenticate, 407 DEBE incluir Proxy-Authenticate. El cliente responde con Proxy-Authorization (no Authorization). Es posible recibir tanto 407 como 401 en secuencia: primero autenticarse con proxy, luego con servidor destino. Los navegadores modernos manejan 407 automáticamente usando credenciales de proxy configuradas. En aplicaciones, las librerías HTTP típicamente soportan configuración de proxy con credenciales. NTLM y Negotiate son comunes en entornos Windows/Active Directory. El encabezado Via indica proxies por los que pasó la solicitud.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 407 Proxy Authentication Required"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 407 Proxy Authentication Required"
            }
        ]
    }
]