[
    {
        "code": 100,
        "status": "Continue",
        "category": "Informational",
        "description": "El código 100 Continue es una respuesta provisional que indica que el cliente debe continuar con su solicitud o ignorar esta respuesta si la solicitud ya ha sido completada. Este código se utiliza principalmente en escenarios donde el cliente necesita enviar un cuerpo de solicitud grande y quiere verificar primero si el servidor está dispuesto a aceptarlo antes de enviar todos los datos. El cliente envía los encabezados de la solicitud con un encabezado 'Expect: 100-continue', y el servidor responde con 100 Continue si está listo para recibir el cuerpo de la solicitud. Esto es especialmente útil para optimizar el ancho de banda y evitar enviar grandes cantidades de datos que podrían ser rechazados por el servidor. Por ejemplo, si un cliente intenta subir un archivo de 500MB, puede primero enviar los encabezados para verificar la autenticación y validación antes de transmitir todo el archivo. Si el servidor responde con 100 Continue, el cliente procede a enviar el cuerpo completo. Si el servidor responde con un código de error (como 401 Unauthorized), el cliente puede abortar la transmisión sin haber desperdiciado ancho de banda enviando el archivo completo.",
        "useCases": [
            "Upload de archivos grandes donde se necesita validación previa",
            "APIs que requieren verificación de autenticación antes de procesar cuerpos de solicitud pesados",
            "Optimización de ancho de banda en conexiones lentas",
            "Sistemas de streaming donde se necesita confirmación del servidor antes de enviar datos"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo grande",
                "request": "POST /upload HTTP/1.1\nHost: example.com\nExpect: 100-continue\nContent-Length: 524288000\nContent-Type: application/octet-stream",
                "response": "HTTP/1.1 100 Continue",
                "explanation": "El servidor acepta recibir el archivo, el cliente procede a enviar los 500MB"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611664/404_2_l0oyj5.png",
                "alt": "Imagen que representa el nombre del código 100 Continue"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618710/1-removebg-preview_tkp4yz.png",
                "alt": "Imagen del código 100 Continue"
            }
        ]
    },
    {
        "code": 101,
        "status": "Switching Protocols",
        "category": "Informational",
        "description": "El código 101 Switching Protocols indica que el servidor está cambiando de protocolo según lo solicitado por el cliente a través del encabezado 'Upgrade'. Este mecanismo permite que una conexión establecida inicialmente con HTTP evolucione a un protocolo diferente, como WebSocket, HTTP/2, o cualquier otro protocolo compatible. El servidor envía este código para confirmar que acepta cambiar al protocolo solicitado en el encabezado Upgrade de la solicitud del cliente. Después de enviar esta respuesta, el servidor abandona el protocolo HTTP/1.1 y comienza a comunicarse usando el nuevo protocolo especificado. Este código es fundamental para la implementación de WebSockets, que permite comunicación bidireccional en tiempo real sobre una única conexión TCP. El proceso típico involucra una solicitud HTTP inicial que solicita el upgrade, el servidor responde con 101, y a partir de ese momento la conexión opera bajo el nuevo protocolo. Esto es especialmente valioso en aplicaciones que requieren comunicación en tiempo real, como chats, juegos multijugador, dashboards en vivo, o aplicaciones colaborativas. Es importante notar que no todos los proxies o intermediarios soportan este mecanismo, por lo que la implementación debe considerar compatibilidad.",
        "useCases": [
            "Establecimiento de conexiones WebSocket para comunicación bidireccional en tiempo real",
            "Upgrade de HTTP/1.1 a HTTP/2 para mejorar el rendimiento",
            "Implementación de Server-Sent Events (SSE) en algunos casos",
            "Protocolos personalizados que necesitan una conexión HTTP inicial"
        ],
        "examples": [
            {
                "scenario": "Upgrade a WebSocket",
                "request": "GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13",
                "response": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
                "explanation": "El servidor acepta el upgrade a WebSocket y la conexión ahora usa el protocolo WebSocket"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597106/1_ltkyhn.png",
                "alt": "Imagen que representa el nombre del código 101 Switching Protocols"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618707/2-removebg-preview_jjwrov.png",
                "alt": "Imagen del código 101 Switching Protocols"
            }
        ]
    },
    {
        "code": 102,
        "status": "Processing",
        "category": "Informational",
        "description": "El código 102 Processing es una respuesta provisional que indica que el servidor ha recibido y está procesando la solicitud, pero aún no tiene una respuesta disponible. Este código se utiliza principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para prevenir que el cliente agote el tiempo de espera en operaciones que requieren mucho tiempo de procesamiento. Cuando un servidor WebDAV recibe una solicitud que puede tomar tiempo significativo para completarse (como copiar una gran estructura de directorios, realizar operaciones complejas en múltiples recursos, o procesar transformaciones de archivos grandes), envía este código intermedio para mantener la conexión activa y asegurar al cliente que la solicitud no se ha perdido o estancado. El cliente, al recibir este código, puede resetear su temporizador de timeout y continuar esperando. Es particularmente útil en operaciones como PROPFIND sobre grandes colecciones de recursos, operaciones COPY o MOVE masivas, o cualquier operación que involucre procesamiento extensivo en el servidor. A diferencia de 100 Continue que es sobre el envío de datos, 102 Processing es sobre la ejecución de la operación solicitada.",
        "useCases": [
            "Operaciones WebDAV que toman tiempo significativo (PROPFIND, COPY, MOVE)",
            "Procesamiento de grandes estructuras de archivos en sistemas de gestión de contenido",
            "Operaciones batch sobre múltiples recursos",
            "Transformaciones o conversiones de archivos que requieren tiempo de procesamiento extenso"
        ],
        "examples": [
            {
                "scenario": "Copia masiva de directorios en WebDAV",
                "request": "COPY /documents/folder1/ HTTP/1.1\nHost: webdav.example.com\nDestination: /documents/folder2/\nDepth: infinity",
                "response": "HTTP/1.1 102 Processing",
                "explanation": "El servidor informa que está copiando los archivos recursivamente y el cliente debe seguir esperando"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2518 (WebDAV)",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611761/2_je4oyl.png",
                "alt": "Imagen que representa el nombre del código 102 Processing"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618704/3-removebg-preview_cj1fzy.png",
                "alt": "Imagen del código 102 Processing"
            }
        ]
    },
    {
        "code": 103,
        "status": "Early Hints",
        "category": "Informational",
        "description": "El código 103 Early Hints es una respuesta informativa relativamente nueva que permite al servidor enviar encabezados HTTP preliminares antes de que la respuesta final esté lista. Su propósito principal es mejorar el rendimiento de carga de páginas web al permitir que el navegador comience a pre-cargar recursos críticos mientras el servidor aún está preparando la respuesta completa. Esto es especialmente valioso cuando el servidor necesita tiempo para generar contenido dinámico pero ya sabe qué recursos adicionales (CSS, JavaScript, fuentes, imágenes) serán necesarios. El servidor puede enviar encabezados Link con rel=preload o rel=preconnect, permitiendo que el navegador inicie la descarga de estos recursos en paralelo mientras espera la respuesta HTML principal. Por ejemplo, si un servidor de aplicación necesita consultar una base de datos para generar una página pero ya sabe que necesitará ciertos archivos CSS y JavaScript, puede enviar 103 Early Hints inmediatamente con referencias a esos recursos. Esto reduce significativamente el tiempo de carga percibido y mejora métricas como First Contentful Paint (FCP) y Largest Contentful Paint (LCP). Es particularmente efectivo en sitios con tiempos de procesamiento del servidor variables o consultas de base de datos complejas.",
        "useCases": [
            "Precarga de recursos estáticos (CSS, JS, fuentes) mientras se genera contenido dinámico",
            "Establecimiento anticipado de conexiones a dominios de terceros (CDNs, APIs)",
            "Optimización del rendimiento web y mejora de Core Web Vitals",
            "Reducción del tiempo de carga en aplicaciones con procesamiento del servidor intensivo"
        ],
        "examples": [
            {
                "scenario": "Precarga de recursos críticos",
                "request": "GET /dashboard HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 103 Early Hints\nLink: </styles/critical.css>; rel=preload; as=style\nLink: </scripts/app.js>; rel=preload; as=script\nLink: <https://cdn.example.com>; rel=preconnect\n\n[... el servidor continúa procesando ...]\n\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>...",
                "explanation": "El navegador recibe instrucciones para precargar CSS y JS mientras el servidor genera el HTML del dashboard"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 8297",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597108/3_av4aj8.png",
                "alt": "Imagen que representa el nombre del código 103 Early Hints  "
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618702/4-removebg-preview_gkrmuw.png",
                "alt": "Imagen del código 103 Early Hints"
            }
        ]
    },
    {
        "code": 200,
        "status": "OK",
        "category": "Success",
        "description": "El código 200 OK es la respuesta de éxito estándar y más común en HTTP. Indica que la solicitud ha sido procesada exitosamente y el servidor está devolviendo el resultado solicitado. El significado específico de 'éxito' varía según el método HTTP utilizado: para GET significa que el recurso ha sido recuperado y se transmite en el cuerpo del mensaje; para POST indica que el recurso que describe el resultado de la acción se transmite en el cuerpo del mensaje; para PUT o PATCH significa que el recurso ha sido modificado exitosamente; para DELETE indica que el recurso ha sido eliminado. Este código es el caballo de batalla de las APIs REST y aplicaciones web. La respuesta 200 típicamente incluye el cuerpo del mensaje con el contenido solicitado (HTML, JSON, XML, archivos binarios, etc.) junto con encabezados relevantes como Content-Type, Content-Length, Cache-Control, ETag, entre otros. Es importante notar que 200 no siempre es la respuesta más semántica - por ejemplo, una creación exitosa debería usar 201 Created, y una eliminación exitosa sin contenido debería usar 204 No Content. El uso apropiado de códigos de estado hace que las APIs sean más expresivas y fáciles de consumir.",
        "useCases": [
            "Recuperación exitosa de recursos (GET requests)",
            "Respuestas exitosas de búsquedas o consultas",
            "Actualizaciones parciales exitosas (PATCH)",
            "Cualquier operación exitosa que devuelve contenido en el cuerpo",
            "Respuestas de APIs que devuelven datos JSON o XML"
        ],
        "examples": [
            {
                "scenario": "GET request a una API REST",
                "request": "GET /api/users/123 HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 145\nCache-Control: max-age=3600\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}",
                "explanation": "El servidor devuelve exitosamente los datos del usuario solicitado en formato JSON"
            },
            {
                "scenario": "POST request que procesa datos",
                "request": "POST /api/search HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"query\": \"javascript tutorials\"}",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"results\": [\n    {\"title\": \"JS Basics\", \"url\": \"https://example.com/js-basics\"},\n    {\"title\": \"Advanced JS\", \"url\": \"https://example.com/advanced-js\"}\n  ],\n  \"count\": 2\n}",
                "explanation": "La búsqueda se procesó exitosamente y devuelve los resultados"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613634/1_bikeld.png",
                "alt": "Imagen que representa el nombre del código 200 OK"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619787/5-removebg-preview_wc1wto.png",
                "alt": "Imagen del código 200 OK"
            }
        ]
    },
    {
        "code": 201,
        "status": "Created",
        "category": "Success",
        "description": "El código 201 Created indica que la solicitud ha sido exitosa y ha resultado en la creación de uno o más recursos nuevos. Este código es semánticamente más apropiado que 200 OK cuando se crea un nuevo recurso, típicamente en respuesta a solicitudes POST o PUT. La respuesta 201 debe incluir un encabezado Location que contenga la URI del recurso recién creado, permitiendo al cliente acceder directamente al nuevo recurso sin necesidad de búsquedas adicionales. Opcionalmente, el cuerpo de la respuesta puede contener una representación del recurso creado o una descripción del estado de la creación. Este código es fundamental en APIs RESTful bien diseñadas, donde la creación de recursos es una operación común. Por ejemplo, cuando se crea un nuevo usuario, una nueva publicación de blog, un nuevo pedido de compra, o cualquier entidad en el sistema, 201 es la respuesta apropiada. La inclusión del encabezado Location es crucial porque permite a los clientes saber inmediatamente dónde encontrar el recurso recién creado, especialmente útil cuando el servidor genera IDs automáticamente. Algunas implementaciones también incluyen el recurso completo en el cuerpo de la respuesta para evitar que el cliente tenga que hacer una solicitud GET adicional.",
        "useCases": [
            "Creación de nuevos usuarios en un sistema",
            "Publicación de nuevos contenidos (artículos, posts, comentarios)",
            "Creación de pedidos o transacciones",
            "Registro de nuevas entidades en bases de datos mediante APIs",
            "Upload de archivos o recursos que generan nuevas entradas"
        ],
        "examples": [
            {
                "scenario": "Creación de un nuevo usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/users/456\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"created_at\": \"2024-01-16T14:22:00Z\",\n  \"profile_url\": \"/api/users/456\"\n}",
                "explanation": "El usuario fue creado exitosamente, el servidor asignó el ID 456 y devuelve la ubicación del nuevo recurso"
            },
            {
                "scenario": "Creación de un post en blog",
                "request": "POST /api/posts HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token123\n\n{\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"content\": \"HTTP status codes are...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/posts/789\nContent-Type: application/json\n\n{\n  \"id\": 789,\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"slug\": \"introduction-to-http-status-codes\",\n  \"author_id\": 123,\n  \"created_at\": \"2024-01-16T14:25:00Z\",\n  \"status\": \"published\"\n}",
                "explanation": "El post fue creado y publicado, incluyendo metadatos generados por el servidor como slug y timestamps"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613643/2_hapb2d.png",
                "alt": "Imagen que representa el nombre del código 201 Created"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619783/6-removebg-preview_ytp56u.png",
                "alt": "Imagen del codigo 201 Created"
            }
        ]
    },
    {
        "code": 202,
        "status": "Accepted",
        "category": "Success",
        "description": "El código 202 Accepted indica que la solicitud ha sido aceptada para procesamiento, pero el procesamiento aún no se ha completado. Este código es especialmente útil para operaciones asíncronas donde el servidor acepta la solicitud pero la procesará más tarde, en segundo plano. La respuesta 202 es no-comprometida, lo que significa que el servidor acepta la solicitud pero no garantiza que será procesada exitosamente - el procesamiento real podría fallar posteriormente. Este código es ideal para operaciones de larga duración como procesamiento de archivos grandes, conversiones de video, operaciones batch, envío de emails masivos, generación de reportes complejos, o cualquier tarea que no puede completarse inmediatamente dentro del tiempo de respuesta HTTP típico. La respuesta debería incluir información sobre el estado del procesamiento y cómo el cliente puede verificar el progreso, típicamente mediante un encabezado Location que apunta a un recurso de estado o mediante un cuerpo de respuesta que incluye un ID de tarea que puede ser consultado posteriormente. Muchas APIs modernas usan este patrón para operaciones pesadas, proporcionando endpoints separados para verificar el estado de las tareas en progreso.",
        "useCases": [
            "Procesamiento asíncrono de archivos (conversión de video, compresión de imágenes)",
            "Operaciones batch que toman tiempo significativo",
            "Envío de emails masivos o notificaciones",
            "Generación de reportes complejos o exports de datos",
            "Operaciones que requieren aprobación manual posterior",
            "Tareas en cola que serán procesadas por workers en background"
        ],
        "examples": [
            {
                "scenario": "Upload y procesamiento de video",
                "request": "POST /api/videos HTTP/1.1\nHost: media.example.com\nContent-Type: multipart/form-data\n\n[video file data]",
                "response": "HTTP/1.1 202 Accepted\nLocation: /api/jobs/video-process-999\nContent-Type: application/json\n\n{\n  \"job_id\": \"video-process-999\",\n  \"status\": \"queued\",\n  \"message\": \"Video upload accepted. Processing will begin shortly.\",\n  \"status_url\": \"/api/jobs/video-process-999\",\n  \"estimated_completion\": \"2024-01-16T15:30:00Z\"\n}",
                "explanation": "El video fue recibido y está en cola para procesamiento. El cliente puede verificar el estado usando la URL proporcionada"
            },
            {
                "scenario": "Generación de reporte complejo",
                "request": "POST /api/reports/generate HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\n\n{\n  \"type\": \"annual_sales\",\n  \"year\": 2024,\n  \"format\": \"pdf\",\n  \"include_charts\": true\n}",
                "response": "HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n  \"task_id\": \"report-gen-12345\",\n  \"status\": \"processing\",\n  \"progress_url\": \"/api/tasks/report-gen-12345/status\",\n  \"webhook_url\": null,\n  \"message\": \"Report generation started. You will be notified when complete.\"\n}",
                "explanation": "El servidor acepta la solicitud de generación de reporte y la procesa en background"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.3",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613646/3_clmvyi.png",
                "alt": "Imagen que representa el nombre del código 202 Accepted"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619780/7-removebg-preview_mh2ybs.png",
                "alt": "Imagen del código 202 Accepted"
            }
        ]
    },
    {
        "code": 203,
        "status": "Non-Authoritative Information",
        "category": "Success",
        "description": "El código 203 Non-Authoritative Information indica que la solicitud fue exitosa pero la información incluida en la respuesta proviene de una copia local o de terceros, no del servidor origen original. Este código es utilizado principalmente por proxies HTTP o cachés que modifican o transforman la respuesta del servidor origen. Aunque la respuesta es exitosa (similar a 200 OK), el código 203 advierte al cliente que los metadatos (encabezados) pueden haber sido modificados por un intermediario y pueden no ser exactamente los mismos que el servidor origen habría proporcionado. El cuerpo de la entidad puede ser idéntico al de una respuesta 200, pero los encabezados podrían ser diferentes. Este código es poco común en la práctica moderna pero es útil en escenarios donde proxies realizan transformaciones, como conversión de formatos de imagen, compresión adicional, añadir encabezados de seguridad, o modificar metadatos. Por ejemplo, un proxy de optimización podría comprimir imágenes antes de enviarlas al cliente y usar 203 para indicar que aunque el contenido es válido, ha sido procesado. También puede ser usado en escenarios de mirror servers o CDNs que sirven contenido desde múltiples ubicaciones y quieren indicar que la respuesta no viene directamente del servidor origen.",
        "useCases": [
            "Respuestas servidas por proxies que modifican metadatos",
            "CDNs o mirrors que sirven contenido almacenado en caché con encabezados modificados",
            "Proxies de transformación que optimizan contenido (compresión de imágenes, minificación)",
            "Sistemas de caché que añaden encabezados adicionales a las respuestas",
            "Servicios de agregación que combinan datos de múltiples fuentes"
        ],
        "examples": [
            {
                "scenario": "Proxy que modifica encabezados de imagen",
                "request": "GET /images/photo.jpg HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: image/jpeg\nContent-Length: 45000\nX-Proxy-Optimized: true\nX-Original-Size: 120000\nVia: 1.1 proxy.example.com\n\n[compressed image data]",
                "explanation": "Un proxy interceptó la imagen, la comprimió, y modificó los encabezados para reflejar el nuevo tamaño"
            },
            {
                "scenario": "CDN sirviendo contenido con metadatos adicionales",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: application/json\nX-Cache: HIT\nX-CDN-Server: edge-server-42\nAge: 3600\n\n{\"data\": \"cached content\"}",
                "explanation": "El CDN sirve contenido en caché y añade encabezados propios que no venían del servidor origen"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.4",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613641/4_jesleh.png",
                "alt": "Imagen que representa el nombre del código 203 Non-Authoritative Information"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619769/8-removebg-preview_cd7hdi.png",
                "alt": "Imagen del código 203 Non-Authoritative Information"
            }
        ]
    },
    {
        "code": 204,
        "status": "No Content",
        "category": "Success",
        "description": "El código 204 No Content indica que el servidor ha procesado exitosamente la solicitud pero no devuelve ningún contenido en el cuerpo de la respuesta. Este código es semánticamente diferente de 200 OK en que explícitamente comunica que no hay contenido para devolver, lo cual es la intención, no un error. La respuesta 204 no debe contener un cuerpo de mensaje - el mensaje termina después de los encabezados. Este código es extremadamente útil en APIs REST para operaciones que modifican el estado del servidor pero no necesitan devolver datos al cliente, como eliminaciones exitosas, actualizaciones donde el cliente ya tiene todos los datos necesarios, o acciones que simplemente cambian el estado sin generar nueva información. Es también común en solicitudes PUT o PATCH donde el cliente envía la representación completa del recurso y no necesita que el servidor la devuelva. El código 204 ahorra ancho de banda al no enviar cuerpos de respuesta innecesarios y hace que las APIs sean más eficientes. En aplicaciones web, una respuesta 204 típicamente no causa que el navegador actualice la página actual, lo cual es útil para operaciones AJAX que modifican datos en el servidor sin necesitar recargar la interfaz.",
        "useCases": [
            "Eliminación exitosa de recursos (DELETE requests)",
            "Actualizaciones que no requieren devolver el recurso modificado",
            "Operaciones de guardado automático donde no se necesita confirmación con datos",
            "Acciones que cambian estado del servidor sin generar nueva información",
            "Heartbeats o keep-alive requests",
            "Operaciones batch donde solo importa el éxito, no los detalles"
        ],
        "examples": [
            {
                "scenario": "Eliminación de un recurso",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token123",
                "response": "HTTP/1.1 204 No Content\nDate: Tue, 16 Jan 2024 15:00:00 GMT",
                "explanation": "El usuario fue eliminado exitosamente, no hay contenido adicional que devolver"
            },
            {
                "scenario": "Actualización de preferencias de usuario",
                "request": "PUT /api/users/123/preferences HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"theme\": \"dark\",\n  \"language\": \"es\",\n  \"notifications\": true\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "Las preferencias fueron actualizadas exitosamente, el cliente ya tiene los datos que envió"
            },
            {
                "scenario": "Guardado automático de documento",
                "request": "PATCH /api/documents/456/autosave HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\n\n{\n  \"content\": \"Updated document content...\",\n  \"last_modified\": \"2024-01-16T15:05:00Z\"\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "El documento fue guardado automáticamente sin necesidad de respuesta con contenido"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.5",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613653/5_efixbc.png",
                "alt": "Imagen que representa el nombre del código 204 No Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619773/9-removebg-preview_wavvrt.png",
                "alt": "Imagen del código 204 No Content"
            }
        ]
    },
    {
        "code": 205,
        "status": "Reset Content",
        "category": "Success",
        "description": "El código 205 Reset Content indica que el servidor ha procesado exitosamente la solicitud y está instruyendo al agente de usuario (típicamente un navegador) a resetear la vista del documento que causó la solicitud a su estado original. A diferencia de 204 No Content, que simplemente no devuelve contenido, 205 específicamente solicita que el cliente reinicie la interfaz de usuario. Este código es particularmente útil en aplicaciones de formularios web donde, después de enviar datos exitosamente, se desea limpiar el formulario para permitir al usuario ingresar nuevos datos sin necesidad de recargar la página completa. Por ejemplo, en un formulario de entrada de datos repetitiva (como ingreso de inventario, registro de múltiples transacciones, o captura de datos en serie), después de cada envío exitoso, el servidor puede responder con 205 para resetear el formulario automáticamente. Al igual que 204, la respuesta 205 no debe contener un cuerpo de mensaje. La diferencia clave es la semántica: 204 dice 'éxito, sin más información', mientras que 205 dice 'éxito, y por favor resetea tu interfaz'. En la práctica moderna, este código es poco utilizado ya que muchas aplicaciones manejan el reseteo de formularios directamente en el cliente con JavaScript, pero sigue siendo válido y útil para aplicaciones tradicionales basadas en formularios HTML.",
        "useCases": [
            "Formularios de entrada de datos repetitiva donde se quiere limpiar campos después del envío",
            "Aplicaciones de encuestas o cuestionarios que permiten múltiples respuestas",
            "Sistemas de captura de datos en serie (inventario, transacciones, registros)",
            "Formularios de búsqueda donde se quiere limpiar los criterios después de ejecutar la búsqueda",
            "Interfaces de administración con formularios que se usan repetidamente"
        ],
        "examples": [
            {
                "scenario": "Formulario de entrada de inventario",
                "request": "POST /inventory/add HTTP/1.1\nHost: warehouse.example.com\nContent-Type: application/x-www-form-urlencoded\n\nproduct_id=ABC123&quantity=50&location=warehouse-a",
                "response": "HTTP/1.1 205 Reset Content\nDate: Tue, 16 Jan 2024 15:10:00 GMT",
                "explanation": "El item fue agregado al inventario y el navegador debe limpiar el formulario para la siguiente entrada"
            },
            {
                "scenario": "Formulario de comentarios/feedback",
                "request": "POST /feedback/submit HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n  \"rating\": 5,\n  \"comment\": \"Excellent service!\",\n  \"category\": \"support\"\n}",
                "response": "HTTP/1.1 205 Reset Content",
                "explanation": "El feedback fue registrado y el formulario debe resetearse para permitir otro envío"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.6",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613651/6_blwgmz.png",
                "alt": "Imagen que representa el nombre del código 205 Reset Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619776/10-removebg-preview_lt16pz.png",
                "alt": "Imagen del código 205 Reset Content"
            }
        ]
    },
    {
        "code": 206,
        "status": "Partial Content",
        "category": "Success",
        "description": "El código 206 Partial Content indica que el servidor está entregando solo una parte del recurso solicitado debido a un encabezado Range enviado por el cliente. Este código es fundamental para la descarga de archivos grandes, streaming de video/audio, y para permitir la reanudación de descargas interrumpidas. Cuando un cliente solicita un rango específico de bytes de un recurso (por ejemplo, bytes 0-1023 de un archivo de 100MB), el servidor responde con 206 y solo los bytes solicitados. La respuesta debe incluir encabezados Content-Range que especifican qué porción del recurso se está enviando y el tamaño total del recurso, y Content-Length que indica el tamaño de la porción actual. Este mecanismo es esencial para aplicaciones de streaming donde el cliente puede solicitar chunks específicos de un video o audio, para administradores de descargas que dividen archivos grandes en múltiples segmentos para descargar en paralelo, y para reanudar descargas interrumpidas solicitando solo la porción faltante. Los navegadores modernos y reproductores de video utilizan extensivamente este código para permitir la búsqueda dentro de videos (cuando mueves la barra de progreso), para cargar solo las porciones visibles de archivos PDF grandes, o para implementar lazy loading eficiente de recursos multimedia.",
        "useCases": [
            "Streaming de video y audio (permitiendo seek/skip)",
            "Descarga resumible de archivos grandes",
            "Descarga paralela de archivos en múltiples segmentos",
            "Visualización de porciones específicas de documentos grandes (PDFs)",
            "Optimización de ancho de banda cargando solo lo necesario",
            "Implementación de lazy loading para contenido multimedia"
        ],
        "examples": [
            {
                "scenario": "Solicitud de rango de bytes de un video",
                "request": "GET /videos/movie.mp4 HTTP/1.1\nHost: cdn.example.com\nRange: bytes=1000000-2999999",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: video/mp4\nContent-Length: 2000000\nContent-Range: bytes 1000000-2999999/500000000\nAccept-Ranges: bytes\n\n[2MB de datos de video]",
                "explanation": "El servidor envía 2MB específicos del video (del byte 1M al byte 3M) de un total de 500MB"
            },
            {
                "scenario": "Reanudación de descarga interrumpida",
                "request": "GET /downloads/software.zip HTTP/1.1\nHost: downloads.example.com\nRange: bytes=50000000-",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: application/zip\nContent-Length: 50000000\nContent-Range: bytes 50000000-99999999/100000000\nAccept-Ranges: bytes\n\n[50MB restantes del archivo]",
                "explanation": "La descarga se reanuda desde el byte 50M hasta el final del archivo de 100MB"
            },
            {
                "scenario": "Descarga paralela con múltiples rangos",
                "request": "GET /files/large-dataset.dat HTTP/1.1\nHost: data.example.com\nRange: bytes=0-10485759,10485760-20971519",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=BOUNDARY_STRING\nContent-Length: 20971520\n\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 0-10485759/1073741824\n\n[primeros 10MB]\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 10485760-20971519/1073741824\n\n[siguientes 10MB]\n--BOUNDARY_STRING--",
                "explanation": "El cliente solicita dos rangos simultáneos para descarga paralela"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613659/7_ts5rgr.png",
                "alt": "Imagen que representa el nombre del código 206 Partial Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619763/11-removebg-preview_krzu2a.png",
                "alt": "Imagen del código 206 Partial Content"
            }
        ]
    },
    {
        "code": 207,
        "status": "Multi-Status",
        "category": "Success",
        "description": "El código 207 Multi-Status es utilizado principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para transmitir información sobre múltiples recursos cuando la operación sobre varios recursos puede tener resultados variados. A diferencia de otros códigos de estado que aplican a toda la respuesta, 207 indica que el cuerpo del mensaje contiene un documento XML con múltiples códigos de estado de respuesta, uno para cada recurso o sub-operación involucrada. Esto es esencial cuando se realizan operaciones sobre colecciones de recursos donde algunos pueden tener éxito y otros fallar. Por ejemplo, al intentar eliminar una carpeta con 10 archivos, 5 podrían eliminarse exitosamente (200), 3 podrían estar bloqueados (423), y 2 podrían no existir (404). El código 207 permite comunicar todos estos estados diferentes en una sola respuesta estructurada. El cuerpo de la respuesta típicamente contiene XML con elementos <response> para cada recurso, cada uno con su propio <status> y potencialmente <propstat> para propiedades. Esto hace que las operaciones batch sean más eficientes y permite al cliente manejar éxitos y fallos parciales de manera granular sin necesidad de múltiples requests individuales.",
        "useCases": [
            "Operaciones WebDAV sobre múltiples archivos o carpetas (PROPFIND, COPY, MOVE, DELETE)",
            "Operaciones batch en APIs que procesan múltiples recursos",
            "Sincronización de colecciones de recursos donde algunos pueden fallar",
            "Consultas de propiedades sobre múltiples recursos simultáneamente",
            "Operaciones de backup o restauración de múltiples archivos"
        ],
        "examples": [
            {
                "scenario": "PROPFIND sobre una colección de archivos",
                "request": "PROPFIND /documents/ HTTP/1.1\nHost: webdav.example.com\nDepth: 1\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <getcontentlength/>\n    <getlastmodified/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 1234\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/documents/file1.pdf</href>\n    <propstat>\n      <prop>\n        <getcontentlength>4500</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 12:00:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/file2.docx</href>\n    <propstat>\n      <prop>\n        <getcontentlength>15000</getcontentlength>\n        <getlastmodified>Tue, 16 Jan 2024 09:30:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/protected.txt</href>\n    <propstat>\n      <status>HTTP/1.1 403 Forbidden</status>\n    </propstat>\n  </response>\n</multistatus>",
                "explanation": "El servidor devuelve propiedades de múltiples archivos, algunos exitosos (200) y uno con acceso denegado (403)"
            },
            {
                "scenario": "Operación COPY batch sobre múltiples recursos",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup-folder/\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/source-folder/document1.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/document2.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/locked-file.dat</href>\n    <status>HTTP/1.1 423 Locked</status>\n  </response>\n</multistatus>",
                "explanation": "Algunos archivos se copiaron exitosamente mientras uno estaba bloqueado"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613656/8_gh0rl4.png",
                "alt": "Imagen que representa el nombre del código 207 Multi-Status"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619766/12-removebg-preview_xsybjn.png",
                "alt": "Imagen del código 207 Multi-Status"
            }
        ]
    },
    {
        "code": 208,
        "status": "Already Reported",
        "category": "Success",
        "description": "El código 208 Already Reported es utilizado exclusivamente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para evitar la enumeración repetida de recursos internos en respuestas Multi-Status. Este código representa una optimización crítica cuando se trabaja con bindings WebDAV, que son esencialmente referencias o enlaces a recursos que pueden aparecer en múltiples ubicaciones dentro de una jerarquía de carpetas. Cuando un cliente realiza una operación PROPFIND con profundidad infinita sobre una colección que contiene múltiples bindings (enlaces, referencias, o aliases) apuntando al mismo recurso subyacente, sin el código 208 la respuesta incluiría información completa del mismo recurso múltiples veces, una por cada binding. Esto no solo infla innecesariamente el tamaño de la respuesta XML sino que también consume recursos de procesamiento tanto en el servidor como en el cliente. El código 208 permite al servidor reportar el recurso completo la primera vez que lo encuentra durante el traversal de la jerarquía, y luego usar 208 Already Reported para las referencias subsecuentes al mismo recurso. Esto es análogo a cómo los lenguajes de programación manejan referencias circulares en estructuras de datos - la primera vez que encuentras un objeto lo procesas completamente, las siguientes veces solo indicas 'ya vimos esto'. En sistemas de archivos modernos con soporte para hard links, enlaces simbólicos, o sistemas distribuidos donde el mismo archivo puede ser accesible desde múltiples rutas virtuales, este código es esencial para mantener las respuestas manejables. La implementación correcta de 208 requiere que el servidor mantenga un registro de qué recursos ya ha incluido en la respuesta actual para evitar duplicación. Es importante notar que este código solo tiene sentido en el contexto de una respuesta 207 Multi-Status y específicamente en operaciones WebDAV que pueden atravesar colecciones con múltiples referencias.",
        "useCases": [
            "Operaciones PROPFIND recursivas sobre colecciones con bindings WebDAV duplicados",
            "Prevención de duplicación en listados de recursos en sistemas con hard links",
            "Optimización de respuestas en traversal de jerarquías con enlaces simbólicos",
            "Reducción del tamaño de respuestas XML en operaciones sobre estructuras complejas de carpetas",
            "Sistemas de archivos distribuidos donde el mismo recurso tiene múltiples rutas de acceso",
            "Implementaciones de versionado donde múltiples versiones pueden compartir contenido subyacente"
        ],
        "examples": [
            {
                "scenario": "PROPFIND recursivo con bindings duplicados",
                "request": "PROPFIND /workspace/projects/ HTTP/1.1\nHost: webdav.example.com\nDepth: infinity\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <displayname/>\n    <getcontentlength/>\n    <getcontenttype/>\n    <resourcetype/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/workspace/projects/shared-library/utils.js</href>\n    <propstat>\n      <prop>\n        <displayname>utils.js</displayname>\n        <getcontentlength>45000</getcontentlength>\n        <getcontenttype>application/javascript</getcontenttype>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/workspace/projects/project-a/lib/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-b/dependencies/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-c/shared/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El archivo utils.js es compartido por múltiples proyectos mediante bindings. Se reporta completamente solo la primera vez, las subsecuentes referencias usan 208 para evitar duplicación innecesaria de datos."
            },
            {
                "scenario": "Traversal de sistema con hard links",
                "request": "PROPFIND /storage/backups/ HTTP/1.1\nHost: dav.example.com\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/storage/backups/2024-01/database.dump</href>\n    <propstat>\n      <prop>\n        <displayname>database.dump</displayname>\n        <getcontentlength>524288000</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 02:00:00 GMT</getlastmodified>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/storage/backups/2024-02/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/storage/backups/latest/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El mismo archivo de backup está vinculado en múltiples directorios mediante hard links para deduplicación. Solo se reporta una vez con sus propiedades completas."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 5842, Section 7.1",
        "relatedCodes": [
            207
        ],
        "technicalNotes": "Este código solo es válido dentro del contexto de una respuesta 207 Multi-Status. El servidor debe implementar lógica para rastrear qué recursos ya han sido reportados durante el traversal de la jerarquía actual. No debe usarse fuera del contexto WebDAV.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613636/9_vly4qs.png",
                "alt": "Imagen que representa el nombre del código 208 Already Reported"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619797/13-removebg-preview_snc3fy.png",
                "alt": "Imagen del código 208 Already Reported"
            }
        ]
    },
    {
        "code": 214,
        "status": "Transformation Applied",
        "category": "Success (Warning Code)",
        "description": "El código 214 Transformation Applied es un código de advertencia HTTP que se transmite a través del encabezado Warning, no como código de estado HTTP principal. Los códigos de advertencia proporcionan información adicional sobre el estado de la respuesta que puede no ser evidente solo con el código de estado. El 214 específicamente informa al cliente que un intermediario (proxy, gateway, CDN) ha aplicado alguna transformación al contenido del mensaje antes de entregarlo. Estas transformaciones pueden ser dramáticas o sutiles: desde conversión de formatos de imagen (JPEG a WebP), transcodificación de video para diferentes dispositivos, compresión agresiva, minificación de código, aplicación de filtros de contenido, hasta modificación de resoluciones o tasas de bits. A diferencia del código de estado 203 Non-Authoritative Information que indica modificación de metadatos (encabezados), el código 214 se enfoca específicamente en transformaciones del cuerpo del mensaje. El formato del encabezado Warning es: 'Warning: 214 agent \"Transformation Applied\" \"descripción detallada\"' donde 'agent' identifica el intermediario que aplicó la transformación y la descripción explica qué se modificó. Esto es crucial para transparencia, debugging, y cumplimiento de políticas de contenido. Por ejemplo, un desarrollador depurando por qué una imagen se ve diferente en producción vs desarrollo puede ver el warning 214 y entender que un CDN está optimizando las imágenes. O un sistema de validación de contenido puede verificar que las transformaciones aplicadas cumplen con políticas corporativas. Los proxies modernos de optimización web, CDNs con procesamiento inteligente de assets, y gateways de adaptación de contenido para diferentes tipos de red (3G, 4G, 5G, WiFi) utilizan extensivamente este mecanismo. Es especialmente importante en contextos móviles donde los operadores de red pueden aplicar optimizaciones agresivas para reducir consumo de datos.",
        "useCases": [
            "Proxies de optimización que comprimen imágenes para reducir ancho de banda en redes lentas",
            "CDNs que convierten formatos de imagen a WebP o AVIF para navegadores compatibles",
            "Transcodificación automática de video según capacidades del dispositivo cliente",
            "Minificación y bundling de archivos JavaScript/CSS por intermediarios",
            "Aplicación de filtros de contenido corporativos o gubernamentales",
            "Adaptación de resolución de imágenes según tipo de conexión (WiFi vs móvil)",
            "Compresión adicional aplicada por operadores móviles en redes congestionadas",
            "Conversión de documentos a formatos más ligeros (por ejemplo, reducir calidad de PDFs)"
        ],
        "examples": [
            {
                "scenario": "CDN optimizando imagen para móvil",
                "request": "GET /assets/hero-image.jpg HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0...)\nAccept: image/webp,image/jpeg,*/*",
                "response": "HTTP/1.1 200 OK\nContent-Type: image/webp\nContent-Length: 28000\nWarning: 214 cdn.example.com \"Transformation Applied\" \"Original JPEG (150KB) converted to WebP format and compressed to 28KB for mobile optimization\"\nVary: Accept, User-Agent\nX-Original-Format: image/jpeg\nX-Original-Size: 153600\nVia: 1.1 cdn.example.com\n\n[WebP image data]",
                "explanation": "El CDN detectó un iPhone con soporte para WebP, convirtió la imagen original JPEG, aplicó compresión agresiva, y notificó la transformación mediante Warning 214."
            },
            {
                "scenario": "Proxy de operador móvil comprimiendo contenido",
                "request": "GET /download/whitepaper.pdf HTTP/1.1\nHost: docs.example.com\nVia: 1.1 mobile-proxy.carrier.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/pdf\nContent-Length: 450000\nWarning: 214 mobile-proxy.carrier.com \"Transformation Applied\" \"PDF images recompressed to reduce file size from 2.5MB to 450KB for data saving on mobile network\"\nX-Data-Saver-Applied: true\nX-Original-Size: 2621440\n\n[compressed PDF data]",
                "explanation": "El proxy del operador móvil aplicó compresión agresiva al PDF para ahorrar datos del plan del usuario."
            },
            {
                "scenario": "Transcodificación de video adaptativa",
                "request": "GET /videos/tutorial.mp4 HTTP/1.1\nHost: media.example.com\nUser-Agent: Mozilla/5.0 (Linux; Android 12...)",
                "response": "HTTP/1.1 200 OK\nContent-Type: video/mp4\nContent-Length: 15000000\nWarning: 214 video-gateway.example.com \"Transformation Applied\" \"Video transcoded from 1080p H.265 to 480p H.264 for Android device with limited bandwidth\"\nX-Original-Resolution: 1920x1080\nX-Original-Codec: hevc\nX-Transcoded-Resolution: 854x480\nX-Transcoded-Codec: h264\n\n[transcoded video data]",
                "explanation": "El gateway de video detectó un dispositivo Android en una conexión lenta y transcodificó el video a menor resolución y codec más compatible."
            },
            {
                "scenario": "Minificación de JavaScript por proxy corporativo",
                "request": "GET /js/app.js HTTP/1.1\nHost: cdn.example.com\nVia: 1.1 corporate-proxy.company.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/javascript\nContent-Length: 85000\nWarning: 214 corporate-proxy.company.com \"Transformation Applied\" \"JavaScript minified and comments removed, reduced from 245KB to 85KB\"\nX-Original-Size: 250880\nX-Minified: true\n\n[minified JavaScript code]",
                "explanation": "Un proxy corporativo minificó automáticamente el JavaScript para optimizar el ancho de banda de la red empresarial."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7234, Section 5.5",
        "headerFormat": "Warning: 214 agent \"Transformation Applied\" \"detailed description\"",
        "relatedHeaders": [
            "Via",
            "X-Original-Size",
            "X-Transformed-By",
            "Vary"
        ],
        "technicalNotes": "Este es un código de advertencia (Warning code), no un código de estado HTTP. Se transmite mediante el encabezado Warning. Múltiples advertencias pueden estar presentes en una sola respuesta. Los códigos de advertencia en el rango 2xx indican que no hubo error pero hay información adicional importante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613638/10_rezx3u.png",
                "alt": "Imagen que representa el nombre del código 214 Transformation Applied"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619790/14-removebg-preview_ypwtjm.png",
                "alt": "Imagen del código 214 Transformation Applied"
            }
        ]
    },
    {
        "code": 226,
        "status": "IM Used",
        "category": "Success",
        "description": "El código 226 IM Used (Instance Manipulation Used) indica que el servidor ha cumplido exitosamente con una solicitud GET para un recurso, pero en lugar de devolver la representación completa del recurso, está devolviendo el resultado de aplicar una o más manipulaciones de instancia (Instance Manipulations o IM) a la instancia actual del recurso. Este código es parte del framework de delta encoding especificado en RFC 3229, un mecanismo sofisticado diseñado para optimizar dramáticamente el uso de ancho de banda cuando los clientes solicitan recursos que han cambiado solo parcialmente desde una versión anterior que ya poseen. El concepto fundamental es simple pero poderoso: si tienes la versión 1 de un documento de 10MB y el servidor tiene la versión 2, en lugar de descargar los 10MB completos nuevamente, el servidor puede enviar solo un 'delta' (diferencia) de quizás 500KB que describe los cambios. El cliente entonces aplica este delta a su versión local para reconstruir la versión 2. El encabezado A-IM (Accept Instance Manipulation) en la solicitud especifica qué tipos de deltas o manipulaciones el cliente puede procesar (por ejemplo: vcdiff, gdiff, diffe, gzip). El servidor responde con 226 y el encabezado IM indica qué manipulación fue aplicada, mientras que Delta-Base identifica la versión base usada para calcular el delta. Este mecanismo es especialmente valioso para documentos grandes que evolucionan incrementalmente: bases de datos, archivos de configuración extensos, imágenes satelitales con actualizaciones periódicas, datasets científicos, o código fuente versionado. Aunque técnicamente poderoso, 226 es raramente implementado en la web moderna porque requiere soporte sofisticado tanto del cliente como del servidor, incluyendo algoritmos de diff/patch, gestión de versiones, y lógica de fallback. Muchos desarrolladores prefieren soluciones más simples como versionado de recursos con ETags para cacheo, o dividir recursos grandes en chunks más pequeños.",
        "useCases": [
            "Sincronización eficiente de archivos grandes con cambios incrementales (bases de datos, logs)",
            "Actualización de datasets científicos o geoespaciales que cambian parcialmente",
            "Distribución de actualizaciones de software mediante deltas en lugar de instaladores completos",
            "APIs que sirven documentos versionados donde el cliente probablemente tiene versiones anteriores",
            "Sistemas de colaboración en documentos grandes con control de versiones",
            "Optimización de ancho de banda en enlaces satelitales o conexiones lentas costosas",
            "Sincronización de repositorios de código fuente sobre HTTP (similar a Git pero vía HTTP puro)"
        ],
        "examples": [
            {
                "scenario": "Delta encoding con formato vcdiff",
                "request": "GET /datasets/weather-data.csv HTTP/1.1\nHost: data.example.com\nA-IM: vcdiff, diffe\nIf-None-Match: \"v2024-01-15-abc123\"\nAccept-Encoding: gzip",
                "response": "HTTP/1.1 226 IM Used\nETag: \"v2024-01-16-def456\"\nIM: vcdiff\nDelta-Base: \"v2024-01-15-abc123\"\nContent-Type: application/x-vcdiff\nContent-Encoding: gzip\nContent-Length: 125000\nCache-Control: private, must-revalidate\n\n[gzipped vcdiff delta data]",
                "explanation": "El cliente tiene los datos meteorológicos del 15 de enero. El servidor envía solo los cambios del 16 de enero usando formato vcdiff comprimido con gzip, reduciendo la transferencia de 50MB completos a solo 125KB de delta."
            },
            {
                "scenario": "Actualización incremental de documento JSON grande",
                "request": "GET /api/products-catalog.json HTTP/1.1\nHost: api.example.com\nA-IM: json-patch, json-merge-patch\nIf-None-Match: \"catalog-v105\"",
                "response": "HTTP/1.1 226 IM Used\nETag: \"catalog-v106\"\nIM: json-patch\nDelta-Base: \"catalog-v105\"\nContent-Type: application/json-patch+json\nContent-Length: 3500\n\n[\n  {\"op\": \"replace\", \"path\": \"/products/42/price\", \"value\": 29.99},\n  {\"op\": \"replace\", \"path\": \"/products/42/stock\", \"value\": 150},\n  {\"op\": \"add\", \"path\": \"/products/999\", \"value\": {\n    \"id\": 999,\n    \"name\": \"New Product\",\n    \"price\": 49.99,\n    \"stock\": 50\n  }},\n  {\"op\": \"remove\", \"path\": \"/products/123\"}\n]",
                "explanation": "En lugar de enviar todo el catálogo de productos (5MB), el servidor envía un JSON Patch (3.5KB) con solo los cambios: actualizaciones de precio/stock de un producto, adición de un producto nuevo, y eliminación de un producto descontinuado."
            },
            {
                "scenario": "Sincronización de base de datos SQLite",
                "request": "GET /db/application.db HTTP/1.1\nHost: sync.example.com\nA-IM: gdiff\nIf-None-Match: \"db-snapshot-20240115-120000\"\nRange: bytes=0-",
                "response": "HTTP/1.1 226 IM Used\nETag: \"db-snapshot-20240116-140000\"\nIM: gdiff\nDelta-Base: \"db-snapshot-20240115-120000\"\nContent-Type: application/x-gdiff\nContent-Length: 450000\n\n[gdiff binary delta data]",
                "explanation": "El cliente sincroniza una base de datos SQLite de 250MB. Solo han cambiado algunas tablas (nuevas filas, actualizaciones). El servidor calcula un delta binario de 450KB usando gdiff, evitando transferir los 250MB completos."
            },
            {
                "scenario": "Fallback cuando delta no es posible",
                "request": "GET /documents/report.pdf HTTP/1.1\nHost: docs.example.com\nA-IM: vcdiff\nIf-None-Match: \"report-v1\"",
                "response": "HTTP/1.1 200 OK\nETag: \"report-v5\"\nContent-Type: application/pdf\nContent-Length: 2500000\nVary: A-IM, If-None-Match\n\n[complete PDF file]",
                "explanation": "El cliente tiene la versión 1 pero la versión actual es 5. Los cambios son tan extensos que el delta sería casi tan grande como el archivo completo, o el servidor no tiene la versión intermedia. Se envía el archivo completo con código 200 en lugar de 226."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 3229, Section 10.4.1",
        "relatedHeaders": [
            "A-IM (Accept-Instance-Manipulation)",
            "IM (Instance-Manipulation)",
            "Delta-Base",
            "If-None-Match",
            "ETag"
        ],
        "deltaFormats": {
            "vcdiff": "Binary delta encoding format (RFC 3284), muy eficiente para archivos binarios",
            "gdiff": "Generic diff format, usado para diferencias binarias",
            "diffe": "Ed-style diff, basado en comandos de edición",
            "json-patch": "RFC 6902, para documentos JSON estructurados",
            "json-merge-patch": "RFC 7396, merge patches para JSON"
        },
        "technicalNotes": "El servidor debe almacenar versiones anteriores o calcular deltas on-the-fly. La implementación requiere algoritmos sofisticados de diff/patch. Si calcular el delta es más costoso que enviar el recurso completo, el servidor debe usar 200 OK. Los clientes deben implementar lógica de fallback para cuando 200 se recibe en lugar de 226.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613648/11_ozqx4y.png",
                "alt": "Imagen que representa el nombre del código 226 IM Used"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619794/15-removebg-preview_yxl4gy.png",
                "alt": "Imagen del código 226 IM Used"
            }
        ]
    },
    {
        "code": 300,
        "status": "Multiple Choices",
        "category": "Redirection",
        "description": "El código 300 Multiple Choices indica que el recurso solicitado corresponde a múltiples representaciones diferentes, cada una con su propia ubicación específica, y se está proporcionando información para que el agente de usuario (o el usuario final) pueda seleccionar una representación preferida y redirigir su solicitud a esa ubicación. Este código representa una situación de negociación de contenido donde el servidor no puede o no quiere tomar automáticamente la decisión sobre cuál variante servir. Es fundamentalmente diferente de otros códigos de redirección porque no impone una única redirección, sino que ofrece opciones. La respuesta debe incluir una lista de las alternativas disponibles junto con sus ubicaciones y características distintivas, permitiendo que el cliente (o usuario) haga una elección informada. Por ejemplo, un documento podría estar disponible en múltiples formatos (PDF, HTML, DOCX), idiomas (inglés, español, francés), o versiones (para principiantes, intermedio, avanzado). El servidor podría responder con 300 y proporcionar enlaces a todas estas variantes. El cuerpo de la respuesta típicamente contiene un documento HTML con enlaces a las diferentes opciones, o puede usar el encabezado Location para sugerir una opción preferida mientras lista otras alternativas en el cuerpo. En la práctica moderna, 300 es raramente utilizado porque los servidores generalmente implementan negociación de contenido automática basada en encabezados Accept, Accept-Language, Accept-Encoding del cliente, eligiendo la mejor representación y devolviéndola directamente con código 200 OK, o usando redirecciones 302/303 para dirigir automáticamente a una variante específica. Sin embargo, 300 sigue siendo útil en escenarios donde la elección tiene implicaciones significativas que no pueden ser determinadas automáticamente, como diferentes niveles de detalle de documentación, versiones con diferentes licencias, o formatos que requieren diferentes aplicaciones.",
        "useCases": [
            "Documentos disponibles en múltiples formatos que requieren elección explícita del usuario",
            "Contenido multilingüe donde el servidor no puede determinar automáticamente el idioma preferido",
            "Diferentes versiones de un recurso (simplificada, completa, técnica) donde la elección depende del contexto",
            "Recursos con múltiples licencias donde el usuario debe seleccionar términos específicos",
            "APIs que ofrecen múltiples endpoints para la misma funcionalidad con diferentes características",
            "Contenido disponible en diferentes niveles de calidad o resolución",
            "Archivos disponibles desde múltiples servidores mirror donde el usuario debe elegir el más cercano"
        ],
        "examples": [
            {
                "scenario": "Documento en múltiples formatos",
                "request": "GET /documentation/user-guide HTTP/1.1\nHost: docs.example.com\nAccept: */*",
                "response": "HTTP/1.1 300 Multiple Choices\nLocation: /documentation/user-guide.html\nContent-Type: text/html; charset=utf-8\nVary: Accept\n\n<!DOCTYPE html>\n<html>\n<head><title>Multiple Formats Available</title></head>\n<body>\n  <h1>User Guide - Multiple Formats</h1>\n  <p>This documentation is available in several formats:</p>\n  <ul>\n    <li><a href=\"/documentation/user-guide.html\">HTML Version</a></li>\n    <li><a href=\"/documentation/user-guide.pdf\">PDF Version</a></li>\n    <li><a href=\"/documentation/user-guide.epub\">EPUB Version</a></li>\n    <li><a href=\"/documentation/user-guide.docx\">DOCX Version</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El servidor ofrece el mismo contenido en cuatro formatos diferentes. El encabezado Location sugiere HTML como opción predeterminada, pero el usuario puede elegir cualquier formato según sus necesidades."
            },
            {
                "scenario": "Contenido multilingüe sin preferencia clara",
                "request": "GET /welcome HTTP/1.1\nHost: www.example.com\nAccept-Language: *",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: text/html; charset=utf-8\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head><title>Language Selection</title></head>\n<body>\n  <h1>Please select your language</h1>\n  <ul>\n    <li><a href=\"/welcome?lang=en\" hreflang=\"en\">English</a></li>\n    <li><a href=\"/welcome?lang=es\" hreflang=\"es\">Español</a></li>\n    <li><a href=\"/welcome?lang=fr\" hreflang=\"fr\">Français</a></li>\n    <li><a href=\"/welcome?lang=de\" hreflang=\"de\">Deutsch</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El cliente no especificó una preferencia clara de idioma, por lo que el servidor presenta todas las opciones de idioma disponibles para que el usuario elija."
            },
            {
                "scenario": "API con múltiples versiones",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: application/json\nLocation: /api/v3/data\n\n{\n  \"message\": \"Multiple API versions available\",\n  \"versions\": [\n    {\n      \"version\": \"v1\",\n      \"url\": \"/api/v1/data\",\n      \"status\": \"deprecated\"\n    },\n    {\n      \"version\": \"v2\",\n      \"url\": \"/api/v2/data\",\n      \"status\": \"stable\"\n    },\n    {\n      \"version\": \"v3\",\n      \"url\": \"/api/v3/data\",\n      \"status\": \"recommended\"\n    }\n  ]\n}",
                "explanation": "El endpoint base de la API devuelve información sobre todas las versiones disponibles, permitiendo que el cliente elija según sus necesidades de estabilidad versus características nuevas."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.1",
        "relatedHeaders": [
            "Location",
            "Vary",
            "Content-Type",
            "Link"
        ],
        "technicalNotes": "Aunque especificado en HTTP/1.0, es raramente usado en la práctica moderna. La mayoría de los servidores implementan content negotiation automática usando encabezados Accept-* y devuelven 200 OK con la mejor representación, o usan 302/303 para redirigir automáticamente.",
        "images": []
    },
    {
        "code": 301,
        "status": "Moved Permanently",
        "category": "Redirection",
        "description": "El código 301 Moved Permanently indica que el recurso solicitado ha sido movido permanentemente a una nueva ubicación URI, y todas las referencias futuras a este recurso deben usar una de las URIs devueltas. Este es uno de los códigos de redirección más importantes y ampliamente utilizados en HTTP, fundamental para SEO, mantenimiento de sitios web, y reorganización de estructuras de URLs. La palabra clave aquí es 'permanentemente' - este código comunica tanto a navegadores como a motores de búsqueda que el cambio es definitivo y no temporal. Los motores de búsqueda como Google, cuando encuentran un 301, transferirán el 'link juice' (valor SEO) del URL antiguo al nuevo, actualizarán sus índices, y eventualmente dejarán de rastrear el URL antiguo. Los navegadores típicamente almacenan en caché redirecciones 301, lo que significa que en visitas futuras pueden ir directamente al nuevo URL sin siquiera consultar el servidor sobre el URL antiguo. La respuesta debe incluir un encabezado Location con la nueva URI del recurso. Es crucial usar 301 correctamente: solo debe usarse cuando estás absolutamente seguro de que el movimiento es permanente. Si hay alguna posibilidad de que el recurso regrese al URL original en el futuro, usa 302 o 307 en su lugar. Las aplicaciones comunes incluyen: migración de HTTP a HTTPS, cambio de nombres de dominio, reestructuración de sitios web, consolidación de contenido duplicado, normalización de URLs (con/sin www, con/sin trailing slash), y redirección de páginas antiguas a nuevas versiones. Un uso inadecuado de 301 puede causar problemas graves: si rediriges permanentemente y luego intentas restaurar el URL original, los navegadores con caché pueden seguir redirigiendo automáticamente incluso después de que hayas eliminado la redirección del servidor.",
        "useCases": [
            "Migración permanente de HTTP a HTTPS para todo un sitio web",
            "Cambio de nombre de dominio (example.com a newbrand.com)",
            "Reestructuración de URLs (/old-page.html a /new-structure/page)",
            "Consolidación de contenido duplicado hacia una URL canónica",
            "Normalización de URLs (www.example.com a example.com o viceversa)",
            "Redirección de trailing slash (/page a /page/ o viceversa)",
            "Movimiento permanente de recursos a CDN o subdominios",
            "Redirección de páginas de productos discontinuados a categorías o alternativas",
            "Migración de plataformas (WordPress a Jamstack, cambio de CMS)",
            "Internacionalización (example.com/page a example.com/en/page)"
        ],
        "examples": [
            {
                "scenario": "Migración HTTP a HTTPS",
                "request": "GET /secure-page HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/secure-page\nContent-Type: text/html; charset=UTF-8\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"https://example.com/secure-page\">here</a>.</p>\n</body>\n</html>",
                "explanation": "El sitio ha migrado permanentemente a HTTPS. Todas las solicitudes HTTP son redirigidas a sus equivalentes HTTPS. Los motores de búsqueda actualizarán sus índices para usar HTTPS."
            },
            {
                "scenario": "Cambio de nombre de dominio",
                "request": "GET /products/widget-x HTTP/1.1\nHost: oldcompany.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://newcompany.com/products/widget-x\nCache-Control: max-age=31536000, immutable",
                "explanation": "La empresa cambió de nombre y dominio. Redirección permanente con caché de 1 año para maximizar eficiencia. Los motores de búsqueda transferirán el valor SEO al nuevo dominio."
            },
            {
                "scenario": "Reestructuración de URLs SEO-friendly",
                "request": "GET /page.php?id=123&category=electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://shop.example.com/electronics/products/smartphone-pro-123\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Moved</title>\n  <link rel=\"canonical\" href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">\n</head>\n<body>\n  <h1>This page has moved permanently</h1>\n  <p>New URL: <a href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">Smartphone Pro</a></p>\n</body>\n</html>",
                "explanation": "URLs antiguas con parámetros query son redirigidas permanentemente a URLs amigables para SEO. Incluye canonical tag para reforzar la URL correcta."
            },
            {
                "scenario": "Normalización www vs non-www",
                "request": "GET / HTTP/1.1\nHost: www.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/\nStrict-Transport-Security: max-age=31536000; includeSubDomains",
                "explanation": "Normalización permanente hacia versión sin www. Incluye HSTS para forzar HTTPS en futuras visitas y mejorar la seguridad."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.2",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Vary",
            "Link",
            "Deprecation",
            "Sunset"
        ],
        "technicalNotes": "En HTTP/1.0, la especificación permitía que navegadores cambiaran el método de POST a GET al seguir un 301. HTTP/1.1 clarificó que el método debe preservarse, pero muchos navegadores aún cambian POST a GET por compatibilidad histórica. Para comportamiento predecible con POST requests, usa 308 en su lugar. Los navegadores cachean 301 agresivamente incluso sin Cache-Control explícito.",
        "images": []
    },
    {
        "code": 302,
        "status": "Found",
        "category": "Redirection",
        "description": "El código 302 Found (originalmente 'Moved Temporarily' en HTTP/1.0) indica que el recurso solicitado reside temporalmente bajo una URI diferente. A diferencia de 301 que señala un cambio permanente, 302 comunica que el recurso puede volver a su ubicación original en el futuro, o que su ubicación temporal puede cambiar. Esta distinción es crucial tanto para navegadores como para motores de búsqueda. Los navegadores generalmente NO cachean redirecciones 302 de forma agresiva, lo que significa que seguirán consultando el URL original en futuras visitas. Los motores de búsqueda mantienen el URL original en sus índices y continúan rastreándolo, no transfieren el 'link juice' al URL de destino. El encabezado Location especifica la URI temporal donde el recurso puede encontrarse actualmente. El código 302 es históricamente ambiguo en cuanto al manejo del método HTTP: aunque la especificación HTTP/1.1 dice que el método de solicitud no debe cambiar al seguir la redirección, en la práctica la mayoría de los navegadores cambian POST a GET cuando siguen un 302. Esta inconsistencia llevó a la creación de códigos más específicos: 303 See Other (explícitamente cambia a GET) y 307 Temporary Redirect (explícitamente preserva el método). Sin embargo, 302 sigue siendo extremadamente común en la web moderna y es el código de redirección temporal por defecto en muchos frameworks y servidores web. Los casos de uso típicos incluyen: redirecciones post-login, redirecciones después de operaciones POST (pattern Post-Redirect-Get), mantenimiento temporal de sitios, A/B testing, distribución de carga entre servidores, redirecciones basadas en geolocalización, y páginas temporales de campaña de marketing.",
        "useCases": [
            "Redirección post-login a dashboard o página de perfil",
            "Patrón Post-Redirect-Get (PRG) para prevenir reenvíos de formularios",
            "Mantenimiento temporal del sitio (redirigir a página de mantenimiento)",
            "A/B testing y experimentos de usuario",
            "Redirecciones basadas en geolocalización o detección de idioma",
            "Páginas temporales de campaña de marketing o eventos",
            "Distribución temporal de carga entre servidores espejo",
            "Redirecciones condicionales basadas en cookies, sesión, o headers",
            "URLs cortas temporales para campañas (bit.ly, tinyurl)",
            "Redirección durante migraciones graduales (canary deployments)"
        ],
        "examples": [
            {
                "scenario": "Redirección post-login",
                "request": "POST /login HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=john&password=secret123",
                "response": "HTTP/1.1 302 Found\nLocation: https://example.com/dashboard\nSet-Cookie: session_id=abc123xyz; HttpOnly; Secure; SameSite=Lax\nCache-Control: no-store, no-cache, must-revalidate",
                "explanation": "Después de autenticación exitosa, el usuario es redirigido temporalmente a su dashboard. Se establece una cookie de sesión y se previene el cacheo de la redirección."
            },
            {
                "scenario": "Patrón Post-Redirect-Get (PRG)",
                "request": "POST /orders/create HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"product_id\": 456,\n  \"quantity\": 2\n}",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/orders/confirmation/789\nX-Order-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"order_id\": 789\n}",
                "explanation": "Después de crear la orden (POST), el servidor redirige a una página de confirmación (GET). Esto previene que el usuario reenvíe la orden accidentalmente al refrescar la página."
            },
            {
                "scenario": "Página de mantenimiento temporal",
                "request": "GET /products/electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/maintenance\nRetry-After: 3600\nCache-Control: no-cache, no-store\n\n<!DOCTYPE html>\n<html>\n<head><title>Temporary Maintenance</title></head>\n<body>\n  <h1>Scheduled Maintenance</h1>\n  <p>We're performing system upgrades. Please check back in 1 hour.</p>\n</body>\n</html>",
                "explanation": "Durante mantenimiento, las páginas redirigen temporalmente a una página de mantenimiento. Retry-After sugiere cuándo reintentar. La redirección es temporal porque las páginas normales volverán después del mantenimiento."
            },
            {
                "scenario": "Redirección basada en geolocalización",
                "request": "GET / HTTP/1.1\nHost: www.globalshop.com\nAccept-Language: es-MX\nX-Forwarded-For: 189.203.10.5",
                "response": "HTTP/1.1 302 Found\nLocation: https://www.globalshop.com/mx/\nVary: Accept-Language, X-Forwarded-For\nSet-Cookie: geo_region=mx; Path=/; Max-Age=86400\nCache-Control: private, no-cache",
                "explanation": "El servidor detecta que el usuario está en México y redirige temporalmente a la versión mexicana del sitio. La redirección es temporal porque el usuario podría estar viajando o usando VPN."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.3",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "Set-Cookie"
        ],
        "technicalNotes": "302 es históricamente ambiguo: la especificación dice preservar el método, pero la mayoría de los navegadores cambian POST a GET. Para comportamiento explícito: usa 303 (fuerza GET) o 307 (preserva método). Las redirecciones 302 generalmente NO se cachean agresivamente. Los motores de búsqueda mantienen el URL original en índices y no transfieren SEO value.",
        "images": []
    },
    {
        "code": 303,
        "status": "See Other",
        "category": "Redirection",
        "description": "El código 303 See Other indica que el servidor está redirigiendo al cliente a un recurso diferente, identificado por el URI en el encabezado Location, y que la respuesta a la solicitud original puede ser encontrada allí usando una solicitud GET. La característica distintiva y crucial de 303 es que SIEMPRE requiere que el cliente use el método GET para la solicitud redirigida, sin importar qué método HTTP se usó en la solicitud original. Esto lo hace perfectamente adecuado para el patrón Post-Redirect-Get (PRG), una de las mejores prácticas más importantes en desarrollo web. El código 303 fue introducido en HTTP/1.1 específicamente para eliminar la ambigüedad del código 302, que teóricamente debería preservar el método pero en la práctica los navegadores lo cambian a GET. Con 303, este comportamiento está explícitamente codificado en la especificación: si un servidor responde con 303 a una solicitud POST, el navegador DEBE hacer una solicitud GET al URL en el encabezado Location. Esto resuelve el problema clásico de 'duplicación de envíos de formularios' donde un usuario envía un formulario (POST), ve la página de confirmación, y luego al refrescar el navegador, se le pregunta si quiere reenviar el formulario. Con 303, el flujo es: (1) usuario envía formulario con POST, (2) servidor procesa y responde 303 con Location a página de confirmación, (3) navegador hace GET a esa página de confirmación, (4) usuario ve confirmación y puede refrescar sin problemas porque ahora es un GET simple. El código 303 es semánticamente diferente de 302 y 307: mientras que 302 es ambiguo y 307 preserva explícitamente el método, 303 explícitamente cambia a GET. Es la elección correcta para cualquier situación donde procesas una operación de modificación de estado (POST, PUT, DELETE) y quieres redirigir al usuario a una representación del resultado.",
        "useCases": [
            "Implementación del patrón Post-Redirect-Get (PRG) después de envíos de formularios",
            "Redirección después de operaciones POST, PUT, DELETE en APIs REST",
            "Confirmaciones de operaciones que modifican estado (creación, actualización, eliminación)",
            "Redirección después de procesamiento de pagos o transacciones",
            "Redirigir desde endpoint de acción a vista de recurso",
            "Prevenir reenvíos accidentales de formularios al refrescar navegador",
            "Redirección de operaciones asíncronas completadas a página de resultados",
            "Upload de archivos seguido de redirección a página de vista previa"
        ],
        "examples": [
            {
                "scenario": "Patrón Post-Redirect-Get clásico",
                "request": "POST /contact HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&email=john%40example.com&message=Hello",
                "response": "HTTP/1.1 303 See Other\nLocation: https://example.com/contact/thank-you\nCache-Control: no-cache, no-store, must-revalidate\nX-Message-ID: msg_123456\n\n<!DOCTYPE html>\n<html>\n<head><title>Message Sent</title></head>\n<body>\n  <p>Your message has been sent successfully.</p>\n  <p>Redirecting to confirmation page...</p>\n</body>\n</html>",
                "explanation": "Después de procesar el formulario de contacto (POST), el servidor redirige con 303 a una página de agradecimiento. El navegador hará GET a /contact/thank-you. Si el usuario refresca, solo re-hace el GET, no reenvía el formulario."
            },
            {
                "scenario": "Creación de recurso en API REST",
                "request": "POST /api/articles HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token_abc123\n\n{\n  \"title\": \"Understanding HTTP 303\",\n  \"content\": \"The 303 status code is...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://blog.example.com/api/articles/789\nX-Article-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"message\": \"Article published successfully\",\n  \"article_id\": 789,\n  \"view_url\": \"/api/articles/789\"\n}",
                "explanation": "El artículo fue creado exitosamente. En lugar de devolver 201 Created, el servidor usa 303 para indicar que el cliente debe hacer GET a /api/articles/789 para ver el recurso completo. Esto separa claramente la operación de creación (POST) de la recuperación (GET)."
            },
            {
                "scenario": "Procesamiento de pago con redirección",
                "request": "POST /checkout/process-payment HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_visa_1234\",\n  \"cart_id\": \"cart_xyz789\"\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://shop.example.com/orders/confirmation/ord_456\nX-Order-ID: ord_456\nX-Transaction-ID: txn_789xyz\nSet-Cookie: cart_id=; Max-Age=0; Path=/\nCache-Control: no-store, no-cache\n\n{\n  \"status\": \"payment_successful\",\n  \"order_id\": \"ord_456\",\n  \"confirmation_url\": \"/orders/confirmation/ord_456\"\n}",
                "explanation": "Después de procesar el pago exitosamente, el servidor redirige con 303 a la página de confirmación de orden. Esto previene que el usuario accidentalmente procese el pago dos veces si refresca la página."
            },
            {
                "scenario": "Eliminación de recurso con redirección a lista",
                "request": "DELETE /api/users/123 HTTP/1.1\nHost: admin.example.com\nAuthorization: Bearer admin_token_xyz\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 303 See Other\nLocation: https://admin.example.com/api/users\nX-Deleted-User-ID: 123\nCache-Control: no-cache\n\n{\n  \"status\": \"deleted\",\n  \"message\": \"User account deleted successfully\",\n  \"deleted_user_id\": 123,\n  \"redirect_to\": \"/api/users\"\n}",
                "explanation": "Después de eliminar el usuario (DELETE), el servidor redirige con 303 a la lista de usuarios. El cliente hará GET a /api/users para ver la lista actualizada sin el usuario eliminado."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.4",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "X-Request-ID",
            "X-Resource-ID"
        ],
        "technicalNotes": "303 fue introducido en HTTP/1.1 para resolver la ambigüedad de 302. El método SIEMPRE cambia a GET - esto no es un bug, es la característica principal. Los navegadores SIEMPRE cambian el método a GET cuando siguen una redirección 303, sin importar el método original (POST, PUT, DELETE). Si necesitas preservar el método, usa 307 en su lugar.",
        "images": []
    },
    {
        "code": 304,
        "status": "Not Modified",
        "category": "Redirection",
        "description": "El código 304 Not Modified es un código de estado especial que indica que el recurso no ha sido modificado desde la versión especificada por los encabezados de solicitud condicional del cliente (If-Modified-Since, If-None-Match), y por lo tanto el cliente puede usar su copia en caché. Este código es fundamental para la optimización del rendimiento web y el ahorro de ancho de banda. A diferencia de otros códigos de redirección, 304 no redirige a una ubicación diferente, sino que instruye al cliente a usar la copia que ya tiene almacenada localmente. El flujo típico funciona así: (1) cliente hace una solicitud inicial GET y recibe 200 OK con el recurso completo más encabezados ETag y/o Last-Modified, (2) cliente almacena el recurso en caché junto con estos validadores, (3) en solicitudes subsecuentes, cliente incluye If-None-Match (con el ETag) y/o If-Modified-Since (con la fecha), (4) servidor verifica si el recurso cambió comparando con los validadores, (5) si NO cambió, servidor responde 304 sin cuerpo de mensaje - solo headers, (6) cliente usa su versión cacheada. Esto ahorra ancho de banda significativo porque solo se transmiten headers (aproximadamente 200-500 bytes) en lugar del recurso completo (que podría ser megabytes). La respuesta 304 NUNCA debe contener un cuerpo de mensaje - el mensaje termina inmediatamente después de los encabezados. Debe incluir headers que habrían sido enviados con 200 OK si el recurso hubiera sido modificado, específicamente: Date, ETag, Cache-Control, Expires, Vary. El código 304 es esencial para: carga eficiente de sitios web con muchos assets estáticos, APIs que sirven datos que cambian infrecuentemente, distribución de contenido mediante CDNs, reducción de carga en servidores de origen, mejora de velocidad percibida por usuarios, y optimización de consumo de datos en dispositivos móviles.",
        "useCases": [
            "Validación de caché para assets estáticos (imágenes, CSS, JavaScript)",
            "APIs que sirven datos que cambian infrecuentemente",
            "Verificación de actualizaciones de recursos sin transferir todo el contenido",
            "Optimización de rendimiento en sitios web con muchos recursos",
            "Reducción de ancho de banda en aplicaciones móviles",
            "Implementación de polling eficiente para verificar cambios",
            "CDN edge caching y validación con servidores origen",
            "Sincronización eficiente de recursos entre cliente y servidor"
        ],
        "examples": [
            {
                "scenario": "Validación con ETag - recurso no modificado",
                "request": "GET /assets/logo.png HTTP/1.1\nHost: cdn.example.com\nIf-None-Match: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: max-age=0",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:00:00 GMT\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: public, max-age=31536000, immutable\nVary: Accept-Encoding\nX-Cache: HIT",
                "explanation": "El cliente tiene logo.png con ETag específico. El servidor verifica que el archivo no ha cambiado (mismo ETag) y responde 304. El navegador usa su copia cacheada. No se transmite la imagen, ahorrando ancho de banda significativo."
            },
            {
                "scenario": "Validación con Last-Modified - recurso no modificado",
                "request": "GET /api/products.json HTTP/1.1\nHost: api.example.com\nIf-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:05:00 GMT\nLast-Modified: Mon, 15 Jan 2024 10:00:00 GMT\nCache-Control: private, must-revalidate, max-age=3600\nVary: Accept",
                "explanation": "El cliente pregunta si products.json cambió desde el 15 de enero. No ha cambiado, entonces el servidor responde 304. Cliente usa su copia cacheada, ahorrando potencialmente varios MB de datos JSON."
            },
            {
                "scenario": "Validación con ETag - recurso SÍ modificado",
                "request": "GET /news/latest-article HTTP/1.1\nHost: blog.example.com\nIf-None-Match: \"old-etag-abc123\"\nAccept: text/html",
                "response": "HTTP/1.1 200 OK\nDate: Tue, 16 Jan 2024 19:10:00 GMT\nETag: \"new-etag-xyz789\"\nLast-Modified: Tue, 16 Jan 2024 18:00:00 GMT\nContent-Type: text/html; charset=utf-8\nCache-Control: public, max-age=600\n\n<!DOCTYPE html>\n<html>\n<head><title>Breaking News Updated!</title></head>\n<body>\n  <article>\n    <h1>Major Update to Story</h1>\n    <p>New information has emerged...</p>\n  </article>\n</body>\n</html>",
                "explanation": "El artículo fue actualizado (ETag diferente), entonces el servidor responde 200 OK con el contenido completo actualizado y nuevo ETag. El cliente reemplaza su caché con la nueva versión."
            },
            {
                "scenario": "API polling eficiente",
                "request": "GET /api/notifications HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nIf-None-Match: W/\"notifications-hash-abc\"\nX-Polling-Interval: 30",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:20:00 GMT\nETag: W/\"notifications-hash-abc\"\nCache-Control: private, no-cache, must-revalidate\nX-Poll-Interval: 30",
                "explanation": "Cliente hace polling cada 30 segundos para notificaciones. No hay nuevas notificaciones, entonces 304. Esto es muchísimo más eficiente que transferir la lista completa de notificaciones en cada poll."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7232, Section 4.1",
        "relatedHeaders": [
            "If-Modified-Since",
            "If-None-Match",
            "ETag",
            "Last-Modified",
            "Date",
            "Cache-Control",
            "Expires",
            "Vary"
        ],
        "technicalNotes": "La respuesta 304 NUNCA debe incluir un cuerpo de mensaje. DEBE incluir Date header. DEBE incluir ETag y/o Last-Modified si estaban en la respuesta 200 original. DEBE incluir Cache-Control y Expires si aplican. NO debe incluir Content-Length porque no hay cuerpo. Los navegadores automáticamente incluyen If-None-Match/If-Modified-Since cuando revalidan recursos cacheados.",
        "images": []
    },
    {
        "code": 305,
        "status": "Use Proxy",
        "category": "Redirection",
        "description": "El código 305 Use Proxy indica que el recurso solicitado debe ser accedido a través de un proxy especificado en el encabezado Location. Este código fue definido en versiones anteriores de la especificación HTTP pero ha sido DEPRECADO en HTTP/1.1 debido a serias preocupaciones de seguridad. El código 305 fue diseñado originalmente para permitir que los servidores indiquen a los clientes que deben acceder a un recurso específico a través de un proxy particular. Sin embargo, esta funcionalidad presentaba riesgos significativos de seguridad ya que permitía que servidores potencialmente maliciosos obligaran a los clientes a enrutar su tráfico a través de proxies no confiables, lo que podría resultar en ataques man-in-the-middle, interceptación de datos sensibles, modificación de contenido, o redirección a sitios maliciosos. Debido a estos riesgos, la mayoría de los navegadores modernos y clientes HTTP ignoran completamente el código 305 y nunca lo implementaron correctamente. El código fue formalmente deprecado y las implementaciones modernas NO deben usarlo ni responder a él. En lugar de 305, las configuraciones de proxy deben ser manejadas a nivel de sistema operativo, configuración de red, o mediante configuración explícita del usuario en la aplicación cliente (como las configuraciones de proxy en navegadores). La especificación HTTP/1.1 revisada recomienda explícitamente NO usar este código bajo ninguna circunstancia. Si un servidor necesita comunicar información sobre proxies, debe hacerlo a través de otros mecanismos más seguros como encabezados informativos personalizados, documentación fuera de banda, o configuración manual del cliente. El código 305 representa un ejemplo importante en la evolución de HTTP de cómo consideraciones de seguridad pueden llevar a la deprecación de características que parecían útiles pero resultaron ser vectores de ataque potenciales.",
        "useCases": [
            "NINGUNO - Este código está DEPRECADO y NO debe ser usado",
            "Históricamente fue diseñado para indicar uso de proxy, pero fue abandonado por riesgos de seguridad",
            "No tiene casos de uso válidos en implementaciones modernas"
        ],
        "examples": [
            {
                "scenario": "Ejemplo histórico (NO usar en producción)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 305 Use Proxy\nLocation: http://proxy.example.com:8080\n\n[Este código está DEPRECADO y no debe ser usado]",
                "explanation": "Este es solo un ejemplo histórico de cómo se habría usado 305. En la práctica moderna, este código NUNCA debe ser usado debido a graves riesgos de seguridad. Los navegadores modernos lo ignoran completamente."
            },
            {
                "scenario": "Respuesta moderna correcta (usar configuración de proxy apropiada)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nX-Proxy-Info: For proxy configuration, see https://example.com/proxy-setup\n\n{\n  \"message\": \"Resource accessed successfully\",\n  \"proxy_documentation\": \"https://example.com/proxy-setup\"\n}",
                "explanation": "En lugar de usar 305 deprecado, proporciona información sobre configuración de proxy a través de documentación o headers informativos. La configuración de proxy debe manejarse a nivel de cliente, no mediante respuestas HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1 (DEPRECADO)",
        "specification": "RFC 7231, Section 6.4.5 (marcado como deprecado)",
        "relatedHeaders": [
            "Location"
        ],
        "technicalNotes": "Este código está OFICIALMENTE DEPRECADO desde HTTP/1.1. Fue removido de la especificación debido a serias preocupaciones de seguridad. Los navegadores modernos NO lo implementan y lo ignoran. Representaba un vector de ataque para man-in-the-middle. NUNCA debe ser usado en implementaciones nuevas. Las configuraciones de proxy deben manejarse a nivel de sistema operativo, configuración de red del usuario, o PAC (Proxy Auto-Config) files, NO mediante respuestas HTTP.",
        "images": []
    },
    {
        "code": 306,
        "status": "Switch Proxy",
        "category": "Redirection",
        "description": "El código 306 Switch Proxy es un código de estado que ya no se utiliza en las especificaciones HTTP modernas y está completamente OBSOLETO. Este código fue definido en una versión preliminar de la especificación HTTP/1.1 pero nunca llegó a ser parte del estándar oficial final. Originalmente, el código 306 estaba destinado a indicar que las solicitudes subsecuentes deben usar el proxy especificado, similar en concepto al deprecado 305 Use Proxy, pero con la intención de que fuera utilizado en solicitudes futuras en lugar de la solicitud actual. Sin embargo, debido a las mismas preocupaciones graves de seguridad que llevaron a la deprecación del código 305, el código 306 fue eliminado completamente de la especificación antes de su finalización. El código 306 nunca fue ampliamente implementado por navegadores o servidores web, y hoy en día no tiene ningún significado definido en HTTP. Si un servidor envía un código 306, los clientes modernos no sabrán cómo manejarlo correctamente. En la especificación oficial RFC 7231 de HTTP/1.1, el código 306 simplemente está marcado como '(Unused)' - no utilizado. El espacio del código 306 fue reservado pero nunca se le asignó un significado oficial, y permanece sin uso en todas las versiones modernas de HTTP. Esto representa un caso interesante en el desarrollo de estándares donde un código fue propuesto, asignado un número, pero luego abandonado antes de la ratificación final del estándar. A diferencia del 305 que fue oficialmente deprecado después de ser parte del estándar, el 306 simplemente nunca llegó a existir oficialmente. En implementaciones modernas, este código no debe ser usado bajo ninguna circunstancia y si se encuentra en respuestas, debe ser tratado como un error desconocido o no válido.",
        "useCases": [
            "NINGUNO - Este código está completamente OBSOLETO y nunca fue parte del estándar oficial",
            "No tiene significado definido en HTTP moderno",
            "Fue abandonado antes de la finalización de HTTP/1.1",
            "No debe ser usado en ninguna implementación"
        ],
        "examples": [
            {
                "scenario": "Código obsoleto sin uso oficial",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 306 (Unused)\n\n[Este código NO tiene significado oficial y NO debe ser usado]",
                "explanation": "El código 306 nunca fue oficialmente definido en el estándar HTTP final. Si un servidor responde con 306, los clientes modernos no sabrán cómo manejarlo. Este código simplemente no debe ser usado."
            },
            {
                "scenario": "Manejo correcto en cliente moderno",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "Si un cliente recibe 306:\n- Debe tratarlo como un código de estado desconocido\n- Puede registrar un error o advertencia\n- No debe intentar interpretarlo como una redirección válida\n- Debería fallar la solicitud o usar comportamiento de fallback",
                "explanation": "Los clientes modernos correctamente implementados no tienen lógica especial para manejar 306 porque nunca fue parte del estándar. Si se encuentra, indica un problema de configuración del servidor."
            }
        ],
        "httpVersion": "HTTP/1.1 (NUNCA OFICIALIZADO)",
        "specification": "RFC 7231 - marcado como '(Unused)' / Sin uso oficial",
        "relatedHeaders": [],
        "technicalNotes": "El código 306 fue propuesto en borradores tempranos de HTTP/1.1 pero fue eliminado antes de la especificación final. En RFC 7231, aparece listado como '306 (Unused)' indicando que el número está reservado pero sin significado asignado. A diferencia del 305 que fue deprecado después de uso, el 306 simplemente nunca existió oficialmente. NO debe ser implementado ni usado en sistemas modernos. Su presencia en listados de códigos HTTP es puramente histórica.",
        "images": []
    },
    {
        "code": 307,
        "status": "Temporary Redirect",
        "category": "Redirection",
        "description": "El código 307 Temporary Redirect indica que el recurso solicitado reside temporalmente bajo una URI diferente, y el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. Esta es la diferencia crítica y el propósito principal del código 307: garantizar que el método HTTP se preserve durante la redirección. Mientras que el código 302 Found es históricamente ambiguo (la especificación dice preservar el método, pero los navegadores cambian POST a GET en la práctica), el código 307 elimina toda ambigüedad al requerir explícitamente que el método se mantenga idéntico. Si la solicitud original fue POST, la solicitud redirigida también debe ser POST. Si fue DELETE, la redirigida también debe ser DELETE. Esto es esencial en escenarios donde el método HTTP tiene significado semántico importante y cambiarlo podría causar comportamiento incorrecto o inseguro. Por ejemplo, si un cliente envía una solicitud POST con datos importantes a un servidor que responde con redirección, es crucial que esos datos sean enviados al nuevo destino también con POST, no convertidos a GET (que podría perder los datos del cuerpo o exponerlos en la URL). El código 307 fue introducido en HTTP/1.1 específicamente para proporcionar una versión sin ambigüedades del 302 que preserve el método. Al igual que 302, el 307 indica que la redirección es temporal, no permanente, por lo que los motores de búsqueda deben mantener el URL original en sus índices y los navegadores no deben cachear la redirección de forma agresiva. Los casos de uso comunes incluyen: mantenimiento temporal donde se necesita redirigir solicitudes POST, balanceo de carga que preserva el método de la solicitud, redirecciones de API donde el método es crítico para la semántica de la operación, y cualquier escenario de redirección temporal donde cambiar el método HTTP sería semánticamente incorrecto o podría causar pérdida de datos.",
        "useCases": [
            "Redirecciones temporales donde preservar el método HTTP es crítico",
            "Mantenimiento temporal de APIs que manejan POST, PUT, DELETE",
            "Balanceo de carga entre servidores manteniendo el método original",
            "Redirecciones de APIs RESTful donde el método define la operación",
            "Migración gradual de endpoints preservando semántica del método",
            "Redirección temporal de uploads (POST con archivos)",
            "Failover entre servidores sin cambiar la naturaleza de la solicitud",
            "Testing A/B de APIs donde el método debe mantenerse consistente"
        ],
        "examples": [
            {
                "scenario": "Redirección POST preservando el método",
                "request": "POST /api/orders HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"product_id\": 789,\n  \"quantity\": 3,\n  \"customer_id\": 456,\n  \"shipping_address\": \"123 Main St\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-backup.example.com/api/orders\nRetry-After: 120\nCache-Control: no-cache, no-store\nX-Redirect-Reason: primary_server_maintenance\n\n{\n  \"message\": \"Primary server under maintenance\",\n  \"redirect_to\": \"https://api-backup.example.com/api/orders\",\n  \"note\": \"Your request will be resubmitted automatically\"\n}",
                "explanation": "El servidor principal está en mantenimiento temporal. La redirección 307 asegura que el navegador/cliente reenvíe la solicitud POST completa con todos los datos del pedido al servidor de backup, sin cambiar a GET que perdería los datos."
            },
            {
                "scenario": "Balanceo de carga con método preservado",
                "request": "PUT /api/users/123/profile HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john.new@example.com\",\n  \"phone\": \"+1234567890\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-node-2.example.com/api/users/123/profile\nX-Load-Balancer: round-robin\nX-Target-Node: node-2\nCache-Control: no-cache\n\n{\n  \"status\": \"redirecting\",\n  \"target_server\": \"node-2\",\n  \"message\": \"Request being routed to optimal server node\"\n}",
                "explanation": "El load balancer redirige temporalmente la solicitud PUT a otro nodo del cluster. El código 307 garantiza que la solicitud PUT con los datos de actualización del perfil se envíe al nuevo servidor, no se convierta en GET."
            },
            {
                "scenario": "Upload de archivo con redirección temporal",
                "request": "POST /api/uploads HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data; boundary=----Boundary\nContent-Length: 5242880\n\n------Boundary\nContent-Disposition: form-data; name=\"file\"; filename=\"report.pdf\"\nContent-Type: application/pdf\n\n[5MB de datos del archivo PDF]\n------Boundary--",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://storage-region-2.example.com/api/uploads\nX-Storage-Region: us-west-2\nX-Redirect-Reason: region_optimization\nRetry-After: 0\n\n{\n  \"message\": \"Redirecting to optimal storage region\",\n  \"target_region\": \"us-west-2\",\n  \"note\": \"File upload will be resubmitted automatically\"\n}",
                "explanation": "El sistema de storage detecta que el usuario está más cerca de otra región y redirige temporalmente. El código 307 asegura que el POST con el archivo completo se reenvíe al servidor de la nueva región sin perder datos."
            },
            {
                "scenario": "Mantenimiento de API con DELETE preservado",
                "request": "DELETE /api/articles/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_abc\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-maintenance.example.com/api/articles/456\nX-Maintenance-Mode: true\nX-Estimated-Duration: 1800\nCache-Control: no-store\n\n{\n  \"status\": \"maintenance_redirect\",\n  \"message\": \"Main API under scheduled maintenance\",\n  \"maintenance_endpoint\": \"https://api-maintenance.example.com\",\n  \"operation_will_complete\": true\n}",
                "explanation": "Durante mantenimiento programado, las solicitudes DELETE son redirigidas a un servidor de mantenimiento que puede procesarlas. El 307 preserva el método DELETE para que la operación de eliminación se ejecute correctamente en el nuevo servidor."
            },
            {
                "scenario": "Migración gradual de endpoints",
                "request": "PATCH /api/v2/settings/notifications HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\n\n{\n  \"email_notifications\": false,\n  \"push_notifications\": true\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://new-api.example.com/api/v2/settings/notifications\nX-Migration-Phase: gradual-rollout\nX-Legacy-Endpoint: deprecated\nDeprecation: true\nLink: <https://docs.example.com/api-migration>; rel=\"deprecation\"\n\n{\n  \"message\": \"This endpoint is being migrated to new infrastructure\",\n  \"new_location\": \"https://new-api.example.com/api/v2/settings/notifications\",\n  \"migration_guide\": \"https://docs.example.com/api-migration\"\n}",
                "explanation": "Durante una migración gradual de API, el endpoint antiguo redirige temporalmente al nuevo con 307, preservando el método PATCH y los datos de actualización de configuración."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.7",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "X-Redirect-Reason"
        ],
        "technicalNotes": "El código 307 fue introducido en HTTP/1.1 para eliminar la ambigüedad del 302. La diferencia clave es que 307 GARANTIZA que el método HTTP se preserve (POST sigue siendo POST, PUT sigue siendo PUT, etc.), mientras que 302 en la práctica causa que navegadores cambien POST a GET. Para redirecciones temporales donde el método debe preservarse, siempre usa 307. Para redirecciones temporales donde cambiar a GET es aceptable o deseado, usa 302 o mejor aún 303. Los navegadores NO cachean 307 agresivamente, similar a 302. Los motores de búsqueda mantienen el URL original en índices.",
        "images": []
    },
    {
        "code": 308,
        "status": "Permanent Redirect",
        "category": "Redirection",
        "description": "El código 308 Permanent Redirect indica que el recurso solicitado ha sido movido permanentemente a una nueva URI especificada en el encabezado Location, y todas las futuras solicitudes deben usar la nueva URI. Además, y esto es lo más importante, el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. El código 308 es a 301 lo que 307 es a 302: proporciona una versión sin ambigüedades que garantiza la preservación del método HTTP. Mientras que el código 301 Moved Permanently es históricamente ambiguo (muchos navegadores cambian POST a GET al seguir un 301, aunque la especificación dice preservar el método), el código 308 elimina completamente esta ambigüedad. Si la solicitud original fue POST, la redirigida debe ser POST. Si fue PUT, la redirigida debe ser PUT. Si fue DELETE, la redirigida debe ser DELETE. Esta garantía es crítica para APIs RESTful y aplicaciones donde el método HTTP tiene significado semántico importante. El código 308 fue estandarizado más recientemente que otros códigos de redirección (en RFC 7538 de 2015) para llenar un vacío en la especificación HTTP. Combina dos propiedades importantes: (1) permanencia - como 301, indica que el cambio es definitivo y permanente, los motores de búsqueda deben actualizar índices, los navegadores pueden cachear la redirección, y el valor SEO debe transferirse al nuevo URL; (2) preservación del método - como 307, garantiza que el método HTTP no cambie durante la redirección. Los casos de uso típicos incluyen: reestructuración permanente de APIs donde los métodos deben preservarse, migración permanente de endpoints RESTful, consolidación de servicios manteniendo semántica de métodos HTTP, cambios de infraestructura permanentes donde POST/PUT/DELETE deben mantenerse, y cualquier redirección permanente donde cambiar el método sería semánticamente incorrecto o causaría pérdida de datos.",
        "useCases": [
            "Reestructuración permanente de APIs RESTful preservando métodos HTTP",
            "Migración permanente de endpoints donde POST, PUT, DELETE deben mantenerse",
            "Cambio permanente de dominio para APIs con operaciones de escritura",
            "Consolidación de servicios manteniendo semántica RESTful",
            "Deprecación definitiva de endpoints antiguos hacia nuevos con misma funcionalidad",
            "Migración de infraestructura permanente (on-premise a cloud) preservando métodos",
            "Reorganización de URLs en APIs donde el método HTTP es parte de la semántica",
            "Versioning de APIs con redirección permanente preservando operaciones"
        ],
        "examples": [
            {
                "scenario": "Migración permanente de API endpoint con POST",
                "request": "POST /api/v1/users HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane@example.com\",\n  \"role\": \"admin\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v2/users\nCache-Control: max-age=31536000\nDeprecation: true\nSunset: Mon, 01 Jan 2025 00:00:00 GMT\n\n{\n  \"message\": \"API v1 has been permanently moved to v2\",\n  \"new_endpoint\": \"https://api.example.com/v2/users\",\n  \"documentation\": \"https://docs.example.com/api/v2\",\n  \"note\": \"Please update your integration to use the new endpoint\"\n}",
                "explanation": "La API v1 ha sido permanentemente reemplazada por v2. El código 308 asegura que la solicitud POST con los datos del nuevo usuario se reenvíe al nuevo endpoint manteniendo POST, no convirtiéndose a GET que perdería los datos."
            },
            {
                "scenario": "Cambio permanente de dominio con PUT preservado",
                "request": "PUT /api/products/789 HTTP/1.1\nHost: shop-api.oldcompany.com\nContent-Type: application/json\nAuthorization: Bearer token_abc\n\n{\n  \"name\": \"Updated Product Name\",\n  \"price\": 99.99,\n  \"stock\": 150,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.newcompany.com/api/products/789\nCache-Control: public, max-age=31536000, immutable\nX-Company-Rebrand: true\nLink: <https://www.newcompany.com/api-migration>; rel=\"alternate\"\n\n{\n  \"status\": \"permanent_redirect\",\n  \"message\": \"Our company has rebranded. API permanently moved to new domain.\",\n  \"new_location\": \"https://api.newcompany.com\",\n  \"migration_complete\": true\n}",
                "explanation": "La empresa cambió de marca y dominio permanentemente. El 308 garantiza que la solicitud PUT para actualizar el producto se reenvíe al nuevo dominio manteniendo el método PUT y todos los datos de actualización."
            },
            {
                "scenario": "Reestructuración permanente con DELETE preservado",
                "request": "DELETE /services/old-structure/items/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v3/items/456\nCache-Control: max-age=2592000\nX-API-Restructure: v3-final\n\n{\n  \"message\": \"API structure has been permanently reorganized\",\n  \"old_path\": \"/services/old-structure/items/:id\",\n  \"new_path\": \"/v3/items/:id\",\n  \"operation_preserved\": \"DELETE\",\n  \"note\": \"Your delete operation will complete at the new location\"\n}",
                "explanation": "La estructura de la API fue permanentemente reorganizada. El 308 asegura que la solicitud DELETE se reenvíe a la nueva estructura manteniendo la operación de eliminación, no cambiando a GET."
            },
            {
                "scenario": "Migración cloud permanente con PATCH",
                "request": "PATCH /api/configurations/global HTTP/1.1\nHost: on-premise.example.com\nContent-Type: application/json\n\n{\n  \"maintenance_mode\": false,\n  \"max_connections\": 1000,\n  \"timeout_seconds\": 30\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://cloud-api.example.com/api/configurations/global\nX-Migration-Type: on-premise-to-cloud\nX-Migration-Date: 2024-01-15\nCache-Control: public, max-age=31536000\n\n{\n  \"message\": \"Service permanently migrated to cloud infrastructure\",\n  \"cloud_endpoint\": \"https://cloud-api.example.com\",\n  \"on_premise_shutdown\": \"2024-06-01\",\n  \"benefits\": \"Improved reliability, scalability, and performance\"\n}",
                "explanation": "El servicio fue migrado permanentemente de infraestructura on-premise a cloud. El 308 preserva el método PATCH para que la actualización parcial de configuración se aplique correctamente en el nuevo servidor cloud."
            },
            {
                "scenario": "Consolidación de microservicios con POST",
                "request": "POST /payment-service/api/process HTTP/1.1\nHost: payments.example.com\nContent-Type: application/json\n\n{\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_12345\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://unified-api.example.com/payments/process\nX-Service-Consolidation: microservices-to-unified\nCache-Control: max-age=15552000\n\n{\n  \"message\": \"Payment service consolidated into unified API\",\n  \"new_endpoint\": \"https://unified-api.example.com/payments/process\",\n  \"consolidation_date\": \"2024-01-01\",\n  \"note\": \"All microservices now under unified API gateway\"\n}",
                "explanation": "Múltiples microservicios fueron consolidados en una API unificada permanentemente. El 308 asegura que la solicitud POST de procesamiento de pago con datos sensibles se reenvíe correctamente manteniendo POST."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7538 (2015)",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Deprecation",
            "Sunset",
            "Link"
        ],
        "relatedCodes": [
            301,
            307
        ],
        "technicalNotes": "El código 308 es relativamente nuevo (RFC 7538, 2015) y fue creado para llenar el vacío de un código de redirección permanente que preserve el método HTTP. Es a 301 lo que 307 es a 302. Combina permanencia (como 301) con preservación de método (como 307). Los navegadores modernos lo soportan bien desde ~2015-2016. Al igual que 301, los navegadores y motores de búsqueda deben cachear 308 y actualizar índices. La diferencia crítica con 301 es que 308 GARANTIZA que POST/PUT/DELETE/PATCH se preserven, mientras que 301 históricamente causa que navegadores cambien POST a GET. Para APIs RESTful con redirecciones permanentes, 308 es casi siempre la elección correcta.",
        "images": []
    }
]