[
    {
        "code": 100,
        "status": "Continue",
        "category": "Informational",
        "description": "El código 100 Continue es una respuesta provisional que indica que el cliente debe continuar con su solicitud o ignorar esta respuesta si la solicitud ya ha sido completada. Este código se utiliza principalmente en escenarios donde el cliente necesita enviar un cuerpo de solicitud grande y quiere verificar primero si el servidor está dispuesto a aceptarlo antes de enviar todos los datos. El cliente envía los encabezados de la solicitud con un encabezado 'Expect: 100-continue', y el servidor responde con 100 Continue si está listo para recibir el cuerpo de la solicitud. Esto es especialmente útil para optimizar el ancho de banda y evitar enviar grandes cantidades de datos que podrían ser rechazados por el servidor. Por ejemplo, si un cliente intenta subir un archivo de 500MB, puede primero enviar los encabezados para verificar la autenticación y validación antes de transmitir todo el archivo. Si el servidor responde con 100 Continue, el cliente procede a enviar el cuerpo completo. Si el servidor responde con un código de error (como 401 Unauthorized), el cliente puede abortar la transmisión sin haber desperdiciado ancho de banda enviando el archivo completo.",
        "useCases": [
            "Upload de archivos grandes donde se necesita validación previa",
            "APIs que requieren verificación de autenticación antes de procesar cuerpos de solicitud pesados",
            "Optimización de ancho de banda en conexiones lentas",
            "Sistemas de streaming donde se necesita confirmación del servidor antes de enviar datos"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo grande",
                "request": "POST /upload HTTP/1.1\nHost: example.com\nExpect: 100-continue\nContent-Length: 524288000\nContent-Type: application/octet-stream",
                "response": "HTTP/1.1 100 Continue",
                "explanation": "El servidor acepta recibir el archivo, el cliente procede a enviar los 500MB"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611664/404_2_l0oyj5.png",
                "alt": "Imagen que representa el nombre del código 100 Continue"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618710/1-removebg-preview_tkp4yz.png",
                "alt": "Imagen del código 100 Continue"
            }
        ]
    },
    {
        "code": 101,
        "status": "Switching Protocols",
        "category": "Informational",
        "description": "El código 101 Switching Protocols indica que el servidor está cambiando de protocolo según lo solicitado por el cliente a través del encabezado 'Upgrade'. Este mecanismo permite que una conexión establecida inicialmente con HTTP evolucione a un protocolo diferente, como WebSocket, HTTP/2, o cualquier otro protocolo compatible. El servidor envía este código para confirmar que acepta cambiar al protocolo solicitado en el encabezado Upgrade de la solicitud del cliente. Después de enviar esta respuesta, el servidor abandona el protocolo HTTP/1.1 y comienza a comunicarse usando el nuevo protocolo especificado. Este código es fundamental para la implementación de WebSockets, que permite comunicación bidireccional en tiempo real sobre una única conexión TCP. El proceso típico involucra una solicitud HTTP inicial que solicita el upgrade, el servidor responde con 101, y a partir de ese momento la conexión opera bajo el nuevo protocolo. Esto es especialmente valioso en aplicaciones que requieren comunicación en tiempo real, como chats, juegos multijugador, dashboards en vivo, o aplicaciones colaborativas. Es importante notar que no todos los proxies o intermediarios soportan este mecanismo, por lo que la implementación debe considerar compatibilidad.",
        "useCases": [
            "Establecimiento de conexiones WebSocket para comunicación bidireccional en tiempo real",
            "Upgrade de HTTP/1.1 a HTTP/2 para mejorar el rendimiento",
            "Implementación de Server-Sent Events (SSE) en algunos casos",
            "Protocolos personalizados que necesitan una conexión HTTP inicial"
        ],
        "examples": [
            {
                "scenario": "Upgrade a WebSocket",
                "request": "GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13",
                "response": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
                "explanation": "El servidor acepta el upgrade a WebSocket y la conexión ahora usa el protocolo WebSocket"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.2.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597106/1_ltkyhn.png",
                "alt": "Imagen que representa el nombre del código 101 Switching Protocols"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618707/2-removebg-preview_jjwrov.png",
                "alt": "Imagen del código 101 Switching Protocols"
            }
        ]
    },
    {
        "code": 102,
        "status": "Processing",
        "category": "Informational",
        "description": "El código 102 Processing es una respuesta provisional que indica que el servidor ha recibido y está procesando la solicitud, pero aún no tiene una respuesta disponible. Este código se utiliza principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para prevenir que el cliente agote el tiempo de espera en operaciones que requieren mucho tiempo de procesamiento. Cuando un servidor WebDAV recibe una solicitud que puede tomar tiempo significativo para completarse (como copiar una gran estructura de directorios, realizar operaciones complejas en múltiples recursos, o procesar transformaciones de archivos grandes), envía este código intermedio para mantener la conexión activa y asegurar al cliente que la solicitud no se ha perdido o estancado. El cliente, al recibir este código, puede resetear su temporizador de timeout y continuar esperando. Es particularmente útil en operaciones como PROPFIND sobre grandes colecciones de recursos, operaciones COPY o MOVE masivas, o cualquier operación que involucre procesamiento extensivo en el servidor. A diferencia de 100 Continue que es sobre el envío de datos, 102 Processing es sobre la ejecución de la operación solicitada.",
        "useCases": [
            "Operaciones WebDAV que toman tiempo significativo (PROPFIND, COPY, MOVE)",
            "Procesamiento de grandes estructuras de archivos en sistemas de gestión de contenido",
            "Operaciones batch sobre múltiples recursos",
            "Transformaciones o conversiones de archivos que requieren tiempo de procesamiento extenso"
        ],
        "examples": [
            {
                "scenario": "Copia masiva de directorios en WebDAV",
                "request": "COPY /documents/folder1/ HTTP/1.1\nHost: webdav.example.com\nDestination: /documents/folder2/\nDepth: infinity",
                "response": "HTTP/1.1 102 Processing",
                "explanation": "El servidor informa que está copiando los archivos recursivamente y el cliente debe seguir esperando"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2518 (WebDAV)",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768611761/2_je4oyl.png",
                "alt": "Imagen que representa el nombre del código 102 Processing"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618704/3-removebg-preview_cj1fzy.png",
                "alt": "Imagen del código 102 Processing"
            }
        ]
    },
    {
        "code": 103,
        "status": "Early Hints",
        "category": "Informational",
        "description": "El código 103 Early Hints es una respuesta informativa relativamente nueva que permite al servidor enviar encabezados HTTP preliminares antes de que la respuesta final esté lista. Su propósito principal es mejorar el rendimiento de carga de páginas web al permitir que el navegador comience a pre-cargar recursos críticos mientras el servidor aún está preparando la respuesta completa. Esto es especialmente valioso cuando el servidor necesita tiempo para generar contenido dinámico pero ya sabe qué recursos adicionales (CSS, JavaScript, fuentes, imágenes) serán necesarios. El servidor puede enviar encabezados Link con rel=preload o rel=preconnect, permitiendo que el navegador inicie la descarga de estos recursos en paralelo mientras espera la respuesta HTML principal. Por ejemplo, si un servidor de aplicación necesita consultar una base de datos para generar una página pero ya sabe que necesitará ciertos archivos CSS y JavaScript, puede enviar 103 Early Hints inmediatamente con referencias a esos recursos. Esto reduce significativamente el tiempo de carga percibido y mejora métricas como First Contentful Paint (FCP) y Largest Contentful Paint (LCP). Es particularmente efectivo en sitios con tiempos de procesamiento del servidor variables o consultas de base de datos complejas.",
        "useCases": [
            "Precarga de recursos estáticos (CSS, JS, fuentes) mientras se genera contenido dinámico",
            "Establecimiento anticipado de conexiones a dominios de terceros (CDNs, APIs)",
            "Optimización del rendimiento web y mejora de Core Web Vitals",
            "Reducción del tiempo de carga en aplicaciones con procesamiento del servidor intensivo"
        ],
        "examples": [
            {
                "scenario": "Precarga de recursos críticos",
                "request": "GET /dashboard HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 103 Early Hints\nLink: </styles/critical.css>; rel=preload; as=style\nLink: </scripts/app.js>; rel=preload; as=script\nLink: <https://cdn.example.com>; rel=preconnect\n\n[... el servidor continúa procesando ...]\n\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>...",
                "explanation": "El navegador recibe instrucciones para precargar CSS y JS mientras el servidor genera el HTML del dashboard"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 8297",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768597108/3_av4aj8.png",
                "alt": "Imagen que representa el nombre del código 103 Early Hints  "
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768618702/4-removebg-preview_gkrmuw.png",
                "alt": "Imagen del código 103 Early Hints"
            }
        ]
    },
    {
        "code": 200,
        "status": "OK",
        "category": "Success",
        "description": "El código 200 OK es la respuesta de éxito estándar y más común en HTTP. Indica que la solicitud ha sido procesada exitosamente y el servidor está devolviendo el resultado solicitado. El significado específico de 'éxito' varía según el método HTTP utilizado: para GET significa que el recurso ha sido recuperado y se transmite en el cuerpo del mensaje; para POST indica que el recurso que describe el resultado de la acción se transmite en el cuerpo del mensaje; para PUT o PATCH significa que el recurso ha sido modificado exitosamente; para DELETE indica que el recurso ha sido eliminado. Este código es el caballo de batalla de las APIs REST y aplicaciones web. La respuesta 200 típicamente incluye el cuerpo del mensaje con el contenido solicitado (HTML, JSON, XML, archivos binarios, etc.) junto con encabezados relevantes como Content-Type, Content-Length, Cache-Control, ETag, entre otros. Es importante notar que 200 no siempre es la respuesta más semántica - por ejemplo, una creación exitosa debería usar 201 Created, y una eliminación exitosa sin contenido debería usar 204 No Content. El uso apropiado de códigos de estado hace que las APIs sean más expresivas y fáciles de consumir.",
        "useCases": [
            "Recuperación exitosa de recursos (GET requests)",
            "Respuestas exitosas de búsquedas o consultas",
            "Actualizaciones parciales exitosas (PATCH)",
            "Cualquier operación exitosa que devuelve contenido en el cuerpo",
            "Respuestas de APIs que devuelven datos JSON o XML"
        ],
        "examples": [
            {
                "scenario": "GET request a una API REST",
                "request": "GET /api/users/123 HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 145\nCache-Control: max-age=3600\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}",
                "explanation": "El servidor devuelve exitosamente los datos del usuario solicitado en formato JSON"
            },
            {
                "scenario": "POST request que procesa datos",
                "request": "POST /api/search HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"query\": \"javascript tutorials\"}",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"results\": [\n    {\"title\": \"JS Basics\", \"url\": \"https://example.com/js-basics\"},\n    {\"title\": \"Advanced JS\", \"url\": \"https://example.com/advanced-js\"}\n  ],\n  \"count\": 2\n}",
                "explanation": "La búsqueda se procesó exitosamente y devuelve los resultados"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613634/1_bikeld.png",
                "alt": "Imagen que representa el nombre del código 200 OK"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619787/5-removebg-preview_wc1wto.png",
                "alt": "Imagen del código 200 OK"
            }
        ]
    },
    {
        "code": 201,
        "status": "Created",
        "category": "Success",
        "description": "El código 201 Created indica que la solicitud ha sido exitosa y ha resultado en la creación de uno o más recursos nuevos. Este código es semánticamente más apropiado que 200 OK cuando se crea un nuevo recurso, típicamente en respuesta a solicitudes POST o PUT. La respuesta 201 debe incluir un encabezado Location que contenga la URI del recurso recién creado, permitiendo al cliente acceder directamente al nuevo recurso sin necesidad de búsquedas adicionales. Opcionalmente, el cuerpo de la respuesta puede contener una representación del recurso creado o una descripción del estado de la creación. Este código es fundamental en APIs RESTful bien diseñadas, donde la creación de recursos es una operación común. Por ejemplo, cuando se crea un nuevo usuario, una nueva publicación de blog, un nuevo pedido de compra, o cualquier entidad en el sistema, 201 es la respuesta apropiada. La inclusión del encabezado Location es crucial porque permite a los clientes saber inmediatamente dónde encontrar el recurso recién creado, especialmente útil cuando el servidor genera IDs automáticamente. Algunas implementaciones también incluyen el recurso completo en el cuerpo de la respuesta para evitar que el cliente tenga que hacer una solicitud GET adicional.",
        "useCases": [
            "Creación de nuevos usuarios en un sistema",
            "Publicación de nuevos contenidos (artículos, posts, comentarios)",
            "Creación de pedidos o transacciones",
            "Registro de nuevas entidades en bases de datos mediante APIs",
            "Upload de archivos o recursos que generan nuevas entradas"
        ],
        "examples": [
            {
                "scenario": "Creación de un nuevo usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/users/456\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"name\": \"Jane Smith\",\n  \"email\": \"jane@example.com\",\n  \"created_at\": \"2024-01-16T14:22:00Z\",\n  \"profile_url\": \"/api/users/456\"\n}",
                "explanation": "El usuario fue creado exitosamente, el servidor asignó el ID 456 y devuelve la ubicación del nuevo recurso"
            },
            {
                "scenario": "Creación de un post en blog",
                "request": "POST /api/posts HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token123\n\n{\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"content\": \"HTTP status codes are...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 201 Created\nLocation: /api/posts/789\nContent-Type: application/json\n\n{\n  \"id\": 789,\n  \"title\": \"Introduction to HTTP Status Codes\",\n  \"slug\": \"introduction-to-http-status-codes\",\n  \"author_id\": 123,\n  \"created_at\": \"2024-01-16T14:25:00Z\",\n  \"status\": \"published\"\n}",
                "explanation": "El post fue creado y publicado, incluyendo metadatos generados por el servidor como slug y timestamps"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.2",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613643/2_hapb2d.png",
                "alt": "Imagen que representa el nombre del código 201 Created"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619783/6-removebg-preview_ytp56u.png",
                "alt": "Imagen del codigo 201 Created"
            }
        ]
    },
    {
        "code": 202,
        "status": "Accepted",
        "category": "Success",
        "description": "El código 202 Accepted indica que la solicitud ha sido aceptada para procesamiento, pero el procesamiento aún no se ha completado. Este código es especialmente útil para operaciones asíncronas donde el servidor acepta la solicitud pero la procesará más tarde, en segundo plano. La respuesta 202 es no-comprometida, lo que significa que el servidor acepta la solicitud pero no garantiza que será procesada exitosamente - el procesamiento real podría fallar posteriormente. Este código es ideal para operaciones de larga duración como procesamiento de archivos grandes, conversiones de video, operaciones batch, envío de emails masivos, generación de reportes complejos, o cualquier tarea que no puede completarse inmediatamente dentro del tiempo de respuesta HTTP típico. La respuesta debería incluir información sobre el estado del procesamiento y cómo el cliente puede verificar el progreso, típicamente mediante un encabezado Location que apunta a un recurso de estado o mediante un cuerpo de respuesta que incluye un ID de tarea que puede ser consultado posteriormente. Muchas APIs modernas usan este patrón para operaciones pesadas, proporcionando endpoints separados para verificar el estado de las tareas en progreso.",
        "useCases": [
            "Procesamiento asíncrono de archivos (conversión de video, compresión de imágenes)",
            "Operaciones batch que toman tiempo significativo",
            "Envío de emails masivos o notificaciones",
            "Generación de reportes complejos o exports de datos",
            "Operaciones que requieren aprobación manual posterior",
            "Tareas en cola que serán procesadas por workers en background"
        ],
        "examples": [
            {
                "scenario": "Upload y procesamiento de video",
                "request": "POST /api/videos HTTP/1.1\nHost: media.example.com\nContent-Type: multipart/form-data\n\n[video file data]",
                "response": "HTTP/1.1 202 Accepted\nLocation: /api/jobs/video-process-999\nContent-Type: application/json\n\n{\n  \"job_id\": \"video-process-999\",\n  \"status\": \"queued\",\n  \"message\": \"Video upload accepted. Processing will begin shortly.\",\n  \"status_url\": \"/api/jobs/video-process-999\",\n  \"estimated_completion\": \"2024-01-16T15:30:00Z\"\n}",
                "explanation": "El video fue recibido y está en cola para procesamiento. El cliente puede verificar el estado usando la URL proporcionada"
            },
            {
                "scenario": "Generación de reporte complejo",
                "request": "POST /api/reports/generate HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\n\n{\n  \"type\": \"annual_sales\",\n  \"year\": 2024,\n  \"format\": \"pdf\",\n  \"include_charts\": true\n}",
                "response": "HTTP/1.1 202 Accepted\nContent-Type: application/json\n\n{\n  \"task_id\": \"report-gen-12345\",\n  \"status\": \"processing\",\n  \"progress_url\": \"/api/tasks/report-gen-12345/status\",\n  \"webhook_url\": null,\n  \"message\": \"Report generation started. You will be notified when complete.\"\n}",
                "explanation": "El servidor acepta la solicitud de generación de reporte y la procesa en background"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.3",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613646/3_clmvyi.png",
                "alt": "Imagen que representa el nombre del código 202 Accepted"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619780/7-removebg-preview_mh2ybs.png",
                "alt": "Imagen del código 202 Accepted"
            }
        ]
    },
    {
        "code": 203,
        "status": "Non-Authoritative Information",
        "category": "Success",
        "description": "El código 203 Non-Authoritative Information indica que la solicitud fue exitosa pero la información incluida en la respuesta proviene de una copia local o de terceros, no del servidor origen original. Este código es utilizado principalmente por proxies HTTP o cachés que modifican o transforman la respuesta del servidor origen. Aunque la respuesta es exitosa (similar a 200 OK), el código 203 advierte al cliente que los metadatos (encabezados) pueden haber sido modificados por un intermediario y pueden no ser exactamente los mismos que el servidor origen habría proporcionado. El cuerpo de la entidad puede ser idéntico al de una respuesta 200, pero los encabezados podrían ser diferentes. Este código es poco común en la práctica moderna pero es útil en escenarios donde proxies realizan transformaciones, como conversión de formatos de imagen, compresión adicional, añadir encabezados de seguridad, o modificar metadatos. Por ejemplo, un proxy de optimización podría comprimir imágenes antes de enviarlas al cliente y usar 203 para indicar que aunque el contenido es válido, ha sido procesado. También puede ser usado en escenarios de mirror servers o CDNs que sirven contenido desde múltiples ubicaciones y quieren indicar que la respuesta no viene directamente del servidor origen.",
        "useCases": [
            "Respuestas servidas por proxies que modifican metadatos",
            "CDNs o mirrors que sirven contenido almacenado en caché con encabezados modificados",
            "Proxies de transformación que optimizan contenido (compresión de imágenes, minificación)",
            "Sistemas de caché que añaden encabezados adicionales a las respuestas",
            "Servicios de agregación que combinan datos de múltiples fuentes"
        ],
        "examples": [
            {
                "scenario": "Proxy que modifica encabezados de imagen",
                "request": "GET /images/photo.jpg HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: image/jpeg\nContent-Length: 45000\nX-Proxy-Optimized: true\nX-Original-Size: 120000\nVia: 1.1 proxy.example.com\n\n[compressed image data]",
                "explanation": "Un proxy interceptó la imagen, la comprimió, y modificó los encabezados para reflejar el nuevo tamaño"
            },
            {
                "scenario": "CDN sirviendo contenido con metadatos adicionales",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 203 Non-Authoritative Information\nContent-Type: application/json\nX-Cache: HIT\nX-CDN-Server: edge-server-42\nAge: 3600\n\n{\"data\": \"cached content\"}",
                "explanation": "El CDN sirve contenido en caché y añade encabezados propios que no venían del servidor origen"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.4",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613641/4_jesleh.png",
                "alt": "Imagen que representa el nombre del código 203 Non-Authoritative Information"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619769/8-removebg-preview_cd7hdi.png",
                "alt": "Imagen del código 203 Non-Authoritative Information"
            }
        ]
    },
    {
        "code": 204,
        "status": "No Content",
        "category": "Success",
        "description": "El código 204 No Content indica que el servidor ha procesado exitosamente la solicitud pero no devuelve ningún contenido en el cuerpo de la respuesta. Este código es semánticamente diferente de 200 OK en que explícitamente comunica que no hay contenido para devolver, lo cual es la intención, no un error. La respuesta 204 no debe contener un cuerpo de mensaje - el mensaje termina después de los encabezados. Este código es extremadamente útil en APIs REST para operaciones que modifican el estado del servidor pero no necesitan devolver datos al cliente, como eliminaciones exitosas, actualizaciones donde el cliente ya tiene todos los datos necesarios, o acciones que simplemente cambian el estado sin generar nueva información. Es también común en solicitudes PUT o PATCH donde el cliente envía la representación completa del recurso y no necesita que el servidor la devuelva. El código 204 ahorra ancho de banda al no enviar cuerpos de respuesta innecesarios y hace que las APIs sean más eficientes. En aplicaciones web, una respuesta 204 típicamente no causa que el navegador actualice la página actual, lo cual es útil para operaciones AJAX que modifican datos en el servidor sin necesitar recargar la interfaz.",
        "useCases": [
            "Eliminación exitosa de recursos (DELETE requests)",
            "Actualizaciones que no requieren devolver el recurso modificado",
            "Operaciones de guardado automático donde no se necesita confirmación con datos",
            "Acciones que cambian estado del servidor sin generar nueva información",
            "Heartbeats o keep-alive requests",
            "Operaciones batch donde solo importa el éxito, no los detalles"
        ],
        "examples": [
            {
                "scenario": "Eliminación de un recurso",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token123",
                "response": "HTTP/1.1 204 No Content\nDate: Tue, 16 Jan 2024 15:00:00 GMT",
                "explanation": "El usuario fue eliminado exitosamente, no hay contenido adicional que devolver"
            },
            {
                "scenario": "Actualización de preferencias de usuario",
                "request": "PUT /api/users/123/preferences HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"theme\": \"dark\",\n  \"language\": \"es\",\n  \"notifications\": true\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "Las preferencias fueron actualizadas exitosamente, el cliente ya tiene los datos que envió"
            },
            {
                "scenario": "Guardado automático de documento",
                "request": "PATCH /api/documents/456/autosave HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\n\n{\n  \"content\": \"Updated document content...\",\n  \"last_modified\": \"2024-01-16T15:05:00Z\"\n}",
                "response": "HTTP/1.1 204 No Content",
                "explanation": "El documento fue guardado automáticamente sin necesidad de respuesta con contenido"
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.3.5",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613653/5_efixbc.png",
                "alt": "Imagen que representa el nombre del código 204 No Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619773/9-removebg-preview_wavvrt.png",
                "alt": "Imagen del código 204 No Content"
            }
        ]
    },
    {
        "code": 205,
        "status": "Reset Content",
        "category": "Success",
        "description": "El código 205 Reset Content indica que el servidor ha procesado exitosamente la solicitud y está instruyendo al agente de usuario (típicamente un navegador) a resetear la vista del documento que causó la solicitud a su estado original. A diferencia de 204 No Content, que simplemente no devuelve contenido, 205 específicamente solicita que el cliente reinicie la interfaz de usuario. Este código es particularmente útil en aplicaciones de formularios web donde, después de enviar datos exitosamente, se desea limpiar el formulario para permitir al usuario ingresar nuevos datos sin necesidad de recargar la página completa. Por ejemplo, en un formulario de entrada de datos repetitiva (como ingreso de inventario, registro de múltiples transacciones, o captura de datos en serie), después de cada envío exitoso, el servidor puede responder con 205 para resetear el formulario automáticamente. Al igual que 204, la respuesta 205 no debe contener un cuerpo de mensaje. La diferencia clave es la semántica: 204 dice 'éxito, sin más información', mientras que 205 dice 'éxito, y por favor resetea tu interfaz'. En la práctica moderna, este código es poco utilizado ya que muchas aplicaciones manejan el reseteo de formularios directamente en el cliente con JavaScript, pero sigue siendo válido y útil para aplicaciones tradicionales basadas en formularios HTML.",
        "useCases": [
            "Formularios de entrada de datos repetitiva donde se quiere limpiar campos después del envío",
            "Aplicaciones de encuestas o cuestionarios que permiten múltiples respuestas",
            "Sistemas de captura de datos en serie (inventario, transacciones, registros)",
            "Formularios de búsqueda donde se quiere limpiar los criterios después de ejecutar la búsqueda",
            "Interfaces de administración con formularios que se usan repetidamente"
        ],
        "examples": [
            {
                "scenario": "Formulario de entrada de inventario",
                "request": "POST /inventory/add HTTP/1.1\nHost: warehouse.example.com\nContent-Type: application/x-www-form-urlencoded\n\nproduct_id=ABC123&quantity=50&location=warehouse-a",
                "response": "HTTP/1.1 205 Reset Content\nDate: Tue, 16 Jan 2024 15:10:00 GMT",
                "explanation": "El item fue agregado al inventario y el navegador debe limpiar el formulario para la siguiente entrada"
            },
            {
                "scenario": "Formulario de comentarios/feedback",
                "request": "POST /feedback/submit HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n  \"rating\": 5,\n  \"comment\": \"Excellent service!\",\n  \"category\": \"support\"\n}",
                "response": "HTTP/1.1 205 Reset Content",
                "explanation": "El feedback fue registrado y el formulario debe resetearse para permitir otro envío"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.3.6",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613651/6_blwgmz.png",
                "alt": "Imagen que representa el nombre del código 205 Reset Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619776/10-removebg-preview_lt16pz.png",
                "alt": "Imagen del código 205 Reset Content"
            }
        ]
    },
    {
        "code": 206,
        "status": "Partial Content",
        "category": "Success",
        "description": "El código 206 Partial Content indica que el servidor está entregando solo una parte del recurso solicitado debido a un encabezado Range enviado por el cliente. Este código es fundamental para la descarga de archivos grandes, streaming de video/audio, y para permitir la reanudación de descargas interrumpidas. Cuando un cliente solicita un rango específico de bytes de un recurso (por ejemplo, bytes 0-1023 de un archivo de 100MB), el servidor responde con 206 y solo los bytes solicitados. La respuesta debe incluir encabezados Content-Range que especifican qué porción del recurso se está enviando y el tamaño total del recurso, y Content-Length que indica el tamaño de la porción actual. Este mecanismo es esencial para aplicaciones de streaming donde el cliente puede solicitar chunks específicos de un video o audio, para administradores de descargas que dividen archivos grandes en múltiples segmentos para descargar en paralelo, y para reanudar descargas interrumpidas solicitando solo la porción faltante. Los navegadores modernos y reproductores de video utilizan extensivamente este código para permitir la búsqueda dentro de videos (cuando mueves la barra de progreso), para cargar solo las porciones visibles de archivos PDF grandes, o para implementar lazy loading eficiente de recursos multimedia.",
        "useCases": [
            "Streaming de video y audio (permitiendo seek/skip)",
            "Descarga resumible de archivos grandes",
            "Descarga paralela de archivos en múltiples segmentos",
            "Visualización de porciones específicas de documentos grandes (PDFs)",
            "Optimización de ancho de banda cargando solo lo necesario",
            "Implementación de lazy loading para contenido multimedia"
        ],
        "examples": [
            {
                "scenario": "Solicitud de rango de bytes de un video",
                "request": "GET /videos/movie.mp4 HTTP/1.1\nHost: cdn.example.com\nRange: bytes=1000000-2999999",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: video/mp4\nContent-Length: 2000000\nContent-Range: bytes 1000000-2999999/500000000\nAccept-Ranges: bytes\n\n[2MB de datos de video]",
                "explanation": "El servidor envía 2MB específicos del video (del byte 1M al byte 3M) de un total de 500MB"
            },
            {
                "scenario": "Reanudación de descarga interrumpida",
                "request": "GET /downloads/software.zip HTTP/1.1\nHost: downloads.example.com\nRange: bytes=50000000-",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: application/zip\nContent-Length: 50000000\nContent-Range: bytes 50000000-99999999/100000000\nAccept-Ranges: bytes\n\n[50MB restantes del archivo]",
                "explanation": "La descarga se reanuda desde el byte 50M hasta el final del archivo de 100MB"
            },
            {
                "scenario": "Descarga paralela con múltiples rangos",
                "request": "GET /files/large-dataset.dat HTTP/1.1\nHost: data.example.com\nRange: bytes=0-10485759,10485760-20971519",
                "response": "HTTP/1.1 206 Partial Content\nContent-Type: multipart/byteranges; boundary=BOUNDARY_STRING\nContent-Length: 20971520\n\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 0-10485759/1073741824\n\n[primeros 10MB]\n--BOUNDARY_STRING\nContent-Type: application/octet-stream\nContent-Range: bytes 10485760-20971519/1073741824\n\n[siguientes 10MB]\n--BOUNDARY_STRING--",
                "explanation": "El cliente solicita dos rangos simultáneos para descarga paralela"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613659/7_ts5rgr.png",
                "alt": "Imagen que representa el nombre del código 206 Partial Content"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619763/11-removebg-preview_krzu2a.png",
                "alt": "Imagen del código 206 Partial Content"
            }
        ]
    },
    {
        "code": 207,
        "status": "Multi-Status",
        "category": "Success",
        "description": "El código 207 Multi-Status es utilizado principalmente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para transmitir información sobre múltiples recursos cuando la operación sobre varios recursos puede tener resultados variados. A diferencia de otros códigos de estado que aplican a toda la respuesta, 207 indica que el cuerpo del mensaje contiene un documento XML con múltiples códigos de estado de respuesta, uno para cada recurso o sub-operación involucrada. Esto es esencial cuando se realizan operaciones sobre colecciones de recursos donde algunos pueden tener éxito y otros fallar. Por ejemplo, al intentar eliminar una carpeta con 10 archivos, 5 podrían eliminarse exitosamente (200), 3 podrían estar bloqueados (423), y 2 podrían no existir (404). El código 207 permite comunicar todos estos estados diferentes en una sola respuesta estructurada. El cuerpo de la respuesta típicamente contiene XML con elementos <response> para cada recurso, cada uno con su propio <status> y potencialmente <propstat> para propiedades. Esto hace que las operaciones batch sean más eficientes y permite al cliente manejar éxitos y fallos parciales de manera granular sin necesidad de múltiples requests individuales.",
        "useCases": [
            "Operaciones WebDAV sobre múltiples archivos o carpetas (PROPFIND, COPY, MOVE, DELETE)",
            "Operaciones batch en APIs que procesan múltiples recursos",
            "Sincronización de colecciones de recursos donde algunos pueden fallar",
            "Consultas de propiedades sobre múltiples recursos simultáneamente",
            "Operaciones de backup o restauración de múltiples archivos"
        ],
        "examples": [
            {
                "scenario": "PROPFIND sobre una colección de archivos",
                "request": "PROPFIND /documents/ HTTP/1.1\nHost: webdav.example.com\nDepth: 1\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <getcontentlength/>\n    <getlastmodified/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 1234\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/documents/file1.pdf</href>\n    <propstat>\n      <prop>\n        <getcontentlength>4500</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 12:00:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/file2.docx</href>\n    <propstat>\n      <prop>\n        <getcontentlength>15000</getcontentlength>\n        <getlastmodified>Tue, 16 Jan 2024 09:30:00 GMT</getlastmodified>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/documents/protected.txt</href>\n    <propstat>\n      <status>HTTP/1.1 403 Forbidden</status>\n    </propstat>\n  </response>\n</multistatus>",
                "explanation": "El servidor devuelve propiedades de múltiples archivos, algunos exitosos (200) y uno con acceso denegado (403)"
            },
            {
                "scenario": "Operación COPY batch sobre múltiples recursos",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup-folder/\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/source-folder/document1.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/document2.txt</href>\n    <status>HTTP/1.1 201 Created</status>\n  </response>\n  <response>\n    <href>/source-folder/locked-file.dat</href>\n    <status>HTTP/1.1 423 Locked</status>\n  </response>\n</multistatus>",
                "explanation": "Algunos archivos se copiaron exitosamente mientras uno estaba bloqueado"
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.1",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613656/8_gh0rl4.png",
                "alt": "Imagen que representa el nombre del código 207 Multi-Status"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619766/12-removebg-preview_xsybjn.png",
                "alt": "Imagen del código 207 Multi-Status"
            }
        ]
    },
    {
        "code": 208,
        "status": "Already Reported",
        "category": "Success",
        "description": "El código 208 Already Reported es utilizado exclusivamente en el contexto de WebDAV (Web Distributed Authoring and Versioning) para evitar la enumeración repetida de recursos internos en respuestas Multi-Status. Este código representa una optimización crítica cuando se trabaja con bindings WebDAV, que son esencialmente referencias o enlaces a recursos que pueden aparecer en múltiples ubicaciones dentro de una jerarquía de carpetas. Cuando un cliente realiza una operación PROPFIND con profundidad infinita sobre una colección que contiene múltiples bindings (enlaces, referencias, o aliases) apuntando al mismo recurso subyacente, sin el código 208 la respuesta incluiría información completa del mismo recurso múltiples veces, una por cada binding. Esto no solo infla innecesariamente el tamaño de la respuesta XML sino que también consume recursos de procesamiento tanto en el servidor como en el cliente. El código 208 permite al servidor reportar el recurso completo la primera vez que lo encuentra durante el traversal de la jerarquía, y luego usar 208 Already Reported para las referencias subsecuentes al mismo recurso. Esto es análogo a cómo los lenguajes de programación manejan referencias circulares en estructuras de datos - la primera vez que encuentras un objeto lo procesas completamente, las siguientes veces solo indicas 'ya vimos esto'. En sistemas de archivos modernos con soporte para hard links, enlaces simbólicos, o sistemas distribuidos donde el mismo archivo puede ser accesible desde múltiples rutas virtuales, este código es esencial para mantener las respuestas manejables. La implementación correcta de 208 requiere que el servidor mantenga un registro de qué recursos ya ha incluido en la respuesta actual para evitar duplicación. Es importante notar que este código solo tiene sentido en el contexto de una respuesta 207 Multi-Status y específicamente en operaciones WebDAV que pueden atravesar colecciones con múltiples referencias.",
        "useCases": [
            "Operaciones PROPFIND recursivas sobre colecciones con bindings WebDAV duplicados",
            "Prevención de duplicación en listados de recursos en sistemas con hard links",
            "Optimización de respuestas en traversal de jerarquías con enlaces simbólicos",
            "Reducción del tamaño de respuestas XML en operaciones sobre estructuras complejas de carpetas",
            "Sistemas de archivos distribuidos donde el mismo recurso tiene múltiples rutas de acceso",
            "Implementaciones de versionado donde múltiples versiones pueden compartir contenido subyacente"
        ],
        "examples": [
            {
                "scenario": "PROPFIND recursivo con bindings duplicados",
                "request": "PROPFIND /workspace/projects/ HTTP/1.1\nHost: webdav.example.com\nDepth: infinity\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<propfind xmlns=\"DAV:\">\n  <prop>\n    <displayname/>\n    <getcontentlength/>\n    <getcontenttype/>\n    <resourcetype/>\n  </prop>\n</propfind>",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/workspace/projects/shared-library/utils.js</href>\n    <propstat>\n      <prop>\n        <displayname>utils.js</displayname>\n        <getcontentlength>45000</getcontentlength>\n        <getcontenttype>application/javascript</getcontenttype>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/workspace/projects/project-a/lib/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-b/dependencies/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/workspace/projects/project-c/shared/utils.js</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El archivo utils.js es compartido por múltiples proyectos mediante bindings. Se reporta completamente solo la primera vez, las subsecuentes referencias usan 208 para evitar duplicación innecesaria de datos."
            },
            {
                "scenario": "Traversal de sistema con hard links",
                "request": "PROPFIND /storage/backups/ HTTP/1.1\nHost: dav.example.com\nDepth: infinity",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml\n\n<?xml version=\"1.0\"?>\n<multistatus xmlns=\"DAV:\">\n  <response>\n    <href>/storage/backups/2024-01/database.dump</href>\n    <propstat>\n      <prop>\n        <displayname>database.dump</displayname>\n        <getcontentlength>524288000</getcontentlength>\n        <getlastmodified>Mon, 15 Jan 2024 02:00:00 GMT</getlastmodified>\n        <resourcetype/>\n      </prop>\n      <status>HTTP/1.1 200 OK</status>\n    </propstat>\n  </response>\n  <response>\n    <href>/storage/backups/2024-02/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n  <response>\n    <href>/storage/backups/latest/database.dump</href>\n    <status>HTTP/1.1 208 Already Reported</status>\n  </response>\n</multistatus>",
                "explanation": "El mismo archivo de backup está vinculado en múltiples directorios mediante hard links para deduplicación. Solo se reporta una vez con sus propiedades completas."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 5842, Section 7.1",
        "relatedCodes": [
            207
        ],
        "technicalNotes": "Este código solo es válido dentro del contexto de una respuesta 207 Multi-Status. El servidor debe implementar lógica para rastrear qué recursos ya han sido reportados durante el traversal de la jerarquía actual. No debe usarse fuera del contexto WebDAV.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613636/9_vly4qs.png",
                "alt": "Imagen que representa el nombre del código 208 Already Reported"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619797/13-removebg-preview_snc3fy.png",
                "alt": "Imagen del código 208 Already Reported"
            }
        ]
    },
    {
        "code": 214,
        "status": "Transformation Applied",
        "category": "Success (Warning Code)",
        "description": "El código 214 Transformation Applied es un código de advertencia HTTP que se transmite a través del encabezado Warning, no como código de estado HTTP principal. Los códigos de advertencia proporcionan información adicional sobre el estado de la respuesta que puede no ser evidente solo con el código de estado. El 214 específicamente informa al cliente que un intermediario (proxy, gateway, CDN) ha aplicado alguna transformación al contenido del mensaje antes de entregarlo. Estas transformaciones pueden ser dramáticas o sutiles: desde conversión de formatos de imagen (JPEG a WebP), transcodificación de video para diferentes dispositivos, compresión agresiva, minificación de código, aplicación de filtros de contenido, hasta modificación de resoluciones o tasas de bits. A diferencia del código de estado 203 Non-Authoritative Information que indica modificación de metadatos (encabezados), el código 214 se enfoca específicamente en transformaciones del cuerpo del mensaje. El formato del encabezado Warning es: 'Warning: 214 agent \"Transformation Applied\" \"descripción detallada\"' donde 'agent' identifica el intermediario que aplicó la transformación y la descripción explica qué se modificó. Esto es crucial para transparencia, debugging, y cumplimiento de políticas de contenido. Por ejemplo, un desarrollador depurando por qué una imagen se ve diferente en producción vs desarrollo puede ver el warning 214 y entender que un CDN está optimizando las imágenes. O un sistema de validación de contenido puede verificar que las transformaciones aplicadas cumplen con políticas corporativas. Los proxies modernos de optimización web, CDNs con procesamiento inteligente de assets, y gateways de adaptación de contenido para diferentes tipos de red (3G, 4G, 5G, WiFi) utilizan extensivamente este mecanismo. Es especialmente importante en contextos móviles donde los operadores de red pueden aplicar optimizaciones agresivas para reducir consumo de datos.",
        "useCases": [
            "Proxies de optimización que comprimen imágenes para reducir ancho de banda en redes lentas",
            "CDNs que convierten formatos de imagen a WebP o AVIF para navegadores compatibles",
            "Transcodificación automática de video según capacidades del dispositivo cliente",
            "Minificación y bundling de archivos JavaScript/CSS por intermediarios",
            "Aplicación de filtros de contenido corporativos o gubernamentales",
            "Adaptación de resolución de imágenes según tipo de conexión (WiFi vs móvil)",
            "Compresión adicional aplicada por operadores móviles en redes congestionadas",
            "Conversión de documentos a formatos más ligeros (por ejemplo, reducir calidad de PDFs)"
        ],
        "examples": [
            {
                "scenario": "CDN optimizando imagen para móvil",
                "request": "GET /assets/hero-image.jpg HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0...)\nAccept: image/webp,image/jpeg,*/*",
                "response": "HTTP/1.1 200 OK\nContent-Type: image/webp\nContent-Length: 28000\nWarning: 214 cdn.example.com \"Transformation Applied\" \"Original JPEG (150KB) converted to WebP format and compressed to 28KB for mobile optimization\"\nVary: Accept, User-Agent\nX-Original-Format: image/jpeg\nX-Original-Size: 153600\nVia: 1.1 cdn.example.com\n\n[WebP image data]",
                "explanation": "El CDN detectó un iPhone con soporte para WebP, convirtió la imagen original JPEG, aplicó compresión agresiva, y notificó la transformación mediante Warning 214."
            },
            {
                "scenario": "Proxy de operador móvil comprimiendo contenido",
                "request": "GET /download/whitepaper.pdf HTTP/1.1\nHost: docs.example.com\nVia: 1.1 mobile-proxy.carrier.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/pdf\nContent-Length: 450000\nWarning: 214 mobile-proxy.carrier.com \"Transformation Applied\" \"PDF images recompressed to reduce file size from 2.5MB to 450KB for data saving on mobile network\"\nX-Data-Saver-Applied: true\nX-Original-Size: 2621440\n\n[compressed PDF data]",
                "explanation": "El proxy del operador móvil aplicó compresión agresiva al PDF para ahorrar datos del plan del usuario."
            },
            {
                "scenario": "Transcodificación de video adaptativa",
                "request": "GET /videos/tutorial.mp4 HTTP/1.1\nHost: media.example.com\nUser-Agent: Mozilla/5.0 (Linux; Android 12...)",
                "response": "HTTP/1.1 200 OK\nContent-Type: video/mp4\nContent-Length: 15000000\nWarning: 214 video-gateway.example.com \"Transformation Applied\" \"Video transcoded from 1080p H.265 to 480p H.264 for Android device with limited bandwidth\"\nX-Original-Resolution: 1920x1080\nX-Original-Codec: hevc\nX-Transcoded-Resolution: 854x480\nX-Transcoded-Codec: h264\n\n[transcoded video data]",
                "explanation": "El gateway de video detectó un dispositivo Android en una conexión lenta y transcodificó el video a menor resolución y codec más compatible."
            },
            {
                "scenario": "Minificación de JavaScript por proxy corporativo",
                "request": "GET /js/app.js HTTP/1.1\nHost: cdn.example.com\nVia: 1.1 corporate-proxy.company.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/javascript\nContent-Length: 85000\nWarning: 214 corporate-proxy.company.com \"Transformation Applied\" \"JavaScript minified and comments removed, reduced from 245KB to 85KB\"\nX-Original-Size: 250880\nX-Minified: true\n\n[minified JavaScript code]",
                "explanation": "Un proxy corporativo minificó automáticamente el JavaScript para optimizar el ancho de banda de la red empresarial."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7234, Section 5.5",
        "headerFormat": "Warning: 214 agent \"Transformation Applied\" \"detailed description\"",
        "relatedHeaders": [
            "Via",
            "X-Original-Size",
            "X-Transformed-By",
            "Vary"
        ],
        "technicalNotes": "Este es un código de advertencia (Warning code), no un código de estado HTTP. Se transmite mediante el encabezado Warning. Múltiples advertencias pueden estar presentes en una sola respuesta. Los códigos de advertencia en el rango 2xx indican que no hubo error pero hay información adicional importante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613638/10_rezx3u.png",
                "alt": "Imagen que representa el nombre del código 214 Transformation Applied"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619790/14-removebg-preview_ypwtjm.png",
                "alt": "Imagen del código 214 Transformation Applied"
            }
        ]
    },
    {
        "code": 226,
        "status": "IM Used",
        "category": "Success",
        "description": "El código 226 IM Used (Instance Manipulation Used) indica que el servidor ha cumplido exitosamente con una solicitud GET para un recurso, pero en lugar de devolver la representación completa del recurso, está devolviendo el resultado de aplicar una o más manipulaciones de instancia (Instance Manipulations o IM) a la instancia actual del recurso. Este código es parte del framework de delta encoding especificado en RFC 3229, un mecanismo sofisticado diseñado para optimizar dramáticamente el uso de ancho de banda cuando los clientes solicitan recursos que han cambiado solo parcialmente desde una versión anterior que ya poseen. El concepto fundamental es simple pero poderoso: si tienes la versión 1 de un documento de 10MB y el servidor tiene la versión 2, en lugar de descargar los 10MB completos nuevamente, el servidor puede enviar solo un 'delta' (diferencia) de quizás 500KB que describe los cambios. El cliente entonces aplica este delta a su versión local para reconstruir la versión 2. El encabezado A-IM (Accept Instance Manipulation) en la solicitud especifica qué tipos de deltas o manipulaciones el cliente puede procesar (por ejemplo: vcdiff, gdiff, diffe, gzip). El servidor responde con 226 y el encabezado IM indica qué manipulación fue aplicada, mientras que Delta-Base identifica la versión base usada para calcular el delta. Este mecanismo es especialmente valioso para documentos grandes que evolucionan incrementalmente: bases de datos, archivos de configuración extensos, imágenes satelitales con actualizaciones periódicas, datasets científicos, o código fuente versionado. Aunque técnicamente poderoso, 226 es raramente implementado en la web moderna porque requiere soporte sofisticado tanto del cliente como del servidor, incluyendo algoritmos de diff/patch, gestión de versiones, y lógica de fallback. Muchos desarrolladores prefieren soluciones más simples como versionado de recursos con ETags para cacheo, o dividir recursos grandes en chunks más pequeños.",
        "useCases": [
            "Sincronización eficiente de archivos grandes con cambios incrementales (bases de datos, logs)",
            "Actualización de datasets científicos o geoespaciales que cambian parcialmente",
            "Distribución de actualizaciones de software mediante deltas en lugar de instaladores completos",
            "APIs que sirven documentos versionados donde el cliente probablemente tiene versiones anteriores",
            "Sistemas de colaboración en documentos grandes con control de versiones",
            "Optimización de ancho de banda en enlaces satelitales o conexiones lentas costosas",
            "Sincronización de repositorios de código fuente sobre HTTP (similar a Git pero vía HTTP puro)"
        ],
        "examples": [
            {
                "scenario": "Delta encoding con formato vcdiff",
                "request": "GET /datasets/weather-data.csv HTTP/1.1\nHost: data.example.com\nA-IM: vcdiff, diffe\nIf-None-Match: \"v2024-01-15-abc123\"\nAccept-Encoding: gzip",
                "response": "HTTP/1.1 226 IM Used\nETag: \"v2024-01-16-def456\"\nIM: vcdiff\nDelta-Base: \"v2024-01-15-abc123\"\nContent-Type: application/x-vcdiff\nContent-Encoding: gzip\nContent-Length: 125000\nCache-Control: private, must-revalidate\n\n[gzipped vcdiff delta data]",
                "explanation": "El cliente tiene los datos meteorológicos del 15 de enero. El servidor envía solo los cambios del 16 de enero usando formato vcdiff comprimido con gzip, reduciendo la transferencia de 50MB completos a solo 125KB de delta."
            },
            {
                "scenario": "Actualización incremental de documento JSON grande",
                "request": "GET /api/products-catalog.json HTTP/1.1\nHost: api.example.com\nA-IM: json-patch, json-merge-patch\nIf-None-Match: \"catalog-v105\"",
                "response": "HTTP/1.1 226 IM Used\nETag: \"catalog-v106\"\nIM: json-patch\nDelta-Base: \"catalog-v105\"\nContent-Type: application/json-patch+json\nContent-Length: 3500\n\n[\n  {\"op\": \"replace\", \"path\": \"/products/42/price\", \"value\": 29.99},\n  {\"op\": \"replace\", \"path\": \"/products/42/stock\", \"value\": 150},\n  {\"op\": \"add\", \"path\": \"/products/999\", \"value\": {\n    \"id\": 999,\n    \"name\": \"New Product\",\n    \"price\": 49.99,\n    \"stock\": 50\n  }},\n  {\"op\": \"remove\", \"path\": \"/products/123\"}\n]",
                "explanation": "En lugar de enviar todo el catálogo de productos (5MB), el servidor envía un JSON Patch (3.5KB) con solo los cambios: actualizaciones de precio/stock de un producto, adición de un producto nuevo, y eliminación de un producto descontinuado."
            },
            {
                "scenario": "Sincronización de base de datos SQLite",
                "request": "GET /db/application.db HTTP/1.1\nHost: sync.example.com\nA-IM: gdiff\nIf-None-Match: \"db-snapshot-20240115-120000\"\nRange: bytes=0-",
                "response": "HTTP/1.1 226 IM Used\nETag: \"db-snapshot-20240116-140000\"\nIM: gdiff\nDelta-Base: \"db-snapshot-20240115-120000\"\nContent-Type: application/x-gdiff\nContent-Length: 450000\n\n[gdiff binary delta data]",
                "explanation": "El cliente sincroniza una base de datos SQLite de 250MB. Solo han cambiado algunas tablas (nuevas filas, actualizaciones). El servidor calcula un delta binario de 450KB usando gdiff, evitando transferir los 250MB completos."
            },
            {
                "scenario": "Fallback cuando delta no es posible",
                "request": "GET /documents/report.pdf HTTP/1.1\nHost: docs.example.com\nA-IM: vcdiff\nIf-None-Match: \"report-v1\"",
                "response": "HTTP/1.1 200 OK\nETag: \"report-v5\"\nContent-Type: application/pdf\nContent-Length: 2500000\nVary: A-IM, If-None-Match\n\n[complete PDF file]",
                "explanation": "El cliente tiene la versión 1 pero la versión actual es 5. Los cambios son tan extensos que el delta sería casi tan grande como el archivo completo, o el servidor no tiene la versión intermedia. Se envía el archivo completo con código 200 en lugar de 226."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 3229, Section 10.4.1",
        "relatedHeaders": [
            "A-IM (Accept-Instance-Manipulation)",
            "IM (Instance-Manipulation)",
            "Delta-Base",
            "If-None-Match",
            "ETag"
        ],
        "deltaFormats": {
            "vcdiff": "Binary delta encoding format (RFC 3284), muy eficiente para archivos binarios",
            "gdiff": "Generic diff format, usado para diferencias binarias",
            "diffe": "Ed-style diff, basado en comandos de edición",
            "json-patch": "RFC 6902, para documentos JSON estructurados",
            "json-merge-patch": "RFC 7396, merge patches para JSON"
        },
        "technicalNotes": "El servidor debe almacenar versiones anteriores o calcular deltas on-the-fly. La implementación requiere algoritmos sofisticados de diff/patch. Si calcular el delta es más costoso que enviar el recurso completo, el servidor debe usar 200 OK. Los clientes deben implementar lógica de fallback para cuando 200 se recibe en lugar de 226.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768613648/11_ozqx4y.png",
                "alt": "Imagen que representa el nombre del código 226 IM Used"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768619794/15-removebg-preview_yxl4gy.png",
                "alt": "Imagen del código 226 IM Used"
            }
        ]
    },
    {
        "code": 300,
        "status": "Multiple Choices",
        "category": "Redirection",
        "description": "El código 300 Multiple Choices indica que el recurso solicitado corresponde a múltiples representaciones diferentes, cada una con su propia ubicación específica, y se está proporcionando información para que el agente de usuario (o el usuario final) pueda seleccionar una representación preferida y redirigir su solicitud a esa ubicación. Este código representa una situación de negociación de contenido donde el servidor no puede o no quiere tomar automáticamente la decisión sobre cuál variante servir. Es fundamentalmente diferente de otros códigos de redirección porque no impone una única redirección, sino que ofrece opciones. La respuesta debe incluir una lista de las alternativas disponibles junto con sus ubicaciones y características distintivas, permitiendo que el cliente (o usuario) haga una elección informada. Por ejemplo, un documento podría estar disponible en múltiples formatos (PDF, HTML, DOCX), idiomas (inglés, español, francés), o versiones (para principiantes, intermedio, avanzado). El servidor podría responder con 300 y proporcionar enlaces a todas estas variantes. El cuerpo de la respuesta típicamente contiene un documento HTML con enlaces a las diferentes opciones, o puede usar el encabezado Location para sugerir una opción preferida mientras lista otras alternativas en el cuerpo. En la práctica moderna, 300 es raramente utilizado porque los servidores generalmente implementan negociación de contenido automática basada en encabezados Accept, Accept-Language, Accept-Encoding del cliente, eligiendo la mejor representación y devolviéndola directamente con código 200 OK, o usando redirecciones 302/303 para dirigir automáticamente a una variante específica. Sin embargo, 300 sigue siendo útil en escenarios donde la elección tiene implicaciones significativas que no pueden ser determinadas automáticamente, como diferentes niveles de detalle de documentación, versiones con diferentes licencias, o formatos que requieren diferentes aplicaciones.",
        "useCases": [
            "Documentos disponibles en múltiples formatos que requieren elección explícita del usuario",
            "Contenido multilingüe donde el servidor no puede determinar automáticamente el idioma preferido",
            "Diferentes versiones de un recurso (simplificada, completa, técnica) donde la elección depende del contexto",
            "Recursos con múltiples licencias donde el usuario debe seleccionar términos específicos",
            "APIs que ofrecen múltiples endpoints para la misma funcionalidad con diferentes características",
            "Contenido disponible en diferentes niveles de calidad o resolución",
            "Archivos disponibles desde múltiples servidores mirror donde el usuario debe elegir el más cercano"
        ],
        "examples": [
            {
                "scenario": "Documento en múltiples formatos",
                "request": "GET /documentation/user-guide HTTP/1.1\nHost: docs.example.com\nAccept: */*",
                "response": "HTTP/1.1 300 Multiple Choices\nLocation: /documentation/user-guide.html\nContent-Type: text/html; charset=utf-8\nVary: Accept\n\n<!DOCTYPE html>\n<html>\n<head><title>Multiple Formats Available</title></head>\n<body>\n  <h1>User Guide - Multiple Formats</h1>\n  <p>This documentation is available in several formats:</p>\n  <ul>\n    <li><a href=\"/documentation/user-guide.html\">HTML Version</a></li>\n    <li><a href=\"/documentation/user-guide.pdf\">PDF Version</a></li>\n    <li><a href=\"/documentation/user-guide.epub\">EPUB Version</a></li>\n    <li><a href=\"/documentation/user-guide.docx\">DOCX Version</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El servidor ofrece el mismo contenido en cuatro formatos diferentes. El encabezado Location sugiere HTML como opción predeterminada, pero el usuario puede elegir cualquier formato según sus necesidades."
            },
            {
                "scenario": "Contenido multilingüe sin preferencia clara",
                "request": "GET /welcome HTTP/1.1\nHost: www.example.com\nAccept-Language: *",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: text/html; charset=utf-8\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head><title>Language Selection</title></head>\n<body>\n  <h1>Please select your language</h1>\n  <ul>\n    <li><a href=\"/welcome?lang=en\" hreflang=\"en\">English</a></li>\n    <li><a href=\"/welcome?lang=es\" hreflang=\"es\">Español</a></li>\n    <li><a href=\"/welcome?lang=fr\" hreflang=\"fr\">Français</a></li>\n    <li><a href=\"/welcome?lang=de\" hreflang=\"de\">Deutsch</a></li>\n  </ul>\n</body>\n</html>",
                "explanation": "El cliente no especificó una preferencia clara de idioma, por lo que el servidor presenta todas las opciones de idioma disponibles para que el usuario elija."
            },
            {
                "scenario": "API con múltiples versiones",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 300 Multiple Choices\nContent-Type: application/json\nLocation: /api/v3/data\n\n{\n  \"message\": \"Multiple API versions available\",\n  \"versions\": [\n    {\n      \"version\": \"v1\",\n      \"url\": \"/api/v1/data\",\n      \"status\": \"deprecated\"\n    },\n    {\n      \"version\": \"v2\",\n      \"url\": \"/api/v2/data\",\n      \"status\": \"stable\"\n    },\n    {\n      \"version\": \"v3\",\n      \"url\": \"/api/v3/data\",\n      \"status\": \"recommended\"\n    }\n  ]\n}",
                "explanation": "El endpoint base de la API devuelve información sobre todas las versiones disponibles, permitiendo que el cliente elija según sus necesidades de estabilidad versus características nuevas."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.1",
        "relatedHeaders": [
            "Location",
            "Vary",
            "Content-Type",
            "Link"
        ],
        "technicalNotes": "Aunque especificado en HTTP/1.0, es raramente usado en la práctica moderna. La mayoría de los servidores implementan content negotiation automática usando encabezados Accept-* y devuelven 200 OK con la mejor representación, o usan 302/303 para redirigir automáticamente.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/300_gepcv9.png",
                "alt": "Imagen que representa el nombre del código 300 Multiple Choices"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/16-removebg-preview_pobkgs.png",
                "alt": "Imagen del código 300 Multiple Choices"
            }
        ]
    },
    {
        "code": 301,
        "status": "Moved Permanently",
        "category": "Redirection",
        "description": "El código 301 Moved Permanently indica que el recurso solicitado ha sido movido permanentemente a una nueva ubicación URI, y todas las referencias futuras a este recurso deben usar una de las URIs devueltas. Este es uno de los códigos de redirección más importantes y ampliamente utilizados en HTTP, fundamental para SEO, mantenimiento de sitios web, y reorganización de estructuras de URLs. La palabra clave aquí es 'permanentemente' - este código comunica tanto a navegadores como a motores de búsqueda que el cambio es definitivo y no temporal. Los motores de búsqueda como Google, cuando encuentran un 301, transferirán el 'link juice' (valor SEO) del URL antiguo al nuevo, actualizarán sus índices, y eventualmente dejarán de rastrear el URL antiguo. Los navegadores típicamente almacenan en caché redirecciones 301, lo que significa que en visitas futuras pueden ir directamente al nuevo URL sin siquiera consultar el servidor sobre el URL antiguo. La respuesta debe incluir un encabezado Location con la nueva URI del recurso. Es crucial usar 301 correctamente: solo debe usarse cuando estás absolutamente seguro de que el movimiento es permanente. Si hay alguna posibilidad de que el recurso regrese al URL original en el futuro, usa 302 o 307 en su lugar. Las aplicaciones comunes incluyen: migración de HTTP a HTTPS, cambio de nombres de dominio, reestructuración de sitios web, consolidación de contenido duplicado, normalización de URLs (con/sin www, con/sin trailing slash), y redirección de páginas antiguas a nuevas versiones. Un uso inadecuado de 301 puede causar problemas graves: si rediriges permanentemente y luego intentas restaurar el URL original, los navegadores con caché pueden seguir redirigiendo automáticamente incluso después de que hayas eliminado la redirección del servidor.",
        "useCases": [
            "Migración permanente de HTTP a HTTPS para todo un sitio web",
            "Cambio de nombre de dominio (example.com a newbrand.com)",
            "Reestructuración de URLs (/old-page.html a /new-structure/page)",
            "Consolidación de contenido duplicado hacia una URL canónica",
            "Normalización de URLs (www.example.com a example.com o viceversa)",
            "Redirección de trailing slash (/page a /page/ o viceversa)",
            "Movimiento permanente de recursos a CDN o subdominios",
            "Redirección de páginas de productos discontinuados a categorías o alternativas",
            "Migración de plataformas (WordPress a Jamstack, cambio de CMS)",
            "Internacionalización (example.com/page a example.com/en/page)"
        ],
        "examples": [
            {
                "scenario": "Migración HTTP a HTTPS",
                "request": "GET /secure-page HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/secure-page\nContent-Type: text/html; charset=UTF-8\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"https://example.com/secure-page\">here</a>.</p>\n</body>\n</html>",
                "explanation": "El sitio ha migrado permanentemente a HTTPS. Todas las solicitudes HTTP son redirigidas a sus equivalentes HTTPS. Los motores de búsqueda actualizarán sus índices para usar HTTPS."
            },
            {
                "scenario": "Cambio de nombre de dominio",
                "request": "GET /products/widget-x HTTP/1.1\nHost: oldcompany.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://newcompany.com/products/widget-x\nCache-Control: max-age=31536000, immutable",
                "explanation": "La empresa cambió de nombre y dominio. Redirección permanente con caché de 1 año para maximizar eficiencia. Los motores de búsqueda transferirán el valor SEO al nuevo dominio."
            },
            {
                "scenario": "Reestructuración de URLs SEO-friendly",
                "request": "GET /page.php?id=123&category=electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://shop.example.com/electronics/products/smartphone-pro-123\nVary: Accept-Language\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Moved</title>\n  <link rel=\"canonical\" href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">\n</head>\n<body>\n  <h1>This page has moved permanently</h1>\n  <p>New URL: <a href=\"https://shop.example.com/electronics/products/smartphone-pro-123\">Smartphone Pro</a></p>\n</body>\n</html>",
                "explanation": "URLs antiguas con parámetros query son redirigidas permanentemente a URLs amigables para SEO. Incluye canonical tag para reforzar la URL correcta."
            },
            {
                "scenario": "Normalización www vs non-www",
                "request": "GET / HTTP/1.1\nHost: www.example.com",
                "response": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/\nStrict-Transport-Security: max-age=31536000; includeSubDomains",
                "explanation": "Normalización permanente hacia versión sin www. Incluye HSTS para forzar HTTPS en futuras visitas y mejorar la seguridad."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.2",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Vary",
            "Link",
            "Deprecation",
            "Sunset"
        ],
        "technicalNotes": "En HTTP/1.0, la especificación permitía que navegadores cambiaran el método de POST a GET al seguir un 301. HTTP/1.1 clarificó que el método debe preservarse, pero muchos navegadores aún cambian POST a GET por compatibilidad histórica. Para comportamiento predecible con POST requests, usa 308 en su lugar. Los navegadores cachean 301 agresivamente incluso sin Cache-Control explícito.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/301_wdshbj.png",
                "alt": "Imagen que representa el nombre del código 301 Moved Permanently"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/17-removebg-preview_uthv3h.png",
                "alt": "Imagen del código 301 Moved Permanently"
            }
        ]
    },
    {
        "code": 302,
        "status": "Found",
        "category": "Redirection",
        "description": "El código 302 Found (originalmente 'Moved Temporarily' en HTTP/1.0) indica que el recurso solicitado reside temporalmente bajo una URI diferente. A diferencia de 301 que señala un cambio permanente, 302 comunica que el recurso puede volver a su ubicación original en el futuro, o que su ubicación temporal puede cambiar. Esta distinción es crucial tanto para navegadores como para motores de búsqueda. Los navegadores generalmente NO cachean redirecciones 302 de forma agresiva, lo que significa que seguirán consultando el URL original en futuras visitas. Los motores de búsqueda mantienen el URL original en sus índices y continúan rastreándolo, no transfieren el 'link juice' al URL de destino. El encabezado Location especifica la URI temporal donde el recurso puede encontrarse actualmente. El código 302 es históricamente ambiguo en cuanto al manejo del método HTTP: aunque la especificación HTTP/1.1 dice que el método de solicitud no debe cambiar al seguir la redirección, en la práctica la mayoría de los navegadores cambian POST a GET cuando siguen un 302. Esta inconsistencia llevó a la creación de códigos más específicos: 303 See Other (explícitamente cambia a GET) y 307 Temporary Redirect (explícitamente preserva el método). Sin embargo, 302 sigue siendo extremadamente común en la web moderna y es el código de redirección temporal por defecto en muchos frameworks y servidores web. Los casos de uso típicos incluyen: redirecciones post-login, redirecciones después de operaciones POST (pattern Post-Redirect-Get), mantenimiento temporal de sitios, A/B testing, distribución de carga entre servidores, redirecciones basadas en geolocalización, y páginas temporales de campaña de marketing.",
        "useCases": [
            "Redirección post-login a dashboard o página de perfil",
            "Patrón Post-Redirect-Get (PRG) para prevenir reenvíos de formularios",
            "Mantenimiento temporal del sitio (redirigir a página de mantenimiento)",
            "A/B testing y experimentos de usuario",
            "Redirecciones basadas en geolocalización o detección de idioma",
            "Páginas temporales de campaña de marketing o eventos",
            "Distribución temporal de carga entre servidores espejo",
            "Redirecciones condicionales basadas en cookies, sesión, o headers",
            "URLs cortas temporales para campañas (bit.ly, tinyurl)",
            "Redirección durante migraciones graduales (canary deployments)"
        ],
        "examples": [
            {
                "scenario": "Redirección post-login",
                "request": "POST /login HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=john&password=secret123",
                "response": "HTTP/1.1 302 Found\nLocation: https://example.com/dashboard\nSet-Cookie: session_id=abc123xyz; HttpOnly; Secure; SameSite=Lax\nCache-Control: no-store, no-cache, must-revalidate",
                "explanation": "Después de autenticación exitosa, el usuario es redirigido temporalmente a su dashboard. Se establece una cookie de sesión y se previene el cacheo de la redirección."
            },
            {
                "scenario": "Patrón Post-Redirect-Get (PRG)",
                "request": "POST /orders/create HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"product_id\": 456,\n  \"quantity\": 2\n}",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/orders/confirmation/789\nX-Order-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"order_id\": 789\n}",
                "explanation": "Después de crear la orden (POST), el servidor redirige a una página de confirmación (GET). Esto previene que el usuario reenvíe la orden accidentalmente al refrescar la página."
            },
            {
                "scenario": "Página de mantenimiento temporal",
                "request": "GET /products/electronics HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 302 Found\nLocation: https://shop.example.com/maintenance\nRetry-After: 3600\nCache-Control: no-cache, no-store\n\n<!DOCTYPE html>\n<html>\n<head><title>Temporary Maintenance</title></head>\n<body>\n  <h1>Scheduled Maintenance</h1>\n  <p>We're performing system upgrades. Please check back in 1 hour.</p>\n</body>\n</html>",
                "explanation": "Durante mantenimiento, las páginas redirigen temporalmente a una página de mantenimiento. Retry-After sugiere cuándo reintentar. La redirección es temporal porque las páginas normales volverán después del mantenimiento."
            },
            {
                "scenario": "Redirección basada en geolocalización",
                "request": "GET / HTTP/1.1\nHost: www.globalshop.com\nAccept-Language: es-MX\nX-Forwarded-For: 189.203.10.5",
                "response": "HTTP/1.1 302 Found\nLocation: https://www.globalshop.com/mx/\nVary: Accept-Language, X-Forwarded-For\nSet-Cookie: geo_region=mx; Path=/; Max-Age=86400\nCache-Control: private, no-cache",
                "explanation": "El servidor detecta que el usuario está en México y redirige temporalmente a la versión mexicana del sitio. La redirección es temporal porque el usuario podría estar viajando o usando VPN."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.4.3",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "Set-Cookie"
        ],
        "technicalNotes": "302 es históricamente ambiguo: la especificación dice preservar el método, pero la mayoría de los navegadores cambian POST a GET. Para comportamiento explícito: usa 303 (fuerza GET) o 307 (preserva método). Las redirecciones 302 generalmente NO se cachean agresivamente. Los motores de búsqueda mantienen el URL original en índices y no transfieren SEO value.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701320/302_pr9ato.png",
                "alt": "Imagen que representa el nombre del código 302 Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/18-removebg-preview_qckrk0.png",
                "alt": "Imagen del código 302 Found"
            }
        ]
    },
    {
        "code": 303,
        "status": "See Other",
        "category": "Redirection",
        "description": "El código 303 See Other indica que el servidor está redirigiendo al cliente a un recurso diferente, identificado por el URI en el encabezado Location, y que la respuesta a la solicitud original puede ser encontrada allí usando una solicitud GET. La característica distintiva y crucial de 303 es que SIEMPRE requiere que el cliente use el método GET para la solicitud redirigida, sin importar qué método HTTP se usó en la solicitud original. Esto lo hace perfectamente adecuado para el patrón Post-Redirect-Get (PRG), una de las mejores prácticas más importantes en desarrollo web. El código 303 fue introducido en HTTP/1.1 específicamente para eliminar la ambigüedad del código 302, que teóricamente debería preservar el método pero en la práctica los navegadores lo cambian a GET. Con 303, este comportamiento está explícitamente codificado en la especificación: si un servidor responde con 303 a una solicitud POST, el navegador DEBE hacer una solicitud GET al URL en el encabezado Location. Esto resuelve el problema clásico de 'duplicación de envíos de formularios' donde un usuario envía un formulario (POST), ve la página de confirmación, y luego al refrescar el navegador, se le pregunta si quiere reenviar el formulario. Con 303, el flujo es: (1) usuario envía formulario con POST, (2) servidor procesa y responde 303 con Location a página de confirmación, (3) navegador hace GET a esa página de confirmación, (4) usuario ve confirmación y puede refrescar sin problemas porque ahora es un GET simple. El código 303 es semánticamente diferente de 302 y 307: mientras que 302 es ambiguo y 307 preserva explícitamente el método, 303 explícitamente cambia a GET. Es la elección correcta para cualquier situación donde procesas una operación de modificación de estado (POST, PUT, DELETE) y quieres redirigir al usuario a una representación del resultado.",
        "useCases": [
            "Implementación del patrón Post-Redirect-Get (PRG) después de envíos de formularios",
            "Redirección después de operaciones POST, PUT, DELETE en APIs REST",
            "Confirmaciones de operaciones que modifican estado (creación, actualización, eliminación)",
            "Redirección después de procesamiento de pagos o transacciones",
            "Redirigir desde endpoint de acción a vista de recurso",
            "Prevenir reenvíos accidentales de formularios al refrescar navegador",
            "Redirección de operaciones asíncronas completadas a página de resultados",
            "Upload de archivos seguido de redirección a página de vista previa"
        ],
        "examples": [
            {
                "scenario": "Patrón Post-Redirect-Get clásico",
                "request": "POST /contact HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&email=john%40example.com&message=Hello",
                "response": "HTTP/1.1 303 See Other\nLocation: https://example.com/contact/thank-you\nCache-Control: no-cache, no-store, must-revalidate\nX-Message-ID: msg_123456\n\n<!DOCTYPE html>\n<html>\n<head><title>Message Sent</title></head>\n<body>\n  <p>Your message has been sent successfully.</p>\n  <p>Redirecting to confirmation page...</p>\n</body>\n</html>",
                "explanation": "Después de procesar el formulario de contacto (POST), el servidor redirige con 303 a una página de agradecimiento. El navegador hará GET a /contact/thank-you. Si el usuario refresca, solo re-hace el GET, no reenvía el formulario."
            },
            {
                "scenario": "Creación de recurso en API REST",
                "request": "POST /api/articles HTTP/1.1\nHost: blog.example.com\nContent-Type: application/json\nAuthorization: Bearer token_abc123\n\n{\n  \"title\": \"Understanding HTTP 303\",\n  \"content\": \"The 303 status code is...\",\n  \"tags\": [\"http\", \"web\", \"tutorial\"]\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://blog.example.com/api/articles/789\nX-Article-ID: 789\nCache-Control: no-cache\n\n{\n  \"status\": \"created\",\n  \"message\": \"Article published successfully\",\n  \"article_id\": 789,\n  \"view_url\": \"/api/articles/789\"\n}",
                "explanation": "El artículo fue creado exitosamente. En lugar de devolver 201 Created, el servidor usa 303 para indicar que el cliente debe hacer GET a /api/articles/789 para ver el recurso completo. Esto separa claramente la operación de creación (POST) de la recuperación (GET)."
            },
            {
                "scenario": "Procesamiento de pago con redirección",
                "request": "POST /checkout/process-payment HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_visa_1234\",\n  \"cart_id\": \"cart_xyz789\"\n}",
                "response": "HTTP/1.1 303 See Other\nLocation: https://shop.example.com/orders/confirmation/ord_456\nX-Order-ID: ord_456\nX-Transaction-ID: txn_789xyz\nSet-Cookie: cart_id=; Max-Age=0; Path=/\nCache-Control: no-store, no-cache\n\n{\n  \"status\": \"payment_successful\",\n  \"order_id\": \"ord_456\",\n  \"confirmation_url\": \"/orders/confirmation/ord_456\"\n}",
                "explanation": "Después de procesar el pago exitosamente, el servidor redirige con 303 a la página de confirmación de orden. Esto previene que el usuario accidentalmente procese el pago dos veces si refresca la página."
            },
            {
                "scenario": "Eliminación de recurso con redirección a lista",
                "request": "DELETE /api/users/123 HTTP/1.1\nHost: admin.example.com\nAuthorization: Bearer admin_token_xyz\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 303 See Other\nLocation: https://admin.example.com/api/users\nX-Deleted-User-ID: 123\nCache-Control: no-cache\n\n{\n  \"status\": \"deleted\",\n  \"message\": \"User account deleted successfully\",\n  \"deleted_user_id\": 123,\n  \"redirect_to\": \"/api/users\"\n}",
                "explanation": "Después de eliminar el usuario (DELETE), el servidor redirige con 303 a la lista de usuarios. El cliente hará GET a /api/users para ver la lista actualizada sin el usuario eliminado."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.4",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "X-Request-ID",
            "X-Resource-ID"
        ],
        "technicalNotes": "303 fue introducido en HTTP/1.1 para resolver la ambigüedad de 302. El método SIEMPRE cambia a GET - esto no es un bug, es la característica principal. Los navegadores SIEMPRE cambian el método a GET cuando siguen una redirección 303, sin importar el método original (POST, PUT, DELETE). Si necesitas preservar el método, usa 307 en su lugar.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701317/303_b4nnly.png",
                "alt": "Imagen que representa el nombre del código 303 See Other"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685324/19-removebg-preview_akkhp7.png",
                "alt": "Imagen del código 303 See Other"
            }
        ]
    },
    {
        "code": 304,
        "status": "Not Modified",
        "category": "Redirection",
        "description": "El código 304 Not Modified es un código de estado especial que indica que el recurso no ha sido modificado desde la versión especificada por los encabezados de solicitud condicional del cliente (If-Modified-Since, If-None-Match), y por lo tanto el cliente puede usar su copia en caché. Este código es fundamental para la optimización del rendimiento web y el ahorro de ancho de banda. A diferencia de otros códigos de redirección, 304 no redirige a una ubicación diferente, sino que instruye al cliente a usar la copia que ya tiene almacenada localmente. El flujo típico funciona así: (1) cliente hace una solicitud inicial GET y recibe 200 OK con el recurso completo más encabezados ETag y/o Last-Modified, (2) cliente almacena el recurso en caché junto con estos validadores, (3) en solicitudes subsecuentes, cliente incluye If-None-Match (con el ETag) y/o If-Modified-Since (con la fecha), (4) servidor verifica si el recurso cambió comparando con los validadores, (5) si NO cambió, servidor responde 304 sin cuerpo de mensaje - solo headers, (6) cliente usa su versión cacheada. Esto ahorra ancho de banda significativo porque solo se transmiten headers (aproximadamente 200-500 bytes) en lugar del recurso completo (que podría ser megabytes). La respuesta 304 NUNCA debe contener un cuerpo de mensaje - el mensaje termina inmediatamente después de los encabezados. Debe incluir headers que habrían sido enviados con 200 OK si el recurso hubiera sido modificado, específicamente: Date, ETag, Cache-Control, Expires, Vary. El código 304 es esencial para: carga eficiente de sitios web con muchos assets estáticos, APIs que sirven datos que cambian infrecuentemente, distribución de contenido mediante CDNs, reducción de carga en servidores de origen, mejora de velocidad percibida por usuarios, y optimización de consumo de datos en dispositivos móviles.",
        "useCases": [
            "Validación de caché para assets estáticos (imágenes, CSS, JavaScript)",
            "APIs que sirven datos que cambian infrecuentemente",
            "Verificación de actualizaciones de recursos sin transferir todo el contenido",
            "Optimización de rendimiento en sitios web con muchos recursos",
            "Reducción de ancho de banda en aplicaciones móviles",
            "Implementación de polling eficiente para verificar cambios",
            "CDN edge caching y validación con servidores origen",
            "Sincronización eficiente de recursos entre cliente y servidor"
        ],
        "examples": [
            {
                "scenario": "Validación con ETag - recurso no modificado",
                "request": "GET /assets/logo.png HTTP/1.1\nHost: cdn.example.com\nIf-None-Match: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: max-age=0",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:00:00 GMT\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\nCache-Control: public, max-age=31536000, immutable\nVary: Accept-Encoding\nX-Cache: HIT",
                "explanation": "El cliente tiene logo.png con ETag específico. El servidor verifica que el archivo no ha cambiado (mismo ETag) y responde 304. El navegador usa su copia cacheada. No se transmite la imagen, ahorrando ancho de banda significativo."
            },
            {
                "scenario": "Validación con Last-Modified - recurso no modificado",
                "request": "GET /api/products.json HTTP/1.1\nHost: api.example.com\nIf-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:05:00 GMT\nLast-Modified: Mon, 15 Jan 2024 10:00:00 GMT\nCache-Control: private, must-revalidate, max-age=3600\nVary: Accept",
                "explanation": "El cliente pregunta si products.json cambió desde el 15 de enero. No ha cambiado, entonces el servidor responde 304. Cliente usa su copia cacheada, ahorrando potencialmente varios MB de datos JSON."
            },
            {
                "scenario": "Validación con ETag - recurso SÍ modificado",
                "request": "GET /news/latest-article HTTP/1.1\nHost: blog.example.com\nIf-None-Match: \"old-etag-abc123\"\nAccept: text/html",
                "response": "HTTP/1.1 200 OK\nDate: Tue, 16 Jan 2024 19:10:00 GMT\nETag: \"new-etag-xyz789\"\nLast-Modified: Tue, 16 Jan 2024 18:00:00 GMT\nContent-Type: text/html; charset=utf-8\nCache-Control: public, max-age=600\n\n<!DOCTYPE html>\n<html>\n<head><title>Breaking News Updated!</title></head>\n<body>\n  <article>\n    <h1>Major Update to Story</h1>\n    <p>New information has emerged...</p>\n  </article>\n</body>\n</html>",
                "explanation": "El artículo fue actualizado (ETag diferente), entonces el servidor responde 200 OK con el contenido completo actualizado y nuevo ETag. El cliente reemplaza su caché con la nueva versión."
            },
            {
                "scenario": "API polling eficiente",
                "request": "GET /api/notifications HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_xyz\nIf-None-Match: W/\"notifications-hash-abc\"\nX-Polling-Interval: 30",
                "response": "HTTP/1.1 304 Not Modified\nDate: Tue, 16 Jan 2024 19:20:00 GMT\nETag: W/\"notifications-hash-abc\"\nCache-Control: private, no-cache, must-revalidate\nX-Poll-Interval: 30",
                "explanation": "Cliente hace polling cada 30 segundos para notificaciones. No hay nuevas notificaciones, entonces 304. Esto es muchísimo más eficiente que transferir la lista completa de notificaciones en cada poll."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7232, Section 4.1",
        "relatedHeaders": [
            "If-Modified-Since",
            "If-None-Match",
            "ETag",
            "Last-Modified",
            "Date",
            "Cache-Control",
            "Expires",
            "Vary"
        ],
        "technicalNotes": "La respuesta 304 NUNCA debe incluir un cuerpo de mensaje. DEBE incluir Date header. DEBE incluir ETag y/o Last-Modified si estaban en la respuesta 200 original. DEBE incluir Cache-Control y Expires si aplican. NO debe incluir Content-Length porque no hay cuerpo. Los navegadores automáticamente incluyen If-None-Match/If-Modified-Since cuando revalidan recursos cacheados.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701318/304_ot5mbk.png",
                "alt": "Imagen que representa el nombre del código 304 Not Modified"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/20-removebg-preview_mnc4wo.png",
                "alt": "Imagen del código 304 Not Modified"
            }
        ]
    },
    {
        "code": 305,
        "status": "Use Proxy",
        "category": "Redirection",
        "description": "El código 305 Use Proxy indica que el recurso solicitado debe ser accedido a través de un proxy especificado en el encabezado Location. Este código fue definido en versiones anteriores de la especificación HTTP pero ha sido DEPRECADO en HTTP/1.1 debido a serias preocupaciones de seguridad. El código 305 fue diseñado originalmente para permitir que los servidores indiquen a los clientes que deben acceder a un recurso específico a través de un proxy particular. Sin embargo, esta funcionalidad presentaba riesgos significativos de seguridad ya que permitía que servidores potencialmente maliciosos obligaran a los clientes a enrutar su tráfico a través de proxies no confiables, lo que podría resultar en ataques man-in-the-middle, interceptación de datos sensibles, modificación de contenido, o redirección a sitios maliciosos. Debido a estos riesgos, la mayoría de los navegadores modernos y clientes HTTP ignoran completamente el código 305 y nunca lo implementaron correctamente. El código fue formalmente deprecado y las implementaciones modernas NO deben usarlo ni responder a él. En lugar de 305, las configuraciones de proxy deben ser manejadas a nivel de sistema operativo, configuración de red, o mediante configuración explícita del usuario en la aplicación cliente (como las configuraciones de proxy en navegadores). La especificación HTTP/1.1 revisada recomienda explícitamente NO usar este código bajo ninguna circunstancia. Si un servidor necesita comunicar información sobre proxies, debe hacerlo a través de otros mecanismos más seguros como encabezados informativos personalizados, documentación fuera de banda, o configuración manual del cliente. El código 305 representa un ejemplo importante en la evolución de HTTP de cómo consideraciones de seguridad pueden llevar a la deprecación de características que parecían útiles pero resultaron ser vectores de ataque potenciales.",
        "useCases": [
            "NINGUNO - Este código está DEPRECADO y NO debe ser usado",
            "Históricamente fue diseñado para indicar uso de proxy, pero fue abandonado por riesgos de seguridad",
            "No tiene casos de uso válidos en implementaciones modernas"
        ],
        "examples": [
            {
                "scenario": "Ejemplo histórico (NO usar en producción)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 305 Use Proxy\nLocation: http://proxy.example.com:8080\n\n[Este código está DEPRECADO y no debe ser usado]",
                "explanation": "Este es solo un ejemplo histórico de cómo se habría usado 305. En la práctica moderna, este código NUNCA debe ser usado debido a graves riesgos de seguridad. Los navegadores modernos lo ignoran completamente."
            },
            {
                "scenario": "Respuesta moderna correcta (usar configuración de proxy apropiada)",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nX-Proxy-Info: For proxy configuration, see https://example.com/proxy-setup\n\n{\n  \"message\": \"Resource accessed successfully\",\n  \"proxy_documentation\": \"https://example.com/proxy-setup\"\n}",
                "explanation": "En lugar de usar 305 deprecado, proporciona información sobre configuración de proxy a través de documentación o headers informativos. La configuración de proxy debe manejarse a nivel de cliente, no mediante respuestas HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1 (DEPRECADO)",
        "specification": "RFC 7231, Section 6.4.5 (marcado como deprecado)",
        "relatedHeaders": [
            "Location"
        ],
        "technicalNotes": "Este código está OFICIALMENTE DEPRECADO desde HTTP/1.1. Fue removido de la especificación debido a serias preocupaciones de seguridad. Los navegadores modernos NO lo implementan y lo ignoran. Representaba un vector de ataque para man-in-the-middle. NUNCA debe ser usado en implementaciones nuevas. Las configuraciones de proxy deben manejarse a nivel de sistema operativo, configuración de red del usuario, o PAC (Proxy Auto-Config) files, NO mediante respuestas HTTP.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/305_paioqd.png",
                "alt": "Imagen que representa el nombre del código 305 Use Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/21-removebg-preview_vr87er.png",
                "alt": "Imagen del código 305 Use Proxy"
            }
        ]
    },
    {
        "code": 306,
        "status": "Switch Proxy",
        "category": "Redirection",
        "description": "El código 306 Switch Proxy es un código de estado que ya no se utiliza en las especificaciones HTTP modernas y está completamente OBSOLETO. Este código fue definido en una versión preliminar de la especificación HTTP/1.1 pero nunca llegó a ser parte del estándar oficial final. Originalmente, el código 306 estaba destinado a indicar que las solicitudes subsecuentes deben usar el proxy especificado, similar en concepto al deprecado 305 Use Proxy, pero con la intención de que fuera utilizado en solicitudes futuras en lugar de la solicitud actual. Sin embargo, debido a las mismas preocupaciones graves de seguridad que llevaron a la deprecación del código 305, el código 306 fue eliminado completamente de la especificación antes de su finalización. El código 306 nunca fue ampliamente implementado por navegadores o servidores web, y hoy en día no tiene ningún significado definido en HTTP. Si un servidor envía un código 306, los clientes modernos no sabrán cómo manejarlo correctamente. En la especificación oficial RFC 7231 de HTTP/1.1, el código 306 simplemente está marcado como '(Unused)' - no utilizado. El espacio del código 306 fue reservado pero nunca se le asignó un significado oficial, y permanece sin uso en todas las versiones modernas de HTTP. Esto representa un caso interesante en el desarrollo de estándares donde un código fue propuesto, asignado un número, pero luego abandonado antes de la ratificación final del estándar. A diferencia del 305 que fue oficialmente deprecado después de ser parte del estándar, el 306 simplemente nunca llegó a existir oficialmente. En implementaciones modernas, este código no debe ser usado bajo ninguna circunstancia y si se encuentra en respuestas, debe ser tratado como un error desconocido o no válido.",
        "useCases": [
            "NINGUNO - Este código está completamente OBSOLETO y nunca fue parte del estándar oficial",
            "No tiene significado definido en HTTP moderno",
            "Fue abandonado antes de la finalización de HTTP/1.1",
            "No debe ser usado en ninguna implementación"
        ],
        "examples": [
            {
                "scenario": "Código obsoleto sin uso oficial",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "HTTP/1.1 306 (Unused)\n\n[Este código NO tiene significado oficial y NO debe ser usado]",
                "explanation": "El código 306 nunca fue oficialmente definido en el estándar HTTP final. Si un servidor responde con 306, los clientes modernos no sabrán cómo manejarlo. Este código simplemente no debe ser usado."
            },
            {
                "scenario": "Manejo correcto en cliente moderno",
                "request": "GET /resource HTTP/1.1\nHost: example.com",
                "response": "Si un cliente recibe 306:\n- Debe tratarlo como un código de estado desconocido\n- Puede registrar un error o advertencia\n- No debe intentar interpretarlo como una redirección válida\n- Debería fallar la solicitud o usar comportamiento de fallback",
                "explanation": "Los clientes modernos correctamente implementados no tienen lógica especial para manejar 306 porque nunca fue parte del estándar. Si se encuentra, indica un problema de configuración del servidor."
            }
        ],
        "httpVersion": "HTTP/1.1 (NUNCA OFICIALIZADO)",
        "specification": "RFC 7231 - marcado como '(Unused)' / Sin uso oficial",
        "relatedHeaders": [],
        "technicalNotes": "El código 306 fue propuesto en borradores tempranos de HTTP/1.1 pero fue eliminado antes de la especificación final. En RFC 7231, aparece listado como '306 (Unused)' indicando que el número está reservado pero sin significado asignado. A diferencia del 305 que fue deprecado después de uso, el 306 simplemente nunca existió oficialmente. NO debe ser implementado ni usado en sistemas modernos. Su presencia en listados de códigos HTTP es puramente histórica.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701322/306_egqdxk.png",
                "alt": "Imagen que representa el nombre del código 306 Switch Proxy"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/22-removebg-preview_q8lfzw.png",
                "alt": "Imagen del código 306 Switch Proxy"
            }
        ]
    },
    {
        "code": 307,
        "status": "Temporary Redirect",
        "category": "Redirection",
        "description": "El código 307 Temporary Redirect indica que el recurso solicitado reside temporalmente bajo una URI diferente, y el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. Esta es la diferencia crítica y el propósito principal del código 307: garantizar que el método HTTP se preserve durante la redirección. Mientras que el código 302 Found es históricamente ambiguo (la especificación dice preservar el método, pero los navegadores cambian POST a GET en la práctica), el código 307 elimina toda ambigüedad al requerir explícitamente que el método se mantenga idéntico. Si la solicitud original fue POST, la solicitud redirigida también debe ser POST. Si fue DELETE, la redirigida también debe ser DELETE. Esto es esencial en escenarios donde el método HTTP tiene significado semántico importante y cambiarlo podría causar comportamiento incorrecto o inseguro. Por ejemplo, si un cliente envía una solicitud POST con datos importantes a un servidor que responde con redirección, es crucial que esos datos sean enviados al nuevo destino también con POST, no convertidos a GET (que podría perder los datos del cuerpo o exponerlos en la URL). El código 307 fue introducido en HTTP/1.1 específicamente para proporcionar una versión sin ambigüedades del 302 que preserve el método. Al igual que 302, el 307 indica que la redirección es temporal, no permanente, por lo que los motores de búsqueda deben mantener el URL original en sus índices y los navegadores no deben cachear la redirección de forma agresiva. Los casos de uso comunes incluyen: mantenimiento temporal donde se necesita redirigir solicitudes POST, balanceo de carga que preserva el método de la solicitud, redirecciones de API donde el método es crítico para la semántica de la operación, y cualquier escenario de redirección temporal donde cambiar el método HTTP sería semánticamente incorrecto o podría causar pérdida de datos.",
        "useCases": [
            "Redirecciones temporales donde preservar el método HTTP es crítico",
            "Mantenimiento temporal de APIs que manejan POST, PUT, DELETE",
            "Balanceo de carga entre servidores manteniendo el método original",
            "Redirecciones de APIs RESTful donde el método define la operación",
            "Migración gradual de endpoints preservando semántica del método",
            "Redirección temporal de uploads (POST con archivos)",
            "Failover entre servidores sin cambiar la naturaleza de la solicitud",
            "Testing A/B de APIs donde el método debe mantenerse consistente"
        ],
        "examples": [
            {
                "scenario": "Redirección POST preservando el método",
                "request": "POST /api/orders HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 156\n\n{\n  \"product_id\": 789,\n  \"quantity\": 3,\n  \"customer_id\": 456,\n  \"shipping_address\": \"123 Main St\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-backup.example.com/api/orders\nRetry-After: 120\nCache-Control: no-cache, no-store\nX-Redirect-Reason: primary_server_maintenance\n\n{\n  \"message\": \"Primary server under maintenance\",\n  \"redirect_to\": \"https://api-backup.example.com/api/orders\",\n  \"note\": \"Your request will be resubmitted automatically\"\n}",
                "explanation": "El servidor principal está en mantenimiento temporal. La redirección 307 asegura que el navegador/cliente reenvíe la solicitud POST completa con todos los datos del pedido al servidor de backup, sin cambiar a GET que perdería los datos."
            },
            {
                "scenario": "Balanceo de carga con método preservado",
                "request": "PUT /api/users/123/profile HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john.new@example.com\",\n  \"phone\": \"+1234567890\"\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-node-2.example.com/api/users/123/profile\nX-Load-Balancer: round-robin\nX-Target-Node: node-2\nCache-Control: no-cache\n\n{\n  \"status\": \"redirecting\",\n  \"target_server\": \"node-2\",\n  \"message\": \"Request being routed to optimal server node\"\n}",
                "explanation": "El load balancer redirige temporalmente la solicitud PUT a otro nodo del cluster. El código 307 garantiza que la solicitud PUT con los datos de actualización del perfil se envíe al nuevo servidor, no se convierta en GET."
            },
            {
                "scenario": "Upload de archivo con redirección temporal",
                "request": "POST /api/uploads HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data; boundary=----Boundary\nContent-Length: 5242880\n\n------Boundary\nContent-Disposition: form-data; name=\"file\"; filename=\"report.pdf\"\nContent-Type: application/pdf\n\n[5MB de datos del archivo PDF]\n------Boundary--",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://storage-region-2.example.com/api/uploads\nX-Storage-Region: us-west-2\nX-Redirect-Reason: region_optimization\nRetry-After: 0\n\n{\n  \"message\": \"Redirecting to optimal storage region\",\n  \"target_region\": \"us-west-2\",\n  \"note\": \"File upload will be resubmitted automatically\"\n}",
                "explanation": "El sistema de storage detecta que el usuario está más cerca de otra región y redirige temporalmente. El código 307 asegura que el POST con el archivo completo se reenvíe al servidor de la nueva región sin perder datos."
            },
            {
                "scenario": "Mantenimiento de API con DELETE preservado",
                "request": "DELETE /api/articles/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer token_abc\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://api-maintenance.example.com/api/articles/456\nX-Maintenance-Mode: true\nX-Estimated-Duration: 1800\nCache-Control: no-store\n\n{\n  \"status\": \"maintenance_redirect\",\n  \"message\": \"Main API under scheduled maintenance\",\n  \"maintenance_endpoint\": \"https://api-maintenance.example.com\",\n  \"operation_will_complete\": true\n}",
                "explanation": "Durante mantenimiento programado, las solicitudes DELETE son redirigidas a un servidor de mantenimiento que puede procesarlas. El 307 preserva el método DELETE para que la operación de eliminación se ejecute correctamente en el nuevo servidor."
            },
            {
                "scenario": "Migración gradual de endpoints",
                "request": "PATCH /api/v2/settings/notifications HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\n\n{\n  \"email_notifications\": false,\n  \"push_notifications\": true\n}",
                "response": "HTTP/1.1 307 Temporary Redirect\nLocation: https://new-api.example.com/api/v2/settings/notifications\nX-Migration-Phase: gradual-rollout\nX-Legacy-Endpoint: deprecated\nDeprecation: true\nLink: <https://docs.example.com/api-migration>; rel=\"deprecation\"\n\n{\n  \"message\": \"This endpoint is being migrated to new infrastructure\",\n  \"new_location\": \"https://new-api.example.com/api/v2/settings/notifications\",\n  \"migration_guide\": \"https://docs.example.com/api-migration\"\n}",
                "explanation": "Durante una migración gradual de API, el endpoint antiguo redirige temporalmente al nuevo con 307, preservando el método PATCH y los datos de actualización de configuración."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.4.7",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Retry-After",
            "Vary",
            "X-Redirect-Reason"
        ],
        "technicalNotes": "El código 307 fue introducido en HTTP/1.1 para eliminar la ambigüedad del 302. La diferencia clave es que 307 GARANTIZA que el método HTTP se preserve (POST sigue siendo POST, PUT sigue siendo PUT, etc.), mientras que 302 en la práctica causa que navegadores cambien POST a GET. Para redirecciones temporales donde el método debe preservarse, siempre usa 307. Para redirecciones temporales donde cambiar a GET es aceptable o deseado, usa 302 o mejor aún 303. Los navegadores NO cachean 307 agresivamente, similar a 302. Los motores de búsqueda mantienen el URL original en índices.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701321/307_zejcdc.png",
                "alt": "Imagen que representa el nombre del código 307 Temporary Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/23-removebg-preview_lguvh9.png",
                "alt": "Imagen del código 307 Temporary Redirect"
            }
        ]
    },
    {
        "code": 308,
        "status": "Permanent Redirect",
        "category": "Redirection",
        "description": "El código 308 Permanent Redirect indica que el recurso solicitado ha sido movido permanentemente a una nueva URI especificada en el encabezado Location, y todas las futuras solicitudes deben usar la nueva URI. Además, y esto es lo más importante, el cliente DEBE usar el mismo método HTTP en la solicitud redirigida que usó en la solicitud original. El código 308 es a 301 lo que 307 es a 302: proporciona una versión sin ambigüedades que garantiza la preservación del método HTTP. Mientras que el código 301 Moved Permanently es históricamente ambiguo (muchos navegadores cambian POST a GET al seguir un 301, aunque la especificación dice preservar el método), el código 308 elimina completamente esta ambigüedad. Si la solicitud original fue POST, la redirigida debe ser POST. Si fue PUT, la redirigida debe ser PUT. Si fue DELETE, la redirigida debe ser DELETE. Esta garantía es crítica para APIs RESTful y aplicaciones donde el método HTTP tiene significado semántico importante. El código 308 fue estandarizado más recientemente que otros códigos de redirección (en RFC 7538 de 2015) para llenar un vacío en la especificación HTTP. Combina dos propiedades importantes: (1) permanencia - como 301, indica que el cambio es definitivo y permanente, los motores de búsqueda deben actualizar índices, los navegadores pueden cachear la redirección, y el valor SEO debe transferirse al nuevo URL; (2) preservación del método - como 307, garantiza que el método HTTP no cambie durante la redirección. Los casos de uso típicos incluyen: reestructuración permanente de APIs donde los métodos deben preservarse, migración permanente de endpoints RESTful, consolidación de servicios manteniendo semántica de métodos HTTP, cambios de infraestructura permanentes donde POST/PUT/DELETE deben mantenerse, y cualquier redirección permanente donde cambiar el método sería semánticamente incorrecto o causaría pérdida de datos.",
        "useCases": [
            "Reestructuración permanente de APIs RESTful preservando métodos HTTP",
            "Migración permanente de endpoints donde POST, PUT, DELETE deben mantenerse",
            "Cambio permanente de dominio para APIs con operaciones de escritura",
            "Consolidación de servicios manteniendo semántica RESTful",
            "Deprecación definitiva de endpoints antiguos hacia nuevos con misma funcionalidad",
            "Migración de infraestructura permanente (on-premise a cloud) preservando métodos",
            "Reorganización de URLs en APIs donde el método HTTP es parte de la semántica",
            "Versioning de APIs con redirección permanente preservando operaciones"
        ],
        "examples": [
            {
                "scenario": "Migración permanente de API endpoint con POST",
                "request": "POST /api/v1/users HTTP/1.1\nHost: old-api.example.com\nContent-Type: application/json\nAuthorization: Bearer token_xyz\n\n{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane@example.com\",\n  \"role\": \"admin\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v2/users\nCache-Control: max-age=31536000\nDeprecation: true\nSunset: Mon, 01 Jan 2025 00:00:00 GMT\n\n{\n  \"message\": \"API v1 has been permanently moved to v2\",\n  \"new_endpoint\": \"https://api.example.com/v2/users\",\n  \"documentation\": \"https://docs.example.com/api/v2\",\n  \"note\": \"Please update your integration to use the new endpoint\"\n}",
                "explanation": "La API v1 ha sido permanentemente reemplazada por v2. El código 308 asegura que la solicitud POST con los datos del nuevo usuario se reenvíe al nuevo endpoint manteniendo POST, no convirtiéndose a GET que perdería los datos."
            },
            {
                "scenario": "Cambio permanente de dominio con PUT preservado",
                "request": "PUT /api/products/789 HTTP/1.1\nHost: shop-api.oldcompany.com\nContent-Type: application/json\nAuthorization: Bearer token_abc\n\n{\n  \"name\": \"Updated Product Name\",\n  \"price\": 99.99,\n  \"stock\": 150,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.newcompany.com/api/products/789\nCache-Control: public, max-age=31536000, immutable\nX-Company-Rebrand: true\nLink: <https://www.newcompany.com/api-migration>; rel=\"alternate\"\n\n{\n  \"status\": \"permanent_redirect\",\n  \"message\": \"Our company has rebranded. API permanently moved to new domain.\",\n  \"new_location\": \"https://api.newcompany.com\",\n  \"migration_complete\": true\n}",
                "explanation": "La empresa cambió de marca y dominio permanentemente. El 308 garantiza que la solicitud PUT para actualizar el producto se reenvíe al nuevo dominio manteniendo el método PUT y todos los datos de actualización."
            },
            {
                "scenario": "Reestructuración permanente con DELETE preservado",
                "request": "DELETE /services/old-structure/items/456 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token\nX-Confirm-Delete: true",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://api.example.com/v3/items/456\nCache-Control: max-age=2592000\nX-API-Restructure: v3-final\n\n{\n  \"message\": \"API structure has been permanently reorganized\",\n  \"old_path\": \"/services/old-structure/items/:id\",\n  \"new_path\": \"/v3/items/:id\",\n  \"operation_preserved\": \"DELETE\",\n  \"note\": \"Your delete operation will complete at the new location\"\n}",
                "explanation": "La estructura de la API fue permanentemente reorganizada. El 308 asegura que la solicitud DELETE se reenvíe a la nueva estructura manteniendo la operación de eliminación, no cambiando a GET."
            },
            {
                "scenario": "Migración cloud permanente con PATCH",
                "request": "PATCH /api/configurations/global HTTP/1.1\nHost: on-premise.example.com\nContent-Type: application/json\n\n{\n  \"maintenance_mode\": false,\n  \"max_connections\": 1000,\n  \"timeout_seconds\": 30\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://cloud-api.example.com/api/configurations/global\nX-Migration-Type: on-premise-to-cloud\nX-Migration-Date: 2024-01-15\nCache-Control: public, max-age=31536000\n\n{\n  \"message\": \"Service permanently migrated to cloud infrastructure\",\n  \"cloud_endpoint\": \"https://cloud-api.example.com\",\n  \"on_premise_shutdown\": \"2024-06-01\",\n  \"benefits\": \"Improved reliability, scalability, and performance\"\n}",
                "explanation": "El servicio fue migrado permanentemente de infraestructura on-premise a cloud. El 308 preserva el método PATCH para que la actualización parcial de configuración se aplique correctamente en el nuevo servidor cloud."
            },
            {
                "scenario": "Consolidación de microservicios con POST",
                "request": "POST /payment-service/api/process HTTP/1.1\nHost: payments.example.com\nContent-Type: application/json\n\n{\n  \"amount\": 299.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"card_token\": \"tok_12345\"\n}",
                "response": "HTTP/1.1 308 Permanent Redirect\nLocation: https://unified-api.example.com/payments/process\nX-Service-Consolidation: microservices-to-unified\nCache-Control: max-age=15552000\n\n{\n  \"message\": \"Payment service consolidated into unified API\",\n  \"new_endpoint\": \"https://unified-api.example.com/payments/process\",\n  \"consolidation_date\": \"2024-01-01\",\n  \"note\": \"All microservices now under unified API gateway\"\n}",
                "explanation": "Múltiples microservicios fueron consolidados en una API unificada permanentemente. El 308 asegura que la solicitud POST de procesamiento de pago con datos sensibles se reenvíe correctamente manteniendo POST."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7538 (2015)",
        "relatedHeaders": [
            "Location",
            "Cache-Control",
            "Deprecation",
            "Sunset",
            "Link"
        ],
        "relatedCodes": [
            301,
            307
        ],
        "technicalNotes": "El código 308 es relativamente nuevo (RFC 7538, 2015) y fue creado para llenar el vacío de un código de redirección permanente que preserve el método HTTP. Es a 301 lo que 307 es a 302. Combina permanencia (como 301) con preservación de método (como 307). Los navegadores modernos lo soportan bien desde ~2015-2016. Al igual que 301, los navegadores y motores de búsqueda deben cachear 308 y actualizar índices. La diferencia crítica con 301 es que 308 GARANTIZA que POST/PUT/DELETE/PATCH se preserven, mientras que 301 históricamente causa que navegadores cambien POST a GET. Para APIs RESTful con redirecciones permanentes, 308 es casi siempre la elección correcta.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768701324/308_ypkqc3.png",
                "alt": "Imagen que representa el nombre del código 308 Permanent Redirect"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768685323/24-removebg-preview_ee4zid.png",
                "alt": "Imagen del código 308 Permanent Redirect"
            }
        ]
    },
    {
        "code": 400,
        "status": "Bad Request",
        "category": "Client Error",
        "description": "El código 400 Bad Request indica que el servidor no puede o no procesará la solicitud debido a algo que se percibe como un error del cliente. Este es uno de los códigos de error más comunes y versátiles en HTTP, utilizado como respuesta genérica para una amplia variedad de errores de solicitud del cliente que no encajan en categorías más específicas. El servidor está indicando que la solicitud está malformada, contiene sintaxis inválida, parámetros inválidos, o es imposible de cumplir por razones que son responsabilidad del cliente. Las causas comunes incluyen: JSON o XML mal formado en el cuerpo de la solicitud, parámetros de query string inválidos o que faltan, encabezados HTTP malformados o contradictorios, tamaño de solicitud que excede límites del servidor, errores de codificación de caracteres, valores de datos que no cumplen con reglas de validación, tipos de contenido no soportados, o cualquier otra violación del protocolo HTTP o de las expectativas de la API. A diferencia de errores 5xx que indican problemas del servidor, el 400 señala claramente que el problema está en la solicitud del cliente y que reenviar la misma solicitud sin modificaciones resultará en el mismo error. El cliente debe corregir la solicitud antes de reintentarla. Es importante que las respuestas 400 incluyan información descriptiva en el cuerpo del mensaje explicando qué está mal con la solicitud para ayudar a los desarrolladores a corregir el problema. Una buena respuesta 400 debería especificar: qué campo o parámetro causó el error, qué se esperaba versus qué se recibió, y cómo corregir el problema. En APIs RESTful modernas, es común incluir códigos de error estructurados, mensajes de error detallados, y referencias a documentación. El código 400 es preferible a códigos de error más específicos cuando el error no encaja claramente en categorías como 401 (autenticación), 403 (autorización), 404 (no encontrado), etc.",
        "useCases": [
            "JSON o XML malformado en el cuerpo de la solicitud",
            "Parámetros de query string inválidos, faltantes o mal formateados",
            "Errores de validación de datos de entrada (formatos incorrectos, valores fuera de rango)",
            "Encabezados HTTP contradictorios o malformados",
            "Tamaño de solicitud que excede límites permitidos",
            "Tipo de contenido no soportado o Content-Type incorrecto",
            "Errores de codificación de caracteres en la solicitud",
            "Violaciones de esquema o estructura de datos esperada",
            "Combinaciones inválidas de parámetros",
            "Requests que violan reglas de negocio básicas"
        ],
        "examples": [
            {
                "scenario": "JSON malformado en el cuerpo de la solicitud",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  // Comentario inválido en JSON\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_request_body\",\n  \"message\": \"Request body contains malformed JSON\",\n  \"details\": \"Unexpected token '/' at position 78. JSON does not support comments.\",\n  \"documentation\": \"https://api.example.com/docs/errors/invalid-json\"\n}",
                "explanation": "El JSON en el cuerpo contiene un comentario que no es válido en JSON estándar. El servidor responde con 400 y explica específicamente qué está mal y dónde ocurrió el error."
            },
            {
                "scenario": "Parámetros de validación fallidos",
                "request": "POST /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"AB\",\n  \"price\": -10.50,\n  \"stock\": \"not_a_number\"\n}",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Request validation failed\",\n  \"validation_errors\": [\n    {\n      \"field\": \"name\",\n      \"message\": \"Name must be at least 3 characters long\",\n      \"received\": \"AB\"\n    },\n    {\n      \"field\": \"price\",\n      \"message\": \"Price must be a positive number\",\n      \"received\": -10.50\n    },\n    {\n      \"field\": \"stock\",\n      \"message\": \"Stock must be an integer\",\n      \"received_type\": \"string\"\n    }\n  ]\n}",
                "explanation": "Múltiples campos tienen errores de validación. La respuesta 400 proporciona detalles específicos de cada error, facilitando que el cliente corrija todos los problemas de una vez."
            },
            {
                "scenario": "Parámetros de query string inválidos",
                "request": "GET /api/users?page=abc&limit=-5 HTTP/1.1\nHost: api.example.com",
                "response": "HTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_query_parameters\",\n  \"message\": \"One or more query parameters are invalid\",\n  \"errors\": [\n    {\n      \"parameter\": \"page\",\n      \"error\": \"Page must be a positive integer\",\n      \"received\": \"abc\"\n    },\n    {\n      \"parameter\": \"limit\",\n      \"error\": \"Limit must be between 1 and 100\",\n      \"received\": -5\n    }\n  ]\n}",
                "explanation": "Los parámetros de paginación contienen valores inválidos. El servidor indica qué parámetros están mal y qué valores son aceptables."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.1",
        "relatedHeaders": [
            "Content-Type",
            "Content-Length"
        ],
        "technicalNotes": "400 es un código de error genérico del cliente. Cuando sea posible, usa códigos más específicos: 401 para autenticación, 403 para autorización, 404 para recursos no encontrados, 405 para métodos no permitidos, 409 para conflictos, 422 para errores de validación semántica. El 400 debe reservarse para errores de sintaxis, malformaciones, o cuando ningún código más específico aplica. Siempre incluye un cuerpo de respuesta descriptivo con detalles del error para facilitar debugging.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712934/400_odwp8l.png",
                "alt": "Imagen que representa el nombre del código 400 Bad Request"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712631/25-removebg-preview_ujorgb.png",
                "alt": "Imagen del código 400 Bad Request"
            }
        ]
    },
    {
        "code": 401,
        "status": "Unauthorized",
        "category": "Client Error",
        "description": "El código 401 Unauthorized indica que la solicitud requiere autenticación del usuario y que las credenciales proporcionadas son inválidas, están ausentes, o han expirado. A pesar de su nombre algo confuso ('Unauthorized'), este código específicamente se refiere a problemas de AUTENTICACIÓN (verificar quién eres), no de AUTORIZACIÓN (verificar qué puedes hacer). El nombre más preciso sería 'Unauthenticated', pero por razones históricas se mantiene como 'Unauthorized'. Cuando un servidor responde con 401, está diciendo: 'No sé quién eres' o 'Las credenciales que proporcionaste no son válidas' o 'Tu sesión ha expirado'. El cliente debe proporcionar credenciales válidas (o renovarlas) para acceder al recurso. La respuesta 401 DEBE incluir un encabezado WWW-Authenticate que especifique el esquema de autenticación que el servidor espera (Basic, Bearer, Digest, etc.). Este encabezado informa al cliente qué tipo de credenciales se requieren y cómo deben ser enviadas. Los escenarios comunes incluyen: intentar acceder a un recurso protegido sin proporcionar token de autenticación, proporcionar un token JWT expirado o inválido, credenciales de usuario/contraseña incorrectas, token de API key inválido o revocado, sesión expirada que necesita renovación, o intentar usar un token de autenticación que fue emitido para otro recurso o dominio. En aplicaciones web modernas, 401 típicamente resulta en redireccionar al usuario a una página de login o mostrar un modal de autenticación. En APIs, puede desencadenar un flujo de renovación de tokens (refresh token flow) o requerir que el usuario vuelva a autenticarse. Es crucial distinguir 401 de 403 Forbidden: usa 401 cuando el problema es que el cliente no está autenticado o sus credenciales son inválidas; usa 403 cuando el cliente está correctamente autenticado pero no tiene permisos para acceder al recurso específico.",
        "useCases": [
            "Acceso a recursos protegidos sin proporcionar token de autenticación",
            "Token JWT expirado que necesita renovación",
            "Credenciales de usuario/contraseña incorrectas en login",
            "API key inválida, revocada o faltante",
            "Sesión de usuario expirada que requiere re-autenticación",
            "Token de autenticación malformado o corrupto",
            "Intentar acceder con credenciales que fueron revocadas",
            "Autenticación de dos factores (2FA) fallida",
            "Token OAuth inválido o expirado",
            "Certificado de cliente inválido o faltante en mTLS"
        ],
        "examples": [
            {
                "scenario": "Acceso sin token de autenticación",
                "request": "GET /api/user/profile HTTP/1.1\nHost: api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"authentication_required\",\n  \"message\": \"Authentication is required to access this resource\",\n  \"required_header\": \"Authorization: Bearer <token>\",\n  \"obtain_token\": \"https://api.example.com/auth/login\"\n}",
                "explanation": "La solicitud intenta acceder a un perfil de usuario protegido sin proporcionar ningún token de autenticación. El servidor responde con 401 y el encabezado WWW-Authenticate indicando que se requiere autenticación Bearer."
            },
            {
                "scenario": "Token JWT expirado",
                "request": "GET /api/orders HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired_token.signature",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"The access token expired\"\nContent-Type: application/json\n\n{\n  \"error\": \"token_expired\",\n  \"message\": \"Your access token has expired\",\n  \"expired_at\": \"2024-01-15T10:00:00Z\",\n  \"refresh_endpoint\": \"/auth/refresh\"\n}",
                "explanation": "El token JWT proporcionado es válido estructuralmente pero ha expirado. El servidor indica cuándo expiró y cómo obtener un nuevo token usando el refresh token."
            },
            {
                "scenario": "Credenciales de login incorrectas",
                "request": "POST /auth/login HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"username\": \"john@example.com\",\n  \"password\": \"wrong_password\"\n}",
                "response": "HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer realm=\"api.example.com\"\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_credentials\",\n  \"message\": \"The username or password you entered is incorrect\",\n  \"attempts_remaining\": 3,\n  \"lockout_warning\": \"Account will be locked after 5 failed attempts\"\n}",
                "explanation": "El usuario proporcionó credenciales incorrectas. El servidor responde con 401 e información sobre intentos restantes antes de bloqueo de cuenta."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7235, Section 3.1",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization",
            "Proxy-Authenticate",
            "Proxy-Authorization"
        ],
        "technicalNotes": "401 es específicamente para AUTENTICACIÓN (quién eres), no AUTORIZACIÓN (qué puedes hacer). La respuesta DEBE incluir encabezado WWW-Authenticate. Los esquemas comunes son: Basic, Bearer (JWT/OAuth), Digest, OAuth, ApiKey. Distinguir de 403 Forbidden: 401 = no estás autenticado o credenciales inválidas; 403 = estás autenticado pero no autorizado. En aplicaciones web, 401 típicamente resulta en redirect a login; en APIs, puede trigger refresh token flow.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712933/401_bmlwc3.png",
                "alt": "Imagen que representa el nombre del código 401 Unauthorized"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712629/26-removebg-preview_kemtbk.png",
                "alt": "Imagen del código 401 Unauthorized"
            }
        ]
    },
    {
        "code": 402,
        "status": "Payment Required",
        "category": "Client Error",
        "description": "El código 402 Payment Required está RESERVADO para uso futuro y originalmente fue concebido para sistemas de pago digital y micropagos en la web. Este código fue incluido en la especificación original de HTTP con la visión de que la web eventualmente incorporaría sistemas de pago integrados directamente en el protocolo HTTP. La idea era que los servidores pudieran responder con 402 cuando un recurso requiriera pago, y los navegadores tendrían capacidades integradas para manejar transacciones. Sin embargo, más de 30 años después de su creación, el código 402 sigue sin tener una definición formal o implementación estándar. Aunque está reservado oficialmente, NO existe un comportamiento estándar definido para él en las especificaciones HTTP. A pesar de esto, algunas APIs modernas y servicios han comenzado a utilizar 402 de manera no estándar para indicar varios escenarios relacionados con pagos: cuando un usuario ha excedido su cuota de API gratuita y necesita actualizar a un plan de pago, cuando una suscripción ha expirado, cuando se requiere pago para acceder a contenido premium, o cuando un servicio freemium ha alcanzado sus límites gratuitos. Sin embargo, estas implementaciones son completamente no estandarizadas y varían significativamente entre diferentes servicios. Debido a la falta de estándares, muchos desarrolladores y servicios evitan usar 402 y en su lugar optan por códigos alternativos como 403 Forbidden con mensajes explicativos sobre requisitos de pago, 451 Unavailable For Legal Reasons para contenido bloqueado por razones comerciales, o códigos de error personalizados en el rango 4xx. Algunos argumentan que 402 podría ser útil para distinguir problemas de pago de otros errores, pero sin estandarización, su uso sigue siendo experimental y no recomendado para producción crítica.",
        "useCases": [
            "USO NO ESTÁNDAR: Indicar que se ha excedido cuota de API gratuita",
            "USO NO ESTÁNDAR: Suscripción expirada que requiere renovación",
            "USO NO ESTÁNDAR: Contenido premium que requiere pago",
            "USO NO ESTÁNDAR: Límites de freemium alcanzados",
            "NOTA: Ninguno de estos usos está estandarizado oficialmente"
        ],
        "examples": [
            {
                "scenario": "Uso experimental (NO estándar) - Cuota de API excedida",
                "request": "GET /api/premium-data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 402 Payment Required\nContent-Type: application/json\n\n{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"You have exceeded your free tier quota\",\n  \"quota_limit\": 1000,\n  \"quota_used\": 1000,\n  \"upgrade_url\": \"https://billing.example.com/upgrade\",\n  \"note\": \"Non-standard use of 402. Standard practice would be 403 or 429.\"\n}",
                "explanation": "USO EXPERIMENTAL: Este servicio usa 402 para indicar que el usuario gratuito ha excedido su cuota. Sin embargo, este NO es un uso estándar. Sería más apropiado usar 429 (Too Many Requests) o 403 (Forbidden) con información de pago."
            },
            {
                "scenario": "Alternativa ESTÁNDAR recomendada - Usar 403 con contexto de pago",
                "request": "GET /api/premium-features HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"payment_required\",\n  \"message\": \"This feature requires a paid subscription\",\n  \"current_plan\": \"free\",\n  \"required_plan\": \"premium\",\n  \"upgrade_url\": \"https://example.com/upgrade\",\n  \"price\": \"$19.99/month\"\n}",
                "explanation": "MEJOR PRÁCTICA: Usar 403 Forbidden con información detallada sobre requisitos de pago es más estándar y ampliamente entendido que usar el no estandarizado 402."
            },
            {
                "scenario": "Alternativa usando 429 para límites de cuota",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer free_tier_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1706745600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded your monthly API quota\",\n  \"reset_date\": \"2024-02-01T00:00:00Z\",\n  \"upgrade_info\": \"https://billing.example.com/upgrade\"\n}",
                "explanation": "MEJOR PRÁCTICA: Para límites de cuota/rate limiting, 429 Too Many Requests es semánticamente más correcto que 402, incluso si el upgrade requiere pago."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.2 (Reserved for future use)",
        "relatedHeaders": [],
        "technicalNotes": "El código 402 está OFICIALMENTE RESERVADO pero NO DEFINIDO en las especificaciones HTTP. No existe comportamiento estándar para este código. Su uso en producción es NO RECOMENDADO. Alternativas estándar: 403 Forbidden (para contenido que requiere pago), 429 Too Many Requests (para límites de cuota), o códigos personalizados 4xx. Muchas empresas evitan 402 completamente debido a la falta de estandarización.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712936/402_vofv3h.png",
                "alt": "Imagen que representa el nombre del código 402 Payment Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712628/27-removebg-preview_sws62c.png",
                "alt": "Imagen del código 402 Payment Required"
            }
        ]
    },
    {
        "code": 403,
        "status": "Forbidden",
        "category": "Client Error",
        "description": "El código 403 Forbidden indica que el servidor entendió la solicitud pero se niega a autorizarla. A diferencia del 401 Unauthorized que se refiere a problemas de AUTENTICACIÓN (quién eres), el 403 se refiere específicamente a problemas de AUTORIZACIÓN (qué tienes permitido hacer). Cuando un servidor responde con 403, está diciendo: 'Sé quién eres (estás autenticado correctamente), pero no tienes permiso para acceder a este recurso' o 'Este recurso está prohibido para ti'. Este es un punto crítico de distinción: 401 significa que no te has identificado o tus credenciales son inválidas, mientras que 403 significa que te identificaste correctamente pero no tienes los permisos necesarios. Un 403 indica que proporcionar credenciales diferentes no ayudará - el acceso está prohibido independientemente de la autenticación. Las causas comunes incluyen: intentar acceder a un recurso para el cual tu rol de usuario no tiene permisos, intentar realizar una operación que excede tus privilegios (por ejemplo, un usuario regular intentando acceder a funciones de administrador), acceder a recursos que están geográficamente restringidos, intentar acceder a contenido que requiere una suscripción o plan de pago superior, violación de políticas de seguridad o control de acceso, acceso bloqueado por firewall de aplicación web (WAF), direcciones IP bloqueadas o en lista negra, intentar acceder a archivos del sistema o directorios protegidos, o violación de límites de rate limiting basados en permisos. A diferencia del 401 que puede ser resuelto proporcionando credenciales válidas, un 403 generalmente requiere que se otorguen permisos adicionales al usuario, que se cambie de plan de suscripción, que se modifiquen políticas de acceso, o que se eliminen restricciones. Las respuestas 403 deben ser cuidadosamente diseñadas para no revelar información sensible sobre la estructura del sistema o existencia de recursos, ya que esto podría ser explotado por atacantes. Es una buena práctica incluir información útil sobre por qué el acceso fue denegado (sin revelar detalles de seguridad sensibles) y qué acciones podría tomar el usuario para obtener acceso.",
        "useCases": [
            "Usuario autenticado intenta acceder a recursos de administrador sin privilegios",
            "Acceso a recursos que requieren roles o permisos específicos que el usuario no tiene",
            "Intentar modificar o eliminar recursos que pertenecen a otro usuario",
            "Acceso a contenido premium sin suscripción adecuada",
            "Restricciones geográficas o de región (geo-blocking)",
            "Límites de rate limiting excedidos para el nivel de usuario",
            "IP bloqueada o en lista negra por razones de seguridad",
            "Violación de políticas de uso o términos de servicio",
            "Acceso a recursos durante horarios restringidos",
            "Intentar realizar operaciones en modo de solo lectura"
        ],
        "examples": [
            {
                "scenario": "Usuario sin privilegios de administrador",
                "request": "DELETE /api/users/789 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer valid_user_token_not_admin",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"insufficient_permissions\",\n  \"message\": \"You do not have permission to perform this action\",\n  \"required_role\": \"admin\",\n  \"your_role\": \"user\",\n  \"action_attempted\": \"delete_user\",\n  \"contact\": \"Please contact your administrator to request elevated permissions\",\n  \"documentation\": \"https://docs.example.com/permissions/roles\"\n}",
                "explanation": "El usuario está correctamente autenticado (el token es válido) pero su rol de 'user' no tiene permisos para eliminar usuarios. Solo los administradores pueden realizar esta acción. Proporcionar un token diferente de usuario regular no ayudará."
            },
            {
                "scenario": "Acceso a recurso de otro usuario",
                "request": "GET /api/users/456/private-messages HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_123_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"access_denied\",\n  \"message\": \"You are not authorized to access this resource\",\n  \"reason\": \"This resource belongs to another user\",\n  \"resource_owner\": \"user_456\",\n  \"authenticated_as\": \"user_123\",\n  \"allowed_actions\": [\n    \"View your own messages at /api/users/123/private-messages\"\n  ]\n}",
                "explanation": "El usuario 123 está autenticado correctamente pero está intentando acceder a los mensajes privados del usuario 456. Por razones de privacidad y seguridad, esto está prohibido. Solo puede acceder a sus propios mensajes."
            },
            {
                "scenario": "Contenido premium sin suscripción adecuada",
                "request": "GET /api/premium-analytics/advanced-reports HTTP/1.1\nHost: analytics.example.com\nAuthorization: Bearer basic_plan_user_token",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"subscription_required\",\n  \"message\": \"This feature requires a premium subscription\",\n  \"current_plan\": \"Basic\",\n  \"required_plan\": \"Premium\",\n  \"feature_name\": \"Advanced Analytics Reports\",\n  \"upgrade_info\": {\n    \"plan_name\": \"Premium Plan\",\n    \"monthly_price\": \"$49.99\",\n    \"annual_price\": \"$499.99 (2 months free)\",\n    \"features\": [\n      \"Advanced analytics reports\",\n      \"Custom dashboards\",\n      \"API access\",\n      \"Priority support\"\n    ],\n    \"upgrade_url\": \"https://analytics.example.com/upgrade\",\n    \"trial_available\": true,\n    \"trial_duration\": \"14 days\"\n  }\n}",
                "explanation": "El usuario está autenticado y tiene una cuenta válida con plan Basic, pero este recurso específico requiere un plan Premium. El acceso está prohibido hasta que actualice su suscripción."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.3",
        "relatedHeaders": [
            "WWW-Authenticate",
            "Authorization"
        ],
        "technicalNotes": "403 es específicamente para AUTORIZACIÓN (qué puedes hacer), no AUTENTICACIÓN (quién eres). La diferencia con 401: 401 = no autenticado o credenciales inválidas (solucionable con login correcto); 403 = autenticado pero sin permisos (proporcionar otras credenciales no ayuda, se necesitan permisos adicionales). No incluyas WWW-Authenticate en 403, ese encabezado es para 401. Por seguridad, considera si deberías devolver 404 en lugar de 403 cuando no quieras revelar que un recurso existe. 403 es apropiado cuando el usuario debe saber que el recurso existe pero no puede accederlo.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712938/403_vobb9m.png",
                "alt": "Imagen que representa el nombre del código 403 Forbidden"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712627/28-removebg-preview_kc6xuc.png",
                "alt": "Imagen del código 403 Forbidden"
            }
        ]
    },
    {
        "code": 404,
        "status": "Not Found",
        "category": "Client Error",
        "description": "El código 404 Not Found es probablemente el código de estado HTTP más conocido y reconocible, incluso fuera de la comunidad técnica. Indica que el servidor no pudo encontrar el recurso solicitado. Es importante entender que 404 significa específicamente que el URI solicitado no corresponde a ningún recurso existente en el servidor, pero no proporciona información sobre si esta ausencia es temporal o permanente. El servidor está diciendo: 'Busqué en la ubicación que especificaste y no hay nada allí'. Esto puede ocurrir por varias razones: el recurso nunca existió en esa ubicación, el recurso existió anteriormente pero fue eliminado, el recurso fue movido a otra ubicación sin configurar una redirección, hay un error tipográfico en la URL, o el usuario no tiene permisos para saber que el recurso existe (en cuyo caso 404 se usa intencionalmente en lugar de 403 por razones de seguridad). El código 404 es apropiado tanto para recursos que definitivamente no existen como para aquellos cuya existencia no debería ser revelada por razones de seguridad o privacidad. Por ejemplo, si un usuario intenta acceder a '/admin/secret-page' pero no tiene permisos, podrías devolver 404 en lugar de 403 para no confirmar que esa página existe. El 404 es distinto del 410 Gone, que específicamente indica que el recurso existió anteriormente pero fue eliminado permanentemente y no regresará. Si sabes con certeza que un recurso fue eliminado permanentemente, 410 es más semántico, pero 404 es aceptable y más comúnmente usado. Las páginas 404 personalizadas son una práctica común en diseño web, ofreciendo navegación útil, búsqueda, o contenido relacionado en lugar de simplemente indicar el error. En APIs RESTful, las respuestas 404 deben incluir información estructurada sobre qué recurso no se encontró y potencialmente sugerencias de recursos similares o acciones alternativas. Es importante que las respuestas 404 sean informativas pero no revelen información sensible del sistema.",
        "useCases": [
            "URL con error tipográfico o mal formada",
            "Recurso que fue eliminado y no existe más",
            "Recurso que nunca existió en la ubicación especificada",
            "ID de recurso inválido en APIs RESTful (producto, usuario, orden que no existe)",
            "Ruta de archivo o directorio inexistente",
            "Endpoint de API que no está definido o fue deprecado",
            "Recurso movido sin redirección configurada",
            "Seguridad: ocultar existencia de recursos sensibles devolviendo 404 en lugar de 403",
            "Páginas que fueron parte de una reestructuración de sitio sin mantener URLs antiguas",
            "Recursos temporales que expiraron (cupones, tokens de verificación vencidos)"
        ],
        "examples": [
            {
                "scenario": "Recurso no encontrado en API REST",
                "request": "GET /api/products/99999 HTTP/1.1\nHost: shop.example.com\nAccept: application/json",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"resource_not_found\",\n  \"message\": \"Product not found\",\n  \"resource_type\": \"product\",\n  \"resource_id\": \"99999\",\n  \"requested_url\": \"/api/products/99999\",\n  \"suggestions\": [\n    \"Verify the product ID is correct\",\n    \"Browse available products at /api/products\",\n    \"Search products at /api/products/search\"\n  ],\n  \"documentation\": \"https://docs.shop.example.com/api/products\"\n}",
                "explanation": "El cliente solicitó un producto con ID 99999 que no existe en la base de datos. El servidor responde con 404 e información útil sobre cómo proceder."
            },
            {
                "scenario": "Página web no encontrada con sugerencias útiles",
                "request": "GET /blog/non-existent-article HTTP/1.1\nHost: www.example.com\nAccept: text/html",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page Not Found - Example Blog</title>\n  <meta name=\"robots\" content=\"noindex\">\n</head>\n<body>\n  <h1>404 - Page Not Found</h1>\n  <p>Sorry, we couldn't find the page you're looking for.</p>\n  <h2>You might be interested in:</h2>\n  <ul>\n    <li><a href=\"/blog\">Latest Blog Posts</a></li>\n    <li><a href=\"/blog/popular\">Popular Articles</a></li>\n    <li><a href=\"/search?q=article\">Search our site</a></li>\n  </ul>\n  <p>Or <a href=\"/\">return to homepage</a></p>\n</body>\n</html>",
                "explanation": "La página solicitada no existe. En lugar de un error genérico, se proporciona una página 404 personalizada con navegación útil, enlaces a contenido popular y opción de búsqueda para ayudar al usuario a encontrar lo que busca."
            },
            {
                "scenario": "Endpoint de API inexistente",
                "request": "POST /api/v2/invalid-endpoint HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"data\": \"some data\"\n}",
                "response": "HTTP/1.1 404 Not Found\nContent-Type: application/json\n\n{\n  \"error\": \"endpoint_not_found\",\n  \"message\": \"The requested API endpoint does not exist\",\n  \"requested_path\": \"/api/v2/invalid-endpoint\",\n  \"method\": \"POST\",\n  \"api_version\": \"v2\",\n  \"available_endpoints\": [\n    \"GET /api/v2/users\",\n    \"POST /api/v2/users\",\n    \"GET /api/v2/products\",\n    \"POST /api/v2/orders\"\n  ],\n  \"documentation\": \"https://api.example.com/docs/v2\",\n  \"support\": \"api-support@example.com\"\n}",
                "explanation": "El cliente está intentando acceder a un endpoint que no existe en la API. El servidor responde con 404 y lista de endpoints disponibles para ayudar al desarrollador a corregir la solicitud."
            }
        ],
        "httpVersion": "HTTP/1.0+",
        "specification": "RFC 7231, Section 6.5.4",
        "relatedHeaders": [
            "Content-Type",
            "Cache-Control"
        ],
        "relatedCodes": [
            410
        ],
        "technicalNotes": "404 significa que el recurso no fue encontrado en la ubicación solicitada, pero no especifica si es temporal o permanente. Para eliminaciones permanentes conocidas, considera usar 410 Gone en su lugar. Por seguridad, 404 puede ser usado intencionalmente en lugar de 403 Forbidden para no revelar la existencia de recursos sensibles. Las páginas 404 deben incluir meta tag noindex para evitar que sean indexadas por motores de búsqueda. En APIs, siempre proporciona información estructurada sobre qué recurso no se encontró. Considera implementar logging de 404s para detectar enlaces rotos o problemas de integración.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712940/404_xr4mgz.png",
                "alt": "Imagen que representa el nombre del código 404 Not Found"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712638/29-removebg-preview_pml3fe.png",
                "alt": "Imagen del código 404 Not Found"
            }
        ]
    },
    {
        "code": 405,
        "status": "Method Not Allowed",
        "category": "Client Error",
        "description": "El código 405 Method Not Allowed indica que el servidor reconoce el método HTTP utilizado en la solicitud (GET, POST, PUT, DELETE, PATCH, etc.), pero ese método específico no está permitido para el recurso solicitado. Es crucial entender que esto es diferente de 404 Not Found: con 405, el recurso SÍ existe y fue encontrado, pero el método HTTP que estás intentando usar sobre ese recurso no está soportado o permitido. El servidor está diciendo: 'Conozco este recurso y existe, pero no puedes usar ese método HTTP en él'. Por ejemplo, si tienes un endpoint de API de solo lectura en /api/statistics, podrías permitir GET pero no POST, PUT o DELETE. Si un cliente intenta hacer POST a ese endpoint, recibiría 405. La respuesta 405 DEBE incluir un encabezado Allow que liste los métodos HTTP que SÍ son permitidos para ese recurso. Este encabezado es obligatorio según la especificación HTTP y proporciona información valiosa al cliente sobre cómo interactuar correctamente con el recurso. Por ejemplo: 'Allow: GET, HEAD, OPTIONS'. Las causas comunes de 405 incluyen: intentar usar POST en un endpoint que solo acepta GET, intentar modificar (PUT/PATCH) o eliminar (DELETE) un recurso de solo lectura, usar métodos no implementados en endpoints específicos, o violar restricciones de seguridad que permiten solo ciertos métodos. El código 405 es fundamental en el diseño de APIs RESTful donde diferentes recursos tienen diferentes conjuntos de operaciones permitidas. Por ejemplo, un endpoint de listado podría solo permitir GET, mientras que un endpoint de recurso individual podría permitir GET, PUT, PATCH, DELETE pero no POST. Es importante distinguir 405 de otros códigos: 404 significa que el recurso no existe; 403 significa que existe pero no tienes permiso; 405 significa que existe, puedes tener permiso, pero el método que intentas usar no es válido para este recurso. Las implementaciones bien diseñadas también responden correctamente a solicitudes OPTIONS, que son usadas por navegadores en CORS preflight para descubrir qué métodos están permitidos.",
        "useCases": [
            "Intentar POST en un endpoint de solo lectura que solo acepta GET",
            "Intentar DELETE en un recurso que no puede ser eliminado",
            "Intentar PUT/PATCH en un recurso inmutable o de solo lectura",
            "Usar métodos HTTP no implementados en endpoints específicos de API",
            "Intentar modificar recursos del sistema que son configurables solo por administradores",
            "Endpoints que solo permiten operaciones de consulta (GET) pero no modificaciones",
            "Recursos que solo permiten creación (POST) pero no actualizaciones individuales",
            "Violación de restricciones de diseño REST donde ciertos recursos solo soportan subconjuntos de métodos",
            "Intentar usar métodos HTTP personalizados o no estándar no soportados por el servidor"
        ],
        "examples": [
            {
                "scenario": "Intentar POST en endpoint de solo lectura",
                "request": "POST /api/statistics/daily-summary HTTP/1.1\nHost: analytics.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"date\": \"2024-01-16\",\n  \"views\": 5000\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"The POST method is not allowed for this resource\",\n  \"requested_method\": \"POST\",\n  \"requested_resource\": \"/api/statistics/daily-summary\",\n  \"allowed_methods\": [\"GET\", \"HEAD\", \"OPTIONS\"],\n  \"reason\": \"This is a read-only statistics endpoint. Data is automatically generated and cannot be manually posted.\",\n  \"alternatives\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"Retrieve daily statistics summary\",\n      \"example\": \"GET /api/statistics/daily-summary?date=2024-01-16\"\n    }\n  ],\n  \"documentation\": \"https://docs.analytics.example.com/api/statistics\"\n}",
                "explanation": "El endpoint de estadísticas es de solo lectura porque los datos son generados automáticamente por el sistema. El cliente intentó usar POST para crear datos manualmente, lo cual no está permitido. El encabezado Allow indica que solo GET, HEAD y OPTIONS son válidos."
            },
            {
                "scenario": "Intentar DELETE en recurso no eliminable",
                "request": "DELETE /api/system/configuration/core-settings HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, PUT, PATCH, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"DELETE method is not allowed on core system settings\",\n  \"requested_method\": \"DELETE\",\n  \"resource_type\": \"system_configuration\",\n  \"allowed_methods\": [\"GET\", \"PUT\", \"PATCH\", \"OPTIONS\"],\n  \"reason\": \"Core settings cannot be deleted as they are required for system operation. They can only be viewed or modified.\",\n  \"allowed_operations\": [\n    {\n      \"method\": \"GET\",\n      \"description\": \"View current core settings\"\n    },\n    {\n      \"method\": \"PUT\",\n      \"description\": \"Replace all core settings\"\n    },\n    {\n      \"method\": \"PATCH\",\n      \"description\": \"Update specific core settings\"\n    }\n  ],\n  \"warning\": \"Modifying core settings requires administrator privileges and can affect system stability\"\n}",
                "explanation": "Las configuraciones centrales del sistema no pueden ser eliminadas porque son esenciales para el funcionamiento del sistema. Solo pueden ser leídas o modificadas. El método DELETE no tiene sentido para este recurso."
            },
            {
                "scenario": "Intentar PUT en endpoint de colección que solo acepta POST",
                "request": "PUT /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"name\": \"New Product\",\n  \"price\": 29.99,\n  \"category\": \"electronics\"\n}",
                "response": "HTTP/1.1 405 Method Not Allowed\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n  \"error\": \"method_not_allowed\",\n  \"message\": \"PUT method is not allowed on the products collection endpoint\",\n  \"requested_method\": \"PUT\",\n  \"requested_resource\": \"/api/products\",\n  \"allowed_methods\": [\"GET\", \"POST\", \"HEAD\", \"OPTIONS\"],\n  \"explanation\": \"PUT is used to update specific resources, not collections. To create a new product, use POST. To update an existing product, use PUT on /api/products/{id}\",\n  \"correct_usage\": [\n    {\n      \"operation\": \"Create new product\",\n      \"method\": \"POST\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"POST /api/products with product data in body\"\n    },\n    {\n      \"operation\": \"Update existing product\",\n      \"method\": \"PUT\",\n      \"endpoint\": \"/api/products/{id}\",\n      \"example\": \"PUT /api/products/123 with updated product data\"\n    },\n    {\n      \"operation\": \"List all products\",\n      \"method\": \"GET\",\n      \"endpoint\": \"/api/products\",\n      \"example\": \"GET /api/products?page=1&limit=20\"\n    }\n  ]\n}",
                "explanation": "Según principios REST, PUT se usa en recursos individuales específicos, no en colecciones. Para crear un producto, debe usar POST en /api/products. Para actualizar un producto específico, debe usar PUT en /api/products/{id}."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.5",
        "relatedHeaders": [
            "Allow"
        ],
        "relatedCodes": [
            501
        ],
        "technicalNotes": "405 es diferente de 501 Not Implemented: 405 significa que el servidor soporta el método en general pero no para este recurso específico; 501 significa que el servidor no implementa ese método en absoluto. La respuesta 405 DEBE incluir el encabezado Allow listando los métodos permitidos. Este encabezado es obligatorio según RFC 7231. Las solicitudes OPTIONS deben ser manejadas apropiadamente para CORS preflight, respondiendo con los métodos permitidos. En diseño REST: colecciones típicamente permiten GET y POST; recursos individuales permiten GET, PUT, PATCH, DELETE. No confundir con 403 (tienes permiso pero no autorización) o 404 (recurso no existe).",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712942/405_iq06kt.png",
                "alt": "Imagen que representa el nombre del código 405 Method Not Allowed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712634/30-removebg-preview_mns9bp.png",
                "alt": "Imagen del código 405 Method Not Allowed"
            }
        ]
    },
    {
        "code": 406,
        "status": "Not Acceptable",
        "category": "Client Error",
        "description": "El código 406 Not Acceptable indica que el servidor no puede producir una respuesta que coincida con los criterios de aceptabilidad especificados en los encabezados de la solicitud del cliente, particularmente los encabezados Accept, Accept-Charset, Accept-Encoding, y Accept-Language. Este código es parte del mecanismo de negociación de contenido (content negotiation) en HTTP. Cuando un cliente envía una solicitud, puede especificar qué tipos de contenido acepta mediante estos encabezados. Por ejemplo, un cliente podría decir 'Accept: application/json' indicando que solo puede procesar respuestas en formato JSON. Si el servidor solo puede proporcionar el recurso en formato XML, debe responder con 406 indicando que no puede satisfacer los requisitos del cliente. El servidor está diciendo: 'Tengo el recurso que solicitaste, pero no puedo entregártelo en ninguno de los formatos que me dijiste que aceptas'. Es importante notar que 406 es relativamente raro en la práctica web moderna porque la mayoría de los servidores simplemente ignoran parcial o totalmente las preferencias del cliente cuando no pueden satisfacerlas, y envían una respuesta en un formato por defecto (usualmente con código 200). Sin embargo, en APIs estrictamente diseñadas y sistemas que implementan negociación de contenido rigurosa, 406 es la respuesta correcta cuando hay una incompatibilidad irreconciliable. Los escenarios incluyen: un cliente que solo acepta JSON pero el servidor solo produce XML, un cliente que requiere compresión gzip pero el servidor no la soporta, un cliente que solicita un idioma específico que no está disponible, o un cliente que requiere un conjunto de caracteres no soportado por el servidor. La respuesta 406 puede incluir una lista de las representaciones disponibles para ayudar al cliente a reformular su solicitud, aunque esto no es obligatorio. Es crucial distinguir 406 de 415 Unsupported Media Type: 415 se refiere al Content-Type que el cliente ENVÍA en el cuerpo de la solicitud, mientras que 406 se refiere a lo que el cliente especifica que puede ACEPTAR en la respuesta.",
        "useCases": [
            "Cliente solicita JSON pero servidor solo puede producir XML",
            "Cliente requiere codificación de caracteres no soportada por el servidor",
            "Cliente solicita idioma específico no disponible",
            "Cliente requiere compresión específica no implementada en servidor",
            "APIs estrictas donde formato de respuesta debe coincidir exactamente con Accept header",
            "Cliente especifica calidad de media type que servidor no puede satisfacer",
            "Negociación de contenido falla completamente sin formato común",
            "Cliente requiere nivel de detalle o versión de API no disponible"
        ],
        "examples": [
            {
                "scenario": "Cliente requiere JSON pero servidor solo produce XML",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAuthorization: Bearer valid_token",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"not_acceptable\",\n  \"message\": \"The requested resource cannot be provided in the requested format\",\n  \"requested_formats\": [\"application/json\"],\n  \"available_formats\": [\n    {\n      \"content_type\": \"application/xml\",\n      \"description\": \"XML representation\",\n      \"example_request\": \"Accept: application/xml\"\n    },\n    {\n      \"content_type\": \"text/xml\",\n      \"description\": \"Plain XML\",\n      \"example_request\": \"Accept: text/xml\"\n    }\n  ],\n  \"suggestion\": \"Please modify your Accept header to one of the available formats\",\n  \"documentation\": \"https://api.example.com/docs/content-negotiation\"\n}",
                "explanation": "El cliente especificó que solo acepta JSON (Accept: application/json), pero este servidor legacy solo puede producir XML. Como no hay un formato común, el servidor responde con 406 y lista los formatos disponibles."
            },
            {
                "scenario": "Idioma solicitado no disponible",
                "request": "GET /api/content/article-123 HTTP/1.1\nHost: content.example.com\nAccept: application/json\nAccept-Language: ja-JP",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\nContent-Language: en-US\n\n{\n  \"error\": \"language_not_available\",\n  \"message\": \"The requested content is not available in the requested language\",\n  \"requested_language\": \"ja-JP\",\n  \"available_languages\": [\n    {\n      \"code\": \"en-US\",\n      \"name\": \"English (United States)\",\n      \"is_default\": true\n    },\n    {\n      \"code\": \"es-ES\",\n      \"name\": \"Spanish (Spain)\"\n    },\n    {\n      \"code\": \"fr-FR\",\n      \"name\": \"French (France)\"\n    },\n    {\n      \"code\": \"de-DE\",\n      \"name\": \"German (Germany)\"\n    }\n  ],\n  \"suggestion\": \"Try requesting with Accept-Language: en-US, es-ES, fr-FR, or de-DE\",\n  \"note\": \"If no Accept-Language header is provided, content will be served in English (default)\"\n}",
                "explanation": "El cliente solicitó contenido en japonés (ja-JP), pero ese idioma no está disponible para este recurso. El servidor lista los idiomas disponibles para ayudar al cliente a hacer una solicitud válida."
            },
            {
                "scenario": "Codificación de caracteres no soportada",
                "request": "GET /api/legacy-data HTTP/1.1\nHost: api.example.com\nAccept: text/plain\nAccept-Charset: ISO-8859-1",
                "response": "HTTP/1.1 406 Not Acceptable\nContent-Type: application/json\n\n{\n  \"error\": \"charset_not_supported\",\n  \"message\": \"The requested character encoding is not supported\",\n  \"requested_charset\": \"ISO-8859-1\",\n  \"available_charsets\": [\n    {\n      \"charset\": \"UTF-8\",\n      \"description\": \"Unicode UTF-8 (recommended)\",\n      \"is_default\": true\n    },\n    {\n      \"charset\": \"UTF-16\",\n      \"description\": \"Unicode UTF-16\"\n    }\n  ],\n  \"recommendation\": \"Use Accept-Charset: UTF-8 or omit the header to receive UTF-8 by default\",\n  \"reason\": \"Modern APIs exclusively use Unicode encodings for better international character support\"\n}",
                "explanation": "El cliente solicitó codificación ISO-8859-1 (Latin-1), pero el servidor moderno solo soporta Unicode (UTF-8 y UTF-16). Se recomienda al cliente usar UTF-8 que es el estándar actual."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.6",
        "relatedHeaders": [
            "Accept",
            "Accept-Charset",
            "Accept-Encoding",
            "Accept-Language",
            "Content-Type"
        ],
        "relatedCodes": [
            415
        ],
        "technicalNotes": "406 se refiere a negociación de contenido proactiva basada en lo que el cliente puede ACEPTAR (headers Accept-*). No confundir con 415 Unsupported Media Type que se refiere al Content-Type que el cliente ENVÍA. En la práctica, 406 es raro porque muchos servidores ignoran parcialmente las preferencias del cliente y envían un formato por defecto con 200. Usar 406 indica una implementación estricta de content negotiation. La respuesta puede incluir lista de representaciones disponibles, aunque no es obligatorio. Si el servidor puede producir múltiples formatos pero ninguno coincide con Accept, debe responder 406, no elegir arbitrariamente uno.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768712944/406_dlslce.png",
                "alt": "Imagen que representa el nombre del código 406 Not Acceptable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768712632/31-removebg-preview_glqv2u.png",
                "alt": "Imagen del código 406 Not Acceptable"
            }
        ]
    },
    {
        "code": 407,
        "status": "Proxy Authentication Required",
        "category": "Client Error",
        "description": "El código 407 Proxy Authentication Required es similar al 401 Unauthorized, pero indica específicamente que el cliente debe autenticarse primero con un servidor proxy antes de que la solicitud pueda ser procesada. Este código es utilizado en escenarios donde la comunicación entre el cliente y el servidor final debe pasar a través de un proxy intermedio que requiere autenticación. El proxy está diciendo: 'Antes de que pueda reenviar tu solicitud al servidor de destino, necesitas autenticarte conmigo'. Esto es común en entornos corporativos donde todo el tráfico HTTP/HTTPS debe pasar por un proxy corporativo que implementa políticas de seguridad, filtrado de contenido, o logging. La respuesta 407 DEBE incluir un encabezado Proxy-Authenticate que especifica el esquema de autenticación que el proxy requiere, similar a cómo 401 usa WWW-Authenticate. Los esquemas comunes incluyen Basic, Digest, NTLM (en entornos Windows/Active Directory), o esquemas personalizados. Cuando un cliente recibe un 407, debe reenviar la solicitud incluyendo un encabezado Proxy-Authorization con las credenciales apropiadas para el proxy. Es importante distinguir entre autenticación de proxy (407) y autenticación de servidor final (401): puede haber escenarios donde ambas son necesarias, primero autenticándose con el proxy (407) y luego con el servidor de destino (401). El código 407 es transparente para muchas aplicaciones modernas porque los navegadores y librerías HTTP manejan automáticamente la autenticación de proxy usando credenciales configuradas a nivel de sistema operativo o aplicación. En entornos empresariales, es común que los administradores configuren credenciales de proxy a nivel de sistema para que todas las aplicaciones puedan usarlas automáticamente. Los proxies pueden requerir autenticación por varias razones: control de acceso y seguridad, rastreo de uso por usuario o departamento, implementación de políticas de uso aceptable, prevención de uso no autorizado de recursos de red, o cumplimiento de requisitos regulatorios. En APIs y aplicaciones server-to-server, manejar 407 correctamente es crucial para funcionar en entornos corporativos donde los proxies son obligatorios.",
        "useCases": [
            "Proxies corporativos que requieren autenticación de empleados",
            "Proxies de red que implementan control de acceso",
            "Proxies de filtrado de contenido en instituciones educativas",
            "Proxies que rastrean y registran uso de internet por usuario",
            "Proxies de caché que requieren identificación de usuarios",
            "Proxies que implementan políticas de uso aceptable",
            "Gateways de seguridad que validan identidad antes de permitir tráfico externo",
            "Proxies que aplican límites de ancho de banda por usuario autenticado"
        ],
        "examples": [
            {
                "scenario": "Proxy corporativo requiere autenticación Basic",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nAccept: application/json",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: Basic realm=\"Corporate Proxy\"\nProxy-Connection: close\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>Proxy Authentication Required</title></head>\n<body>\n  <h1>407 Proxy Authentication Required</h1>\n  <p>This request must be authenticated with the corporate proxy before it can be forwarded.</p>\n  <p>Please configure your application with valid proxy credentials.</p>\n  <p>Contact IT Support if you need assistance: support@company.com</p>\n</body>\n</html>",
                "explanation": "Un proxy corporativo interceptó la solicitud al servidor externo. Antes de reenviar la solicitud, requiere que el cliente se autentique usando credenciales corporativas con esquema Basic authentication. El cliente debe reenviar con encabezado Proxy-Authorization."
            },
            {
                "scenario": "Solicitud correcta con autenticación de proxy",
                "request": "GET https://external-api.example.com/data HTTP/1.1\nHost: external-api.example.com\nProxy-Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\nAccept: application/json",
                "response": "HTTP/1.1 200 OK\nContent-Type: application/json\nVia: 1.1 corporate-proxy.company.com\n\n{\n  \"message\": \"Request successfully forwarded through authenticated proxy\",\n  \"data\": {\n    \"user\": \"authenticated_user\",\n    \"proxy\": \"corporate-proxy.company.com\",\n    \"result\": \"success\"\n  }\n}",
                "explanation": "Después de recibir 407, el cliente reenvió la solicitud incluyendo el encabezado Proxy-Authorization con credenciales válidas. El proxy validó las credenciales y reenvió la solicitud al servidor de destino, que respondió exitosamente. El encabezado Via indica que pasó por el proxy."
            },
            {
                "scenario": "Proxy con autenticación NTLM (entorno Windows)",
                "request": "GET http://internet-resource.example.com/page HTTP/1.1\nHost: internet-resource.example.com",
                "response": "HTTP/1.1 407 Proxy Authentication Required\nProxy-Authenticate: NTLM\nProxy-Authenticate: Negotiate\nContent-Type: application/json\n\n{\n  \"error\": \"proxy_authentication_required\",\n  \"message\": \"Authentication with the corporate proxy is required\",\n  \"proxy_server\": \"proxy.corporate.local\",\n  \"authentication_methods\": [\n    {\n      \"method\": \"NTLM\",\n      \"description\": \"Windows integrated authentication\",\n      \"automatic\": true,\n      \"note\": \"Your Windows credentials will be used automatically if configured\"\n    },\n    {\n      \"method\": \"Negotiate\",\n      \"description\": \"Kerberos/NTLM negotiation\",\n      \"automatic\": true\n    }\n  ],\n  \"help\": \"If automatic authentication fails, contact IT: it-support@corporate.local\",\n  \"documentation\": \"https://intranet.corporate.local/proxy-setup\"\n}",
                "explanation": "Un proxy en entorno Windows corporativo ofrece autenticación NTLM y Negotiate (Kerberos). Estos esquemas típicamente usan las credenciales de dominio del usuario de Windows automáticamente, sin requerir entrada manual de credenciales."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7235, Section 3.2",
        "relatedHeaders": [
            "Proxy-Authenticate",
            "Proxy-Authorization",
            "Via",
            "Proxy-Connection"
        ],
        "relatedCodes": [
            401
        ],
        "technicalNotes": "407 es específico para autenticación de PROXY, no del servidor final. Similar a como 401 requiere WWW-Authenticate, 407 DEBE incluir Proxy-Authenticate. El cliente responde con Proxy-Authorization (no Authorization). Es posible recibir tanto 407 como 401 en secuencia: primero autenticarse con proxy, luego con servidor destino. Los navegadores modernos manejan 407 automáticamente usando credenciales de proxy configuradas. En aplicaciones, las librerías HTTP típicamente soportan configuración de proxy con credenciales. NTLM y Negotiate son comunes en entornos Windows/Active Directory. El encabezado Via indica proxies por los que pasó la solicitud.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752638/407_wyw0bl.png",
                "alt": "Imagen que representa el nombre del código 407 Proxy Authentication Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752254/32-removebg-preview_ww1jb2.png",
                "alt": "Imagen del código 407 Proxy Authentication Required"
            }
        ]
    },
    {
        "code": 408,
        "status": "Request Timeout",
        "category": "Client Error",
        "description": "El código 408 Request Timeout indica que el servidor decidió cerrar la conexión porque el cliente no produjo una solicitud completa dentro del tiempo que el servidor estaba preparado para esperar. Este código se utiliza cuando un cliente establece una conexión con el servidor pero tarda demasiado tiempo en enviar la solicitud HTTP completa, o cuando hay períodos de inactividad prolongados durante la transmisión de la solicitud. El servidor está diciendo: 'Estableciste una conexión conmigo, pero tardaste demasiado en enviar tu solicitud completa, así que voy a cerrar la conexión'. Es importante entender que 408 se refiere al tiempo de espera durante la RECEPCIÓN de la solicitud, no durante el PROCESAMIENTO de la misma. Si el servidor recibe la solicitud completa pero tarda mucho en procesarla, eso sería un problema diferente (potencialmente 504 Gateway Timeout si hay un proxy/gateway involucrado). Las causas comunes de 408 incluyen: conexiones de red lentas o inestables donde los datos se transmiten muy lentamente, clientes que establecen conexiones pero no envían datos (posiblemente por bugs), problemas de firewall o proxy que interrumpen la transmisión de datos, clientes que pausan o se quedan en espera durante la construcción de la solicitud, o ataques de denegación de servicio de tipo slowloris donde los atacantes mantienen conexiones abiertas enviando datos muy lentamente para agotar recursos del servidor. Los servidores implementan timeouts de solicitud como mecanismo de seguridad y gestión de recursos para evitar que conexiones ociosas o lentas consuman recursos indefinidamente. Los valores típicos de timeout varían desde 30 segundos hasta varios minutos dependiendo de la configuración del servidor y el caso de uso. La respuesta 408 puede incluir un encabezado Connection: close indicando que el servidor está cerrando la conexión. Los clientes que reciben 408 pueden reintentar la solicitud, pero deberían investigar por qué la solicitud original fue tan lenta. En aplicaciones modernas, 408 es relativamente raro porque las redes y clientes son generalmente rápidos, pero puede ocurrir en conexiones móviles inestables, uploads de archivos grandes interrumpidos, o situaciones de red degradada.",
        "useCases": [
            "Cliente con conexión de red muy lenta que tarda demasiado en enviar solicitud",
            "Cliente que establece conexión pero no envía datos por bug o error de implementación",
            "Uploads de archivos grandes interrumpidos o extremadamente lentos",
            "Conexiones móviles inestables con pérdida de paquetes y retransmisiones",
            "Problemas de firewall o proxy que causan pausas prolongadas en transmisión",
            "Ataques slowloris u otros ataques de DoS basados en conexiones lentas",
            "Cliente que pausa durante construcción de payload muy grande",
            "Timeout de keep-alive en conexiones HTTP persistentes sin actividad"
        ],
        "examples": [
            {
                "scenario": "Cliente tarda demasiado en enviar solicitud completa",
                "request": "POST /api/upload HTTP/1.1\nHost: api.example.com\nContent-Type: multipart/form-data\nContent-Length: 104857600\n\n[cliente envía datos muy lentamente, solo 10% después de 60 segundos]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nContent-Type: application/json\n\n{\n  \"error\": \"request_timeout\",\n  \"message\": \"The server timed out waiting for the complete request\",\n  \"timeout_duration\": \"60 seconds\",\n  \"bytes_received\": 10485760,\n  \"bytes_expected\": 104857600,\n  \"percentage_received\": \"10%\",\n  \"reason\": \"Request transmission too slow or interrupted\",\n  \"suggestion\": \"Check your network connection and retry the upload\",\n  \"retry_recommended\": true,\n  \"max_upload_time\": \"300 seconds for files up to 100MB\"\n}",
                "explanation": "El cliente comenzó a subir un archivo de 100MB pero la transmisión fue extremadamente lenta. Después de 60 segundos, solo se recibió el 10% de los datos. El servidor cerró la conexión para liberar recursos. El cliente debe verificar su conexión y reintentar."
            },
            {
                "scenario": "Conexión establecida pero sin datos enviados",
                "request": "[TCP connection established]\n[30 seconds pass with no HTTP request sent]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head><title>408 Request Timeout</title></head>\n<body>\n  <h1>408 Request Timeout</h1>\n  <p>The server closed this connection because no request was received within the expected time.</p>\n  <p>Connection was established but no data was sent for 30 seconds.</p>\n  <p>This may indicate a client-side error or network issue.</p>\n  <p>Please check your application and network connection.</p>\n</body>\n</html>",
                "explanation": "El cliente estableció una conexión TCP con el servidor pero no envió ninguna solicitud HTTP durante 30 segundos. Esto podría indicar un bug en el cliente, un problema de red, o un intento de ataque slowloris. El servidor cierra la conexión."
            },
            {
                "scenario": "Timeout de keep-alive en conexión persistente",
                "request": "[Previous request completed successfully]\n[HTTP persistent connection kept alive]\n[No new request for 120 seconds]",
                "response": "HTTP/1.1 408 Request Timeout\nConnection: close\nKeep-Alive: timeout=120, max=100\nContent-Type: application/json\n\n{\n  \"error\": \"keepalive_timeout\",\n  \"message\": \"Persistent connection timed out due to inactivity\",\n  \"connection_type\": \"HTTP/1.1 persistent (keep-alive)\",\n  \"inactive_duration\": \"120 seconds\",\n  \"keepalive_timeout\": \"120 seconds\",\n  \"requests_on_connection\": 5,\n  \"max_requests_per_connection\": 100,\n  \"action\": \"Connection closed. Establish new connection for additional requests.\",\n  \"note\": \"This is normal behavior for idle persistent connections\"\n}",
                "explanation": "En una conexión HTTP/1.1 persistente (keep-alive), el cliente no envió una nueva solicitud durante 120 segundos después de la última respuesta. El servidor cierra la conexión idle para liberar recursos. El cliente puede establecer una nueva conexión si necesita hacer más solicitudes."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.7",
        "relatedHeaders": [
            "Connection",
            "Keep-Alive",
            "Timeout"
        ],
        "relatedCodes": [
            504
        ],
        "technicalNotes": "408 se refiere al timeout durante la RECEPCIÓN de la solicitud (cliente → servidor), no durante el procesamiento. No confundir con 504 Gateway Timeout que es para timeouts de servidor upstream durante procesamiento. La respuesta 408 típicamente incluye Connection: close porque el servidor está cerrando la conexión. Los clientes PUEDEN reintentar automáticamente solicitudes que reciben 408, pero deben implementar backoff exponencial. Los timeouts típicos varían: 30-60 segundos para solicitudes normales, 5-10 minutos para uploads grandes. Los servidores modernos configuran timeouts para: prevenir ataques DoS slowloris, liberar recursos de conexiones idle, optimizar uso de recursos. 408 es relativamente raro en aplicaciones web modernas con conexiones rápidas.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/408_w91uv5.png",
                "alt": "Imagen que representa el nombre del código 408 Request Timeout"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752253/33-removebg-preview_ogidrb.png",
                "alt": "Imagen del código 408 Request Timeout"
            }
        ]
    },
    {
        "code": 409,
        "status": "Conflict",
        "category": "Client Error",
        "description": "El código 409 Conflict indica que la solicitud no pudo ser completada debido a un conflicto con el estado actual del recurso en el servidor. Este código señala que existe una incompatibilidad o contradicción entre lo que el cliente está intentando hacer y el estado actual del sistema. El servidor está diciendo: 'Entiendo lo que quieres hacer, pero no puedo hacerlo porque entraría en conflicto con algo que ya existe o con el estado actual del sistema'. Los conflictos 409 son comunes en operaciones que implican concurrencia, unicidad, o restricciones de integridad de datos. Por ejemplo, intentar crear un usuario con un email que ya está registrado, intentar actualizar un recurso que ha sido modificado por otro usuario desde que lo recuperaste (conflicto de concurrencia), intentar eliminar un recurso que tiene dependencias, intentar reservar un recurso que ya está reservado, o violar restricciones de integridad referencial en bases de datos. El código 409 es fundamental en sistemas que implementan control de concurrencia optimista, donde múltiples clientes pueden intentar modificar el mismo recurso simultáneamente. En estos casos, 409 se usa típicamente con ETags o versionado: el cliente lee un recurso con su ETag actual, intenta actualizarlo enviando el ETag que leyó, pero si otro cliente modificó el recurso mientras tanto (cambiando el ETag), el servidor responde 409 indicando un conflicto de versión. La respuesta 409 debería incluir información suficiente en el cuerpo para que el cliente entienda la naturaleza del conflicto y potencialmente pueda resolverlo. Puede incluir detalles sobre qué causó el conflicto, el estado actual del recurso, y posibles acciones para resolver el conflicto. Es importante distinguir 409 de otros códigos: 400 es para errores de sintaxis o validación básica, 422 es para errores de validación semántica donde la sintaxis es correcta pero los datos no tienen sentido, y 409 es específicamente para conflictos con el estado actual del sistema. El 409 implica que la solicitud podría tener éxito en el futuro si el estado conflictivo cambia.",
        "useCases": [
            "Intentar crear usuario con email o username que ya existe",
            "Conflictos de concurrencia en actualizaciones simultáneas (violación de ETag/versión)",
            "Intentar eliminar recurso que tiene dependencias (foreign key constraints)",
            "Reservar recurso que ya está reservado por otro usuario",
            "Duplicación de transacciones o pedidos",
            "Intentar crear recurso con identificador único que ya existe",
            "Violación de reglas de negocio que dependen del estado actual",
            "Conflictos en sistemas de control de versiones o merge de datos",
            "Intentar aplicar cambios incompatibles con el estado actual del workflow"
        ],
        "examples": [
            {
                "scenario": "Email duplicado al crear usuario",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"password\": \"securepass123\"\n}",
                "response": "HTTP/1.1 409 Conflict\nContent-Type: application/json\n\n{\n  \"error\": \"resource_conflict\",\n  \"message\": \"A user with this email address already exists\",\n  \"conflict_type\": \"duplicate_email\",\n  \"conflicting_field\": \"email\",\n  \"conflicting_value\": \"john@example.com\",\n  \"existing_user_id\": \"user_12345\",\n  \"created_at\": \"2023-06-15T10:30:00Z\",\n  \"suggestions\": [\n    \"Use a different email address\",\n    \"If this is your account, try logging in instead\",\n    \"Use the password reset feature if you forgot your password\"\n  ],\n  \"login_url\": \"/auth/login\",\n  \"password_reset_url\": \"/auth/forgot-password\"\n}",
                "explanation": "El cliente intentó crear un nuevo usuario con un email que ya está registrado en el sistema. Esto viola la restricción de unicidad del email. El servidor responde con 409 indicando el conflicto y sugiriendo acciones alternativas."
            },
            {
                "scenario": "Conflicto de concurrencia con ETag",
                "request": "PUT /api/documents/789 HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nIf-Match: \"version-abc123\"\n\n{\n  \"title\": \"Updated Title\",\n  \"content\": \"Updated content...\",\n  \"status\": \"published\"\n}",
                "response": "HTTP/1.1 409 Conflict\nETag: \"version-xyz789\"\nContent-Type: application/json\n\n{\n  \"error\": \"version_conflict\",\n  \"message\": \"The document has been modified by another user\",\n  \"conflict_type\": \"concurrent_modification\",\n  \"your_version\": \"version-abc123\",\n  \"current_version\": \"version-xyz789\",\n  \"last_modified_by\": \"user_456\",\n  \"last_modified_at\": \"2024-01-16T14:25:00Z\",\n  \"resolution_options\": [\n    {\n      \"option\": \"fetch_latest\",\n      \"description\": \"Get the latest version and manually merge your changes\",\n      \"endpoint\": \"GET /api/documents/789\"\n    },\n    {\n      \"option\": \"force_overwrite\",\n      \"description\": \"Overwrite with your version (will lose other user's changes)\",\n      \"warning\": \"This will discard changes made by user_456\",\n      \"not_recommended\": true\n    }\n  ],\n  \"current_document_url\": \"/api/documents/789\"\n}",
                "explanation": "El cliente intentó actualizar el documento usando un ETag antiguo (version-abc123). Otro usuario ya modificó el documento, cambiando el ETag a version-xyz789. Esto indica un conflicto de concurrencia. El cliente debe obtener la versión actual y decidir cómo resolver el conflicto."
            },
            {
                "scenario": "Eliminar recurso con dependencias",
                "request": "DELETE /api/categories/5 HTTP/1.1\nHost: shop.example.com\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 409 Conflict\nContent-Type: application/json\n\n{\n  \"error\": \"cannot_delete_resource\",\n  \"message\": \"Cannot delete category because it has dependent resources\",\n  \"conflict_type\": \"referential_integrity\",\n  \"category_id\": 5,\n  \"category_name\": \"Electronics\",\n  \"dependent_resources\": [\n    {\n      \"resource_type\": \"products\",\n      \"count\": 47,\n      \"description\": \"47 products are currently assigned to this category\"\n    },\n    {\n      \"resource_type\": \"subcategories\",\n      \"count\": 3,\n      \"description\": \"3 subcategories exist under this category\"\n    }\n  ],\n  \"resolution_steps\": [\n    \"1. Reassign all 47 products to different categories\",\n    \"2. Delete or reassign the 3 subcategories\",\n    \"3. Then retry deleting this category\"\n  ],\n  \"bulk_reassign_endpoint\": \"/api/categories/5/reassign-products\",\n  \"view_products_url\": \"/api/products?category=5\",\n  \"view_subcategories_url\": \"/api/categories?parent=5\"\n}",
                "explanation": "El administrador intentó eliminar una categoría, pero hay 47 productos y 3 subcategorías que dependen de ella. Eliminarla violaría la integridad referencial. El servidor responde con 409 y proporciona pasos claros para resolver el conflicto."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.8",
        "relatedHeaders": [
            "ETag",
            "If-Match",
            "If-None-Match"
        ],
        "relatedCodes": [
            400,
            422
        ],
        "technicalNotes": "409 es específicamente para conflictos con el ESTADO ACTUAL del recurso, no para errores de validación básica. Diferencias clave: 400 para errores de sintaxis/formato; 422 para validación semántica (datos bien formados pero no válidos); 409 para conflictos con estado existente. Común en control de concurrencia optimista usando ETags: el cliente incluye If-Match con el ETag que conoce, si cambió el servidor responde 409. La respuesta debe explicar claramente QUÉ está en conflicto y CÓMO resolverlo. 409 implica que la operación podría tener éxito si el estado conflictivo cambia. En REST, usar 409 para duplicados, violaciones de unicidad, y conflictos de concurrencia.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/409_wgclol.png",
                "alt": "Imagen que representa el nombre del código 409 Conflict"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752251/34-removebg-preview_caqa9i.png",
                "alt": "Imagen del código 409 Conflict"
            }
        ]
    },
    {
        "code": 410,
        "status": "Gone",
        "category": "Client Error",
        "description": "El código 410 Gone indica que el recurso solicitado ya no está disponible en el servidor y que esta condición es permanente, sin dirección de reenvío conocida. Este código es similar al 404 Not Found, pero proporciona información semántica adicional importante: 410 específicamente comunica que el recurso EXISTIÓ anteriormente pero ha sido INTENCIONALMENTE y PERMANENTEMENTE eliminado. El servidor está diciendo: 'Este recurso existía aquí antes, pero lo hemos eliminado deliberadamente y no volverá, y no hay una nueva ubicación para él'. La distinción clave entre 410 y 404 es: 404 significa 'no puedo encontrar esto' (puede que nunca haya existido, puede que haya sido movido, puede que sea temporal), mientras que 410 significa 'esto definitivamente existió aquí pero fue eliminado permanentemente de forma intencional'. El código 410 es útil para varias situaciones: contenido que fue publicado pero posteriormente retirado (artículos eliminados, productos descontinuados, páginas obsoletas), recursos que expiraron y fueron limpiados (cupones de descuento vencidos, promociones terminadas, enlaces de un solo uso consumidos), cuentas de usuario eliminadas permanentemente, o archivos que fueron removidos por violaciones de políticas. Usar 410 en lugar de 404 es beneficioso por varias razones: ayuda a los motores de búsqueda a entender que deben eliminar permanentemente la página de sus índices en lugar de seguir rastreándola esperando que regrese, informa a sistemas de caché que pueden purgar permanentemente el recurso, y proporciona mejor información a desarrolladores y usuarios sobre por qué el contenido no está disponible. Los motores de búsqueda como Google tratan 410 de manera diferente que 404: con 410, eliminan la URL de sus índices más rápidamente y dejan de rastrearla, mientras que con 404 pueden continuar verificando periódicamente si el recurso regresó. Sin embargo, en la práctica, 410 es mucho menos común que 404 porque requiere que el servidor mantenga un registro de qué recursos fueron eliminados, lo cual puede ser un overhead de mantenimiento. Muchos sitios simplemente usan 404 para todo lo que no existe, ya sea que nunca haya existido o haya sido eliminado.",
        "useCases": [
            "Artículos de blog o contenido que fue publicado pero posteriormente eliminado permanentemente",
            "Productos descontinuados en tiendas online que ya no se venderán",
            "Cuentas de usuario que fueron eliminadas permanentemente por solicitud del usuario",
            "Cupones de descuento o códigos promocionales que expiraron",
            "Enlaces de un solo uso que ya fueron consumidos (tokens de verificación, invitaciones)",
            "Contenido removido por violaciones de términos de servicio o derechos de autor",
            "Páginas web obsoletas que fueron retiradas intencionalmente sin reemplazo",
            "Recursos temporales que cumplieron su propósito y fueron limpiados",
            "Archivos subidos que fueron eliminados por el usuario propietario"
        ],
        "examples": [
            {
                "scenario": "Producto descontinuado permanentemente",
                "request": "GET /products/vintage-model-2015 HTTP/1.1\nHost: shop.example.com\nAccept: application/json",
                "response": "HTTP/1.1 410 Gone\nContent-Type: application/json\n\n{\n  \"error\": \"resource_gone\",\n  \"message\": \"This product has been permanently discontinued\",\n  \"resource_type\": \"product\",\n  \"product_id\": \"vintage-model-2015\",\n  \"product_name\": \"Vintage Model 2015\",\n  \"discontinued_date\": \"2023-12-31\",\n  \"reason\": \"Product line discontinued\",\n  \"status\": \"permanently_removed\",\n  \"alternatives\": [\n    {\n      \"product_id\": \"modern-model-2024\",\n      \"name\": \"Modern Model 2024\",\n      \"description\": \"Updated version with new features\",\n      \"url\": \"/products/modern-model-2024\"\n    },\n    {\n      \"product_id\": \"similar-alternative\",\n      \"name\": \"Similar Alternative\",\n      \"description\": \"Comparable product in same category\",\n      \"url\": \"/products/similar-alternative\"\n    }\n  ],\n  \"browse_category\": \"/categories/electronics\",\n  \"note\": \"This product will not return. Consider our alternatives above.\"\n}",
                "explanation": "El producto fue descontinuado permanentemente y no volverá a estar disponible. El código 410 informa a motores de búsqueda que deben eliminar esta URL de sus índices. Se proporcionan productos alternativos para ayudar al usuario."
            },
            {
                "scenario": "Artículo de blog eliminado permanentemente",
                "request": "GET /blog/2020/controversial-article HTTP/1.1\nHost: blog.example.com\nAccept: text/html",
                "response": "HTTP/1.1 410 Gone\nContent-Type: text/html; charset=utf-8\n\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Article Removed - Example Blog</title>\n  <meta name=\"robots\" content=\"noindex, nofollow\">\n</head>\n<body>\n  <h1>410 - Article No Longer Available</h1>\n  <p>The article you're looking for has been permanently removed.</p>\n  <div class=\"info\">\n    <h2>Why was this removed?</h2>\n    <p>This article was removed on January 15, 2024 due to outdated information that could be misleading.</p>\n    <p>We maintain high standards for content accuracy and decided to remove this rather than update it.</p>\n  </div>\n  <div class=\"alternatives\">\n    <h2>You might be interested in:</h2>\n    <ul>\n      <li><a href=\"/blog/2024/updated-perspective\">Updated Perspective on the Topic (2024)</a></li>\n      <li><a href=\"/blog/category/same-topic\">More articles on this topic</a></li>\n      <li><a href=\"/blog\">Browse all blog posts</a></li>\n    </ul>\n  </div>\n</body>\n</html>",
                "explanation": "El artículo fue removido permanentemente por contener información desactualizada. El código 410 asegura que los motores de búsqueda eliminen la página de sus índices. Se incluye meta noindex y se ofrecen alternativas relevantes."
            },
            {
                "scenario": "Token de verificación de un solo uso ya consumido",
                "request": "GET /verify-email?token=abc123xyz789used HTTP/1.1\nHost: auth.example.com",
                "response": "HTTP/1.1 410 Gone\nContent-Type: application/json\n\n{\n  \"error\": \"token_consumed\",\n  \"message\": \"This verification token has already been used\",\n  \"token_type\": \"email_verification\",\n  \"token_status\": \"consumed\",\n  \"used_at\": \"2024-01-10T09:30:00Z\",\n  \"used_by_ip\": \"192.168.1.100\",\n  \"email_status\": \"verified\",\n  \"account_email\": \"user@example.com\",\n  \"action_taken\": \"Email was successfully verified on January 10, 2024\",\n  \"next_steps\": [\n    \"Your email is already verified\",\n    \"You can now log in to your account\",\n    \"If you didn't verify this email, contact support immediately\"\n  ],\n  \"login_url\": \"/auth/login\",\n  \"support_url\": \"/support/contact\"\n}",
                "explanation": "El token de verificación de email era de un solo uso y ya fue consumido el 10 de enero. No puede ser reutilizado. El código 410 indica que este token específico está permanentemente agotado. Se proporciona información sobre cuándo fue usado y qué hacer a continuación."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.9",
        "relatedHeaders": [
            "Content-Type",
            "Cache-Control"
        ],
        "relatedCodes": [
            404
        ],
        "technicalNotes": "410 es semánticamente diferente de 404: 410 significa eliminación PERMANENTE e INTENCIONAL de algo que existió; 404 es más genérico y no implica historia. Usar 410 beneficia SEO: los motores de búsqueda eliminan URLs con 410 de índices más rápido y dejan de rastrearlas. 410 es menos común que 404 en la práctica porque requiere que el servidor mantenga registro de recursos eliminados. Si no mantienes registro de qué fue eliminado, usa 404. Para redirecciones permanentes a nuevas ubicaciones, usa 301 no 410. 410 implica que NO hay nueva ubicación. Incluye meta tag noindex en respuestas HTML. La respuesta puede cacheable a menos que se indique lo contrario.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/410_dhmn6m.png",
                "alt": "Imagen que representa el nombre del código 410 Gone"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752248/35-removebg-preview_h8zeav.png",
                "alt": "Imagen del código 410 Gone"
            }
        ]
    },
    {
        "code": 411,
        "status": "Length Required",
        "category": "Client Error",
        "description": "El código 411 Length Required indica que el servidor se niega a aceptar la solicitud sin un encabezado Content-Length definido. Este código se utiliza cuando el servidor requiere conocer el tamaño exacto del cuerpo de la solicitud antes de comenzar a procesarla, pero el cliente no proporcionó el encabezado Content-Length. El servidor está diciendo: 'Necesito saber cuántos bytes de datos vas a enviarme antes de que pueda aceptar tu solicitud'. Este requisito es importante por varias razones: permite al servidor validar que tiene suficiente espacio o recursos para manejar la solicitud completa antes de comenzar a recibirla, ayuda a prevenir ataques de denegación de servicio donde un atacante podría enviar datos infinitos, permite implementar límites de tamaño de carga apropiados, y facilita la gestión eficiente de recursos del servidor. El código 411 es común en situaciones donde el servidor necesita asignar buffers o recursos basándose en el tamaño de la solicitud, cuando implementa límites de cuota o facturación basada en volumen de datos, o cuando necesita validar restricciones de tamaño antes de procesar. Sin embargo, es importante notar que HTTP/1.1 también soporta Transfer-Encoding: chunked, que permite enviar datos sin conocer la longitud total de antemano. Algunos servidores aceptan chunked encoding como alternativa a Content-Length, pero otros requieren específicamente Content-Length y responderán con 411 si no está presente. En HTTP/2, el concepto de Content-Length es menos crítico debido a la naturaleza del protocolo, pero en HTTP/1.1 sigue siendo relevante. Las causas comunes de 411 incluyen: clientes que intentan hacer POST o PUT sin especificar Content-Length, uso de streaming o chunked encoding cuando el servidor no lo soporta, bugs en implementaciones de cliente que omiten el encabezado, o proxies que eliminan el encabezado Content-Length durante el tránsito. La solución típica es que el cliente incluya el encabezado Content-Length con el número exacto de bytes en el cuerpo de la solicitud.",
        "useCases": [
            "Servidor que requiere Content-Length para validar límites de tamaño antes de aceptar uploads",
            "APIs que implementan cuotas o facturación basada en volumen de datos",
            "Servidores que necesitan pre-asignar buffers basándose en tamaño de solicitud",
            "Sistemas que validan capacidad de almacenamiento antes de aceptar datos",
            "Prevención de ataques DoS de streaming infinito de datos",
            "Servicios que requieren conocer tamaño total para operaciones transaccionales",
            "Sistemas legacy que no soportan Transfer-Encoding: chunked",
            "Validación de límites de recursos antes de procesamiento"
        ],
        "examples": [
            {
                "scenario": "POST sin Content-Length",
                "request": "POST /api/upload HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"data\": \"some content\"\n}",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"length_required\",\n  \"message\": \"Content-Length header is required for this request\",\n  \"missing_header\": \"Content-Length\",\n  \"reason\": \"Server must know the size of the request body before processing\",\n  \"requirements\": {\n    \"header_name\": \"Content-Length\",\n    \"header_value\": \"Size in bytes of the request body\",\n    \"example\": \"Content-Length: 1024\"\n  },\n  \"max_content_length\": 10485760,\n  \"max_content_length_human\": \"10 MB\",\n  \"supported_encodings\": [\"identity\"],\n  \"chunked_encoding_supported\": false,\n  \"how_to_fix\": [\n    \"Calculate the exact size of your request body in bytes\",\n    \"Add Content-Length header with that value\",\n    \"Example: Content-Length: 27 (for the JSON body shown)\"\n  ],\n  \"documentation\": \"https://api.example.com/docs/headers\"\n}",
                "explanation": "El cliente envió una solicitud POST con un cuerpo JSON pero omitió el encabezado Content-Length. El servidor requiere este encabezado para validar el tamaño antes de procesar. El cliente debe calcular el tamaño del cuerpo (27 bytes en este caso) y agregar Content-Length: 27."
            },
            {
                "scenario": "Upload de archivo sin especificar tamaño",
                "request": "PUT /api/files/document.pdf HTTP/1.1\nHost: storage.example.com\nContent-Type: application/pdf\nAuthorization: Bearer valid_token\n\n[binary PDF data without Content-Length]",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"content_length_required\",\n  \"message\": \"File uploads require Content-Length header\",\n  \"resource\": \"/api/files/document.pdf\",\n  \"operation\": \"file_upload\",\n  \"reason\": \"Server must validate available storage space before accepting upload\",\n  \"requirements\": {\n    \"required_headers\": [\n      \"Content-Length\",\n      \"Content-Type\"\n    ],\n    \"example_request\": \"PUT /api/files/document.pdf\\nContent-Type: application/pdf\\nContent-Length: 2048576\\n\\n[file data]\"\n  },\n  \"storage_limits\": {\n    \"max_file_size\": 104857600,\n    \"max_file_size_human\": \"100 MB\",\n    \"current_quota_used\": \"45%\",\n    \"available_space\": 57671680,\n    \"available_space_human\": \"55 MB\"\n  },\n  \"note\": \"Content-Length allows us to verify sufficient storage before accepting your file\"\n}",
                "explanation": "El cliente intenta subir un archivo PDF pero no especificó Content-Length. El servidor necesita este valor para verificar que tiene suficiente espacio de almacenamiento disponible antes de comenzar a recibir el archivo potencialmente grande."
            },
            {
                "scenario": "Solicitud con chunked encoding en servidor que no lo soporta",
                "request": "POST /api/data HTTP/1.1\nHost: legacy.example.com\nTransfer-Encoding: chunked\nContent-Type: application/json\n\n5\n{\"da\n2\nta\n3\n\":1\n2\n}\n\n0\n\n",
                "response": "HTTP/1.1 411 Length Required\nContent-Type: application/json\n\n{\n  \"error\": \"content_length_required\",\n  \"message\": \"This server does not support chunked transfer encoding\",\n  \"received_encoding\": \"chunked\",\n  \"supported_encodings\": [\"identity\"],\n  \"required_header\": \"Content-Length\",\n  \"explanation\": \"This is a legacy server that requires Content-Length and does not support streaming uploads\",\n  \"solution\": [\n    \"Calculate the total size of your data before sending\",\n    \"Remove Transfer-Encoding: chunked header\",\n    \"Add Content-Length header with the exact byte count\",\n    \"Send the data in a single request body\"\n  ],\n  \"example_correct_request\": \"POST /api/data HTTP/1.1\\nContent-Type: application/json\\nContent-Length: 10\\n\\n{\\\"data\\\":1}\",\n  \"modernization_note\": \"Consider upgrading to our v2 API which supports chunked encoding: https://api-v2.example.com\"\n}",
                "explanation": "El cliente intentó usar Transfer-Encoding: chunked para enviar datos sin conocer la longitud total de antemano. Sin embargo, este servidor legacy no soporta chunked encoding y requiere específicamente el encabezado Content-Length."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.10",
        "relatedHeaders": [
            "Content-Length",
            "Transfer-Encoding"
        ],
        "relatedCodes": [
            413
        ],
        "technicalNotes": "411 requiere específicamente el encabezado Content-Length. Algunos servidores aceptan Transfer-Encoding: chunked como alternativa, pero otros no. La respuesta 411 indica que el servidor REQUIERE Content-Length. HTTP/1.1 soporta chunked encoding como alternativa donde la longitud no se conoce de antemano, pero no todos los servidores lo implementan. La diferencia con 413 Payload Too Large: 413 se usa cuando Content-Length ESTÁ presente pero el valor excede el límite; 411 se usa cuando Content-Length está AUSENTE. Para calcular Content-Length: contar bytes exactos del cuerpo de la solicitud (no caracteres, bytes). En HTTP/2, los conceptos de streaming son diferentes y 411 es menos relevante.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/411_mkptuj.png",
                "alt": "Imagen que representa el nombre del código 411 Length Required"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752246/36-removebg-preview_h9lidy.png",
                "alt": "Imagen del código 411 Length Required"
            }
        ]
    },
    {
        "code": 412,
        "status": "Precondition Failed",
        "category": "Client Error",
        "description": "El código 412 Precondition Failed indica que una o más condiciones especificadas en los encabezados de solicitud del cliente fueron evaluadas como falsas cuando fueron probadas en el servidor. Este código es fundamental para implementar control de concurrencia condicional y operaciones seguras sobre recursos. Los encabezados de precondición permiten que los clientes especifiquen condiciones que deben cumplirse para que la solicitud sea procesada. Si alguna de estas condiciones falla, el servidor responde con 412 sin realizar la operación solicitada. Los encabezados de precondición más comunes son: If-Match (la operación solo debe proceder si el ETag actual del recurso coincide con el valor especificado), If-None-Match (proceder solo si el ETag NO coincide), If-Modified-Since (proceder solo si el recurso fue modificado después de la fecha especificada), If-Unmodified-Since (proceder solo si el recurso NO fue modificado desde la fecha especificada), y If-Range (para solicitudes de rango condicionales). El código 412 es especialmente importante en el control de concurrencia optimista, donde múltiples clientes pueden leer un recurso, pero solo uno debería poder modificarlo basándose en la versión que leyó. Por ejemplo: Cliente A lee un documento con ETag 'v1', Cliente B lee el mismo documento con ETag 'v1', Cliente B actualiza el documento (ETag cambia a 'v2'), Cliente A intenta actualizar enviando If-Match: 'v1', el servidor detecta que el ETag actual es 'v2' y responde 412 Precondition Failed, indicando que el documento cambió desde que Cliente A lo leyó. Esto previene que Cliente A sobrescriba inadvertidamente los cambios de Cliente B. El código 412 también es usado en operaciones de eliminación condicional (solo eliminar si el recurso no ha sido modificado), actualizaciones parciales con PATCH (solo aplicar cambios si la versión base es la esperada), y operaciones de caché condicionales. Es importante distinguir 412 de otros códigos: 409 Conflict se usa cuando hay un conflicto con el estado del recurso pero no necesariamente relacionado con precondiciones de encabezados; 428 Precondition Required se usa cuando el servidor REQUIERE una precondición pero el cliente no proporcionó ninguna; 412 se usa cuando el cliente SÍ proporcionó una precondición pero FALLÓ la evaluación.",
        "useCases": [
            "Control de concurrencia optimista con ETags en actualizaciones",
            "Prevenir sobrescritura de cambios concurrentes en edición colaborativa",
            "Validación de versión antes de aplicar actualizaciones o parches",
            "Operaciones condicionales que solo deben ejecutarse si el recurso no cambió",
            "Eliminación segura solo si el recurso está en el estado esperado",
            "Caché condicional basado en fechas de modificación",
            "Prevenir race conditions en operaciones críticas",
            "Validación de que prerequisitos se cumplen antes de operaciones complejas"
        ],
        "examples": [
            {
                "scenario": "Control de concurrencia con If-Match fallido",
                "request": "PUT /api/documents/456 HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nIf-Match: \"version-abc123\"\nAuthorization: Bearer valid_token\n\n{\n  \"title\": \"Updated Document Title\",\n  \"content\": \"My updated content...\",\n  \"status\": \"published\"\n}",
                "response": "HTTP/1.1 412 Precondition Failed\nETag: \"version-xyz789\"\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_failed\",\n  \"message\": \"The resource has been modified since you last retrieved it\",\n  \"precondition_type\": \"if_match\",\n  \"your_etag\": \"version-abc123\",\n  \"current_etag\": \"version-xyz789\",\n  \"last_modified\": \"2024-01-16T15:30:00Z\",\n  \"last_modified_by\": \"user_789\",\n  \"explanation\": \"Another user modified this document after you retrieved it. Your changes cannot be applied to avoid overwriting their work.\",\n  \"resolution_options\": [\n    {\n      \"option\": \"fetch_and_merge\",\n      \"description\": \"Retrieve the latest version and manually merge your changes\",\n      \"recommended\": true,\n      \"action\": \"GET /api/documents/456\"\n    },\n    {\n      \"option\": \"force_update\",\n      \"description\": \"Force your update and overwrite recent changes\",\n      \"warning\": \"This will discard changes made by user_789\",\n      \"action\": \"PUT /api/documents/456 without If-Match header\",\n      \"recommended\": false\n    }\n  ],\n  \"current_version_url\": \"/api/documents/456\"\n}",
                "explanation": "El cliente intentó actualizar el documento usando If-Match con un ETag antiguo (version-abc123). El ETag actual es version-xyz789, lo que significa que otro usuario modificó el documento. La precondición falló y el servidor responde 412 para prevenir sobrescritura accidental."
            },
            {
                "scenario": "If-Unmodified-Since fallido en DELETE",
                "request": "DELETE /api/posts/789 HTTP/1.1\nHost: blog.example.com\nIf-Unmodified-Since: Mon, 15 Jan 2024 10:00:00 GMT\nAuthorization: Bearer admin_token",
                "response": "HTTP/1.1 412 Precondition Failed\nLast-Modified: Tue, 16 Jan 2024 14:20:00 GMT\nContent-Type: application/json\n\n{\n  \"error\": \"precondition_failed\",\n  \"message\": \"The post has been modified since the specified date\",\n  \"precondition_type\": \"if_unmodified_since\",\n  \"your_date\": \"2024-01-15T10:00:00Z\",\n  \"last_modified_date\": \"2024-01-16T14:20:00Z\",\n  \"post_id\": 789,\n  \"post_title\": \"Important Announcement\",\n  \"modified_by\": \"editor_user_456\",\n  \"changes_made\": \"Content updated with critical corrections\",\n  \"explanation\": \"This post was modified after the date you specified. Deletion cannot proceed to prevent loss of recent updates.\",\n  \"next_steps\": [\n    \"Review the current version of the post\",\n    \"Verify that deletion is still appropriate given recent changes\",\n    \"If deletion is still desired, retry without the If-Unmodified-Since header or with the current Last-Modified date\"\n  ],\n  \"view_current_post\": \"/api/posts/789\"\n}",
                "explanation": "El administrador intentó eliminar un post solo si no había sido modificado desde el 15 de enero. Sin embargo, el post fue modificado el 16 de enero. La precondición If-Unmodified-Since falló, y el servidor responde 412 para prevenir eliminación accidental de contenido actualizado."
            },
            {
                "scenario": "If-None-Match fallido (recurso no cambió)",
                "request": "GET /api/data/statistics HTTP/1.1\nHost: api.example.com\nIf-None-Match: \"stats-current-etag-xyz\"\nAccept: application/json",
                "response": "HTTP/1.1 304 Not Modified\nETag: \"stats-current-etag-xyz\"\nCache-Control: private, max-age=300\n\nNOTA: Este escenario NO resulta en 412, sino en 304 Not Modified.\nIf-None-Match con GET típicamente resulta en 304 cuando coincide.\n412 se usa principalmente con métodos de modificación (PUT, PATCH, DELETE, POST).",
                "explanation": "ACLARACIÓN IMPORTANTE: Con métodos seguros como GET, If-None-Match que coincide resulta en 304 Not Modified, no 412. El código 412 se usa principalmente cuando precondiciones fallan en métodos de modificación (PUT, PATCH, DELETE)."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7232, Section 4.2",
        "relatedHeaders": [
            "If-Match",
            "If-None-Match",
            "If-Modified-Since",
            "If-Unmodified-Since",
            "If-Range",
            "ETag",
            "Last-Modified"
        ],
        "relatedCodes": [
            304,
            409,
            428
        ],
        "technicalNotes": "412 indica que una PRECONDICIÓN proporcionada FALLÓ. Diferencias clave: 304 Not Modified se usa con GET cuando If-None-Match/If-Modified-Since indica que el recurso no cambió (esto es éxito, no error); 412 se usa principalmente con métodos de modificación cuando la precondición falla; 409 Conflict es para conflictos de estado no relacionados con precondiciones de encabezados; 428 Precondition Required es cuando el servidor REQUIERE una precondición pero no se proporcionó. Los encabezados If-Match e If-Unmodified-Since se usan para control de concurrencia optimista. 412 previene el 'lost update problem' donde actualizaciones concurrentes se sobrescriben. La respuesta debe incluir el ETag o Last-Modified actual para que el cliente pueda recuperar la versión actual.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768752637/412_ewudq7.png",
                "alt": "Imagen que representa el nombre del código 412 Precondition Failed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768752245/37-removebg-preview_zvinwn.png",
                "alt": "Imagen del código 412 Precondition Failed"
            }
        ]
    },
    {
        "code": 413,
        "status": "Payload Too Large",
        "category": "Client Error",
        "description": "El código 413 Payload Too Large (anteriormente conocido como 'Request Entity Too Large' en HTTP/1.1) indica que el servidor se niega a procesar la solicitud porque el cuerpo de la solicitud (payload) es más grande que los límites que el servidor está dispuesto o es capaz de procesar. El servidor está diciendo: 'Los datos que estás intentando enviarme son demasiado grandes, exceden mis límites configurados'. Este código es fundamental para la gestión de recursos del servidor y la prevención de abusos. Los servidores implementan límites de tamaño de payload por varias razones: prevenir ataques de denegación de servicio (DoS) donde atacantes intentan agotar memoria o almacenamiento del servidor con payloads enormes, gestionar eficientemente los recursos de memoria y almacenamiento, implementar límites de cuota por usuario o plan de suscripción, proteger contra uploads accidentales de archivos excesivamente grandes, y mantener tiempos de respuesta razonables. Los límites pueden aplicarse a diferentes aspectos: tamaño total del cuerpo de la solicitud, tamaño de archivos individuales en uploads multipart, tamaño de campos específicos en formularios, o límites agregados por periodo de tiempo. La respuesta 413 puede incluir un encabezado Retry-After si la condición es temporal (por ejemplo, el usuario ha excedido su cuota mensual pero puede reintentar el próximo mes), aunque esto es menos común. Es importante distinguir 413 de otros códigos relacionados con tamaño: 411 Length Required se usa cuando falta el encabezado Content-Length, mientras que 413 se usa cuando Content-Length ESTÁ presente pero el valor excede el límite permitido. Los límites típicos varían ampliamente según el tipo de servidor y aplicación: servidores web pueden limitar requests a 1-10MB por defecto, servicios de upload de archivos pueden permitir 100MB-5GB, APIs pueden limitar payloads JSON a 1-16MB, y servicios de email pueden limitar adjuntos a 25-50MB. Cuando un cliente recibe 413, las opciones incluyen: reducir el tamaño de los datos (comprimir, optimizar), dividir la carga en múltiples requests más pequeños, o actualizar a un plan de servicio con límites mayores si es una restricción de cuota.",
        "useCases": [
            "Upload de archivos que exceden el tamaño máximo permitido",
            "Solicitudes POST/PUT con payloads JSON o XML demasiado grandes",
            "Envío de formularios con datos que exceden límites configurados",
            "Uploads de imágenes o videos que superan restricciones de tamaño",
            "Requests que exceden cuotas de usuario o plan de suscripción",
            "Payloads que excederían capacidad de memoria o almacenamiento del servidor",
            "Múltiples archivos en upload multipart que exceden límite agregado",
            "Prevención de ataques DoS con payloads excesivamente grandes"
        ],
        "examples": [
            {
                "scenario": "Upload de archivo que excede límite",
                "request": "POST /api/upload HTTP/1.1\nHost: storage.example.com\nContent-Type: multipart/form-data\nContent-Length: 524288000\nAuthorization: Bearer valid_token\n\n[500MB de datos de archivo]",
                "response": "HTTP/1.1 413 Payload Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"payload_too_large\",\n  \"message\": \"The uploaded file exceeds the maximum allowed size\",\n  \"request_size\": 524288000,\n  \"request_size_human\": \"500 MB\",\n  \"max_size\": 104857600,\n  \"max_size_human\": \"100 MB\",\n  \"size_exceeded_by\": 419430400,\n  \"size_exceeded_by_human\": \"400 MB\",\n  \"user_plan\": \"free\",\n  \"plan_limits\": {\n    \"free\": \"100 MB per file\",\n    \"basic\": \"500 MB per file\",\n    \"premium\": \"5 GB per file\",\n    \"enterprise\": \"50 GB per file\"\n  },\n  \"suggestions\": [\n    \"Compress the file before uploading\",\n    \"Split the file into smaller chunks\",\n    \"Upgrade to Basic plan for 500 MB limit\",\n    \"Use our chunked upload API for files larger than 100 MB\"\n  ],\n  \"upgrade_url\": \"https://billing.example.com/upgrade\",\n  \"chunked_upload_docs\": \"https://docs.example.com/api/chunked-upload\"\n}",
                "explanation": "El cliente intentó subir un archivo de 500MB, pero el límite del plan gratuito es 100MB. El servidor rechaza la solicitud con 413 y proporciona información sobre límites de diferentes planes y alternativas como compresión o upload por chunks."
            },
            {
                "scenario": "Payload JSON demasiado grande en API",
                "request": "POST /api/bulk-import HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 16777216\nAuthorization: Bearer valid_token\n\n{\n  \"items\": [\n    ... 100,000 items de datos ...\n  ]\n}",
                "response": "HTTP/1.1 413 Payload Too Large\nContent-Type: application/json\n\n{\n  \"error\": \"request_body_too_large\",\n  \"message\": \"Request body exceeds maximum allowed size for this endpoint\",\n  \"payload_size\": 16777216,\n  \"payload_size_human\": \"16 MB\",\n  \"max_allowed\": 5242880,\n  \"max_allowed_human\": \"5 MB\",\n  \"endpoint\": \"/api/bulk-import\",\n  \"items_in_request\": 100000,\n  \"recommended_batch_size\": 1000,\n  \"explanation\": \"Large bulk imports should be split into smaller batches to ensure reliability and performance\",\n  \"alternatives\": [\n    {\n      \"method\": \"batch_processing\",\n      \"description\": \"Split into batches of 1,000 items each\",\n      \"endpoint\": \"/api/bulk-import\",\n      \"max_items_per_batch\": 1000,\n      \"example\": \"Send 100 requests with 1,000 items each\"\n    },\n    {\n      \"method\": \"file_upload\",\n      \"description\": \"Upload CSV or JSON file for async processing\",\n      \"endpoint\": \"/api/bulk-import/file\",\n      \"max_file_size\": \"100 MB\",\n      \"format\": \"CSV or JSON\"\n    }\n  ],\n  \"documentation\": \"https://docs.example.com/api/bulk-operations\"\n}",
                "explanation": "El cliente intentó importar 100,000 items en una sola solicitud de 16MB, excediendo el límite de 5MB para este endpoint. Se sugiere dividir en lotes de 1,000 items o usar el endpoint de upload de archivo para procesamiento asíncrono."
            },
            {
                "scenario": "Límite de cuota mensual excedido",
                "request": "POST /api/data-processing HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 2097152\n\n[2MB de datos para procesamiento]",
                "response": "HTTP/1.1 413 Payload Too Large\nRetry-After: 1209600\nX-RateLimit-Limit: 104857600\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1709251200\nContent-Type: application/json\n\n{\n  \"error\": \"quota_exceeded\",\n  \"message\": \"Monthly data processing quota has been exceeded\",\n  \"request_size\": 2097152,\n  \"request_size_human\": \"2 MB\",\n  \"quota_type\": \"monthly_processing\",\n  \"quota_limit\": 104857600,\n  \"quota_limit_human\": \"100 MB per month\",\n  \"quota_used\": 104857600,\n  \"quota_used_human\": \"100 MB\",\n  \"quota_remaining\": 0,\n  \"quota_reset_date\": \"2024-03-01T00:00:00Z\",\n  \"days_until_reset\": 14,\n  \"current_plan\": \"starter\",\n  \"plan_options\": [\n    {\n      \"plan\": \"professional\",\n      \"quota\": \"1 GB per month\",\n      \"price\": \"$29.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/professional\"\n    },\n    {\n      \"plan\": \"business\",\n      \"quota\": \"10 GB per month\",\n      \"price\": \"$99.99/month\",\n      \"upgrade_url\": \"https://billing.example.com/upgrade/business\"\n    }\n  ],\n  \"suggestions\": [\n    \"Wait 14 days for quota to reset on March 1st\",\n    \"Upgrade to a higher plan for increased quota\",\n    \"Optimize data to reduce processing size\"\n  ]\n}",
                "explanation": "El usuario ha consumido toda su cuota mensual de procesamiento de datos (100MB). Aunque la solicitud individual de 2MB es pequeña, no puede procesarse porque excedería la cuota del periodo. El encabezado Retry-After indica que puede reintentar en 14 días cuando se resetee la cuota."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.11",
        "relatedHeaders": [
            "Content-Length",
            "Retry-After",
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining"
        ],
        "relatedCodes": [
            411
        ],
        "technicalNotes": "413 se usa cuando el payload EXCEDE un límite, mientras que 411 Length Required se usa cuando falta el encabezado Content-Length. El nombre cambió de 'Request Entity Too Large' a 'Payload Too Large' en especificaciones recientes para mayor claridad. La respuesta puede incluir Retry-After si la condición es temporal (cuotas por periodo). Los límites pueden ser: por solicitud individual, agregados por periodo de tiempo, por usuario/plan, o por tipo de contenido. Los servidores deben documentar claramente sus límites. Para archivos grandes, considerar: chunked upload APIs, compresión, procesamiento asíncrono con polling. Los límites comunes: nginx default 1MB, Apache default 2GB (configurable), servicios cloud 5-100MB para APIs.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/413_s69lyx.png",
                "alt": "Imagen que representa el nombre del código 413 Payload Too Large"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753831/38-removebg-preview_y2zldy.png",
                "alt": "Imagen del código 413 Payload Too Large"
            }
        ]
    },
    {
        "code": 414,
        "status": "URI Too Long",
        "category": "Client Error",
        "description": "El código 414 URI Too Long indica que el servidor se niega a procesar la solicitud porque el URI (Uniform Resource Identifier) solicitado es más largo que lo que el servidor está dispuesto a interpretar. El servidor está diciendo: 'La URL que estás intentando usar es demasiado larga para que yo la procese'. Este código se aplica tanto a la longitud total del URI completo (incluyendo el esquema, host, path, y query string) como específicamente a componentes individuales que pueden tener límites. Las causas más comunes de URIs excesivamente largos son: query strings con demasiados parámetros o valores muy largos, especialmente cuando se pasan grandes cantidades de datos mediante GET en lugar de POST, encoding de datos complejos en la URL (como estado de aplicación, filtros múltiples, o datos serializados), redirecciones en cadena que acumulan parámetros, ataques que intentan explotar vulnerabilidades mediante URLs extremadamente largas, o simplemente diseño inadecuado de API que pone demasiada información en la URL. Los límites de longitud de URI varían significativamente entre diferentes servidores y navegadores: muchos navegadores modernos soportan URLs de hasta 2,000 caracteres (aunque técnicamente pueden manejar más), Internet Explorer históricamente tenía un límite de 2,083 caracteres, Apache tiene un límite por defecto de 8,190 bytes, nginx usa 4K-8K bytes por defecto, IIS tiene límites configurables pero típicamente 16K, y muchos servicios cloud imponen límites de 2K-8K. La especificación HTTP no define un límite máximo, dejándolo a la implementación del servidor. Cuando se encuentra un 414, las soluciones típicas incluyen: cambiar de GET a POST para enviar datos en el cuerpo de la solicitud en lugar de query parameters, acortar los parámetros de query usando IDs en lugar de datos completos, implementar algún tipo de compresión o codificación más eficiente, dividir la solicitud en múltiples requests más pequeños, o usar métodos alternativos como almacenar estado en el servidor y referenciar con un token corto. Es importante diseñar APIs que no dependan de URLs extremadamente largas.",
        "useCases": [
            "Query strings con demasiados parámetros de filtrado o búsqueda",
            "Pasar grandes cantidades de datos mediante GET en lugar de POST",
            "URLs que codifican estado completo de aplicación",
            "Múltiples parámetros de array o lista en query string",
            "Encoding de datos JSON o XML complejos en parámetros de URL",
            "Redirecciones que acumulan parámetros progresivamente",
            "Búsquedas con muchos términos o filtros simultáneos",
            "URLs generadas automáticamente que concatenan demasiada información"
        ],
        "examples": [
            {
                "scenario": "Query string excesivamente largo con múltiples filtros",
                "request": "GET /api/products?category=electronics&brand=Samsung&brand=Apple&brand=Sony&brand=LG&price_min=100&price_max=2000&color=black&color=white&color=silver&color=blue&features=wifi&features=bluetooth&features=4k&features=hdr&features=smart&rating_min=4&shipping=free&instock=true&warranty=2years&model=2024&model=2023&condition=new&region=north&region=south&region=east&region=west&sortby=price&order=asc&page=1&limit=50&include_reviews=true&include_specs=true&include_images=true&include_related=true&format=json... [continues for 3000+ characters] HTTP/1.1\nHost: shop.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"The request URI exceeds the maximum allowed length\",\n  \"uri_length\": 3245,\n  \"max_uri_length\": 2048,\n  \"exceeded_by\": 1197,\n  \"component\": \"query_string\",\n  \"explanation\": \"Your search has too many filters and parameters in the URL\",\n  \"recommendations\": [\n    {\n      \"method\": \"use_post\",\n      \"description\": \"Use POST method with filters in request body\",\n      \"endpoint\": \"POST /api/products/search\",\n      \"example\": {\n        \"filters\": {\n          \"categories\": [\"electronics\"],\n          \"brands\": [\"Samsung\", \"Apple\", \"Sony\", \"LG\"],\n          \"price_range\": {\"min\": 100, \"max\": 2000},\n          \"colors\": [\"black\", \"white\", \"silver\", \"blue\"]\n        }\n      }\n    },\n    {\n      \"method\": \"save_search\",\n      \"description\": \"Save your search criteria and use a short reference ID\",\n      \"endpoint\": \"POST /api/saved-searches\",\n      \"usage\": \"GET /api/products?search_id=abc123\"\n    },\n    {\n      \"method\": \"simplify_filters\",\n      \"description\": \"Reduce the number of simultaneous filters\",\n      \"suggestion\": \"Focus on the most important criteria\"\n    }\n  ],\n  \"documentation\": \"https://docs.shop.example.com/api/search-best-practices\"\n}",
                "explanation": "El cliente intentó usar una URL de más de 3,000 caracteres con docenas de filtros y parámetros. El servidor tiene un límite de 2,048 caracteres. Se sugiere usar POST con los filtros en el cuerpo, o guardar la búsqueda y usar un ID corto."
            },
            {
                "scenario": "Datos codificados en URL que deberían estar en POST body",
                "request": "GET /api/report?data={\"users\":[{\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\",\"department\":\"Engineering\",\"projects\":[\"Project A\",\"Project B\",\"Project C\"]},{\"id\":2,\"name\":\"Jane Smith\",\"email\":\"jane@example.com\",\"department\":\"Marketing\",\"projects\":[\"Campaign X\",\"Campaign Y\"]}],\"date_range\":{\"start\":\"2024-01-01\",\"end\":\"2024-12-31\"},\"metrics\":[\"revenue\",\"users\",\"conversions\",\"engagement\"],\"groupby\":[\"month\",\"department\",\"project\"],\"format\":\"pdf\",\"include_charts\":true,\"include_summary\":true} HTTP/1.1\nHost: analytics.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"URI length exceeds server limits\",\n  \"uri_length\": 892,\n  \"max_uri_length\": 512,\n  \"issue\": \"Complex data structures should not be passed in URL parameters\",\n  \"correct_approach\": {\n    \"method\": \"POST\",\n    \"endpoint\": \"/api/report\",\n    \"content_type\": \"application/json\",\n    \"body_example\": {\n      \"users\": [\n        {\"id\": 1, \"name\": \"John Doe\"},\n        {\"id\": 2, \"name\": \"Jane Smith\"}\n      ],\n      \"date_range\": {\n        \"start\": \"2024-01-01\",\n        \"end\": \"2024-12-31\"\n      },\n      \"metrics\": [\"revenue\", \"users\"],\n      \"format\": \"pdf\"\n    }\n  },\n  \"why_post\": [\n    \"POST allows larger payloads in request body\",\n    \"Better security (data not visible in URLs/logs)\",\n    \"No URL encoding issues with special characters\",\n    \"Cleaner and more maintainable code\"\n  ],\n  \"security_note\": \"Sensitive data should never be in URLs as they may be logged or cached\",\n  \"documentation\": \"https://docs.analytics.example.com/api/reports\"\n}",
                "explanation": "El cliente intentó pasar datos JSON complejos como parámetro de query en GET. Esto no solo excede límites de longitud sino que también es mala práctica. Los datos estructurados complejos deben enviarse en el cuerpo de una solicitud POST."
            },
            {
                "scenario": "URL generada con IDs múltiples como parámetros individuales",
                "request": "GET /api/export?id=1001&id=1002&id=1003&id=1004&id=1005... [continues with 500 more IDs] ...&id=1500&format=csv&include_metadata=true HTTP/1.1\nHost: data.example.com",
                "response": "HTTP/1.1 414 URI Too Long\nContent-Type: application/json\n\n{\n  \"error\": \"uri_too_long\",\n  \"message\": \"Too many ID parameters in URL\",\n  \"parameter_count\": 500,\n  \"uri_length\": 4567,\n  \"max_uri_length\": 2048,\n  \"better_approaches\": [\n    {\n      \"method\": \"post_with_body\",\n      \"description\": \"Use POST with IDs in request body\",\n      \"endpoint\": \"POST /api/export\",\n      \"example\": {\n        \"ids\": [1001, 1002, 1003, \"...\", 1500],\n        \"format\": \"csv\",\n        \"include_metadata\": true\n      }\n    },\n    {\n      \"method\": \"id_ranges\",\n      \"description\": \"Use ranges instead of individual IDs\",\n      \"example\": \"GET /api/export?ids=1001-1500&format=csv\"\n    },\n    {\n      \"method\": \"comma_separated\",\n      \"description\": \"Use comma-separated IDs in single parameter\",\n      \"example\": \"GET /api/export?ids=1001,1002,1003,...,1500&format=csv\",\n      \"note\": \"Still may exceed limits with many IDs, POST recommended\"\n    }\n  ],\n  \"max_recommended_ids_in_url\": 50,\n  \"recommendation\": \"For bulk operations with many IDs, always use POST method\"\n}",
                "explanation": "El cliente intentó exportar 500 items pasando cada ID como un parámetro separado &id=X. Esto crea una URL de más de 4,500 caracteres. Se recomienda usar POST con un array de IDs en el cuerpo, o usar rangos/listas separadas por comas con menos items."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.12",
        "relatedHeaders": [
            "Content-Length"
        ],
        "relatedCodes": [
            413
        ],
        "technicalNotes": "414 es específico para longitud de URI (URL completa incluyendo query string), mientras que 413 Payload Too Large es para el cuerpo de la solicitud. No hay límite máximo definido en la especificación HTTP, cada servidor implementa sus propios límites. Límites típicos: navegadores ~2,000 caracteres (IE: 2,083), servidores web 2K-8K bytes. Mejores prácticas: usar POST para datos complejos, mantener URLs bajo 2,000 caracteres para compatibilidad, usar IDs/tokens en lugar de datos completos, implementar mecanismos de 'saved searches' o 'saved filters'. Query strings largos también pueden causar problemas de seguridad (datos sensibles en logs) y caching issues.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/414_o8x00s.png",
                "alt": "Imagen que representa el nombre del código 414 URI Too Long"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753831/39-removebg-preview_llxt9h.png",
                "alt": "Imagen del código 414 URI Too Long"
            }
        ]
    },
    {
        "code": 415,
        "status": "Unsupported Media Type",
        "category": "Client Error",
        "description": "El código 415 Unsupported Media Type indica que el servidor se niega a aceptar la solicitud porque el formato del payload (cuerpo de la solicitud) está en un formato no soportado. Específicamente, se refiere al valor del encabezado Content-Type que el cliente especificó para los datos que está ENVIANDO al servidor. El servidor está diciendo: 'Recibí tus datos, pero están en un formato que no puedo procesar'. Este código es fundamental en APIs modernas donde los servidores pueden aceptar ciertos formatos de contenido pero no otros. Es importante distinguir 415 de 406 Not Acceptable: 415 se refiere al Content-Type de los datos que el cliente ENVÍA en la solicitud (lo que el cliente está produciendo); 406 se refiere a los tipos de contenido que el cliente puede ACEPTAR en la respuesta (lo que el cliente puede consumir, especificado en el encabezado Accept). Los escenarios comunes que causan 415 incluyen: enviar JSON cuando el servidor solo acepta XML, enviar datos de formulario (application/x-www-form-urlencoded) cuando se espera JSON, enviar archivos con Content-Type incorrecto (por ejemplo, text/plain en lugar de image/jpeg), olvidar incluir el encabezado Content-Type completamente, usar multipart/form-data incorrectamente, o enviar datos en un formato legacy que el servidor ya no soporta. Los servidores modernos típicamente soportan formatos comunes como application/json, application/xml, multipart/form-data para uploads de archivos, y application/x-www-form-urlencoded para formularios tradicionales. Sin embargo, algunos endpoints pueden ser más restrictivos y aceptar solo un formato específico. La respuesta 415 debería idealmente incluir información sobre qué formatos de contenido SÍ son aceptados por el servidor, típicamente mediante el encabezado Accept (aunque técnicamente Accept es para respuestas, algunos servidores lo usan en respuestas 415 para indicar formatos aceptados para solicitudes). En APIs bien diseñadas, la documentación especifica claramente qué Content-Type se requiere para cada endpoint.",
        "useCases": [
            "Enviar JSON cuando el servidor solo acepta XML",
            "Enviar form data cuando se requiere JSON",
            "Upload de archivo con Content-Type incorrecto o faltante",
            "Usar formato legacy no soportado por API moderna",
            "Content-Type mal formado o no reconocido",
            "Enviar datos sin especificar Content-Type cuando es requerido",
            "Intentar enviar formato binario cuando solo se acepta texto",
            "Mismatch entre Content-Type declarado y datos reales enviados"
        ],
        "examples": [
            {
                "scenario": "Enviar JSON cuando solo se acepta XML",
                "request": "POST /api/legacy-service HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 89\n\n{\n  \"userId\": 123,\n  \"action\": \"update\",\n  \"data\": {\n    \"status\": \"active\"\n  }\n}",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\nAccept: application/xml, text/xml\n\n{\n  \"error\": \"unsupported_media_type\",\n  \"message\": \"The media type of the request is not supported\",\n  \"received_content_type\": \"application/json\",\n  \"supported_types\": [\n    {\n      \"content_type\": \"application/xml\",\n      \"description\": \"XML format (preferred)\",\n      \"example\": \"<?xml version=\\\"1.0\\\"?>\\n<request>\\n  <userId>123</userId>\\n  <action>update</action>\\n</request>\"\n    },\n    {\n      \"content_type\": \"text/xml\",\n      \"description\": \"Plain XML format\"\n    }\n  ],\n  \"explanation\": \"This is a legacy endpoint that only accepts XML format\",\n  \"migration_note\": \"Consider using our v2 API which supports JSON: https://api.example.com/v2/\",\n  \"documentation\": \"https://docs.example.com/api/legacy/xml-format\"\n}",
                "explanation": "El cliente envió datos JSON a un endpoint legacy que solo acepta XML. El servidor responde con 415 e indica claramente qué formatos son aceptados, proporcionando un ejemplo de formato correcto y sugiriendo migrar a la API moderna que soporta JSON."
            },
            {
                "scenario": "Falta encabezado Content-Type en upload",
                "request": "POST /api/documents HTTP/1.1\nHost: storage.example.com\nAuthorization: Bearer valid_token\nContent-Length: 2048\n\n[binary PDF data without Content-Type header]",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\n\n{\n  \"error\": \"content_type_required\",\n  \"message\": \"Content-Type header is required and must specify a supported media type\",\n  \"received_content_type\": null,\n  \"issue\": \"No Content-Type header was provided\",\n  \"supported_types\": [\n    \"application/pdf\",\n    \"application/msword\",\n    \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"text/plain\"\n  ],\n  \"required_headers\": [\n    \"Content-Type\",\n    \"Content-Length\"\n  ],\n  \"example_correct_request\": \"POST /api/documents HTTP/1.1\\nContent-Type: application/pdf\\nContent-Length: 2048\\n\\n[PDF data]\",\n  \"note\": \"The Content-Type must match the actual file format being uploaded\",\n  \"documentation\": \"https://docs.storage.example.com/api/upload-requirements\"\n}",
                "explanation": "El cliente intentó subir un archivo PDF pero no incluyó el encabezado Content-Type. El servidor no puede determinar qué tipo de archivo es y responde con 415, listando los tipos de contenido aceptados y explicando que Content-Type es requerido."
            },
            {
                "scenario": "Content-Type no coincide con datos reales",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nContent-Length: 45\n\nname=John+Doe&email=john%40example.com",
                "response": "HTTP/1.1 415 Unsupported Media Type\nContent-Type: application/json\n\n{\n  \"error\": \"content_type_mismatch\",\n  \"message\": \"Content-Type header does not match the actual content format\",\n  \"declared_content_type\": \"application/json\",\n  \"detected_format\": \"application/x-www-form-urlencoded\",\n  \"issue\": \"You declared JSON but sent URL-encoded form data\",\n  \"resolution_options\": [\n    {\n      \"option\": \"use_correct_content_type\",\n      \"description\": \"Change Content-Type to match your data format\",\n      \"correct_header\": \"Content-Type: application/x-www-form-urlencoded\"\n    },\n    {\n      \"option\": \"send_json\",\n      \"description\": \"Send actual JSON data as declared\",\n      \"example\": {\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n      },\n      \"note\": \"This endpoint prefers JSON format\"\n    }\n  ],\n  \"accepted_formats\": [\n    \"application/json (preferred)\",\n    \"application/x-www-form-urlencoded (legacy support)\"\n  ],\n  \"recommendation\": \"Use JSON format for better structure and type safety\"\n}",
                "explanation": "El cliente declaró Content-Type: application/json pero envió datos URL-encoded. Esta inconsistencia causa confusión y el servidor responde con 415, explicando el mismatch y proporcionando opciones para corregirlo."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.13",
        "relatedHeaders": [
            "Content-Type",
            "Accept"
        ],
        "relatedCodes": [
            406
        ],
        "technicalNotes": "415 es sobre el Content-Type de lo que el cliente ENVÍA (request body), mientras que 406 Not Acceptable es sobre lo que el cliente puede ACEPTAR en la respuesta (Accept header). El servidor debería incluir información sobre qué tipos de contenido acepta, aunque no hay un encabezado estándar específico para esto en respuestas 415 (algunos usan Accept, otros lo incluyen en el cuerpo de la respuesta). Content-Type común aceptados: application/json, application/xml, application/x-www-form-urlencoded, multipart/form-data, text/plain. Para uploads de archivos, el Content-Type debe coincidir con el tipo real del archivo. APIs RESTful modernas típicamente requieren application/json. La validación puede ser estricta (solo tipos específicos) o permisiva (cualquier tipo pero con advertencias).",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/415_tl94ln.png",
                "alt": "Imagen que representa el nombre del código 415 Unsupported Media Type"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753830/40-removebg-preview_it0wsn.png",
                "alt": "Imagen del código 415 Unsupported Media Type"
            }
        ]
    },
    {
        "code": 416,
        "status": "Range Not Satisfiable",
        "category": "Client Error",
        "description": "El código 416 Range Not Satisfiable indica que ninguno de los rangos especificados en el encabezado Range de la solicitud puede ser satisfecho. Este código se utiliza cuando un cliente solicita una porción específica de un recurso (usando el encabezado Range), pero el rango solicitado está fuera de los límites del recurso o es inválido de alguna manera. El servidor está diciendo: 'Entiendo que quieres una porción específica de este recurso, pero el rango que especificaste no es válido o está completamente fuera de los límites del contenido disponible'. El mecanismo de rangos en HTTP permite a los clientes solicitar solo partes de un recurso, lo cual es fundamental para: descargas resumibles (donde un cliente puede solicitar solo la porción restante después de una interrupción), streaming de video/audio (donde el cliente puede solicitar segmentos específicos para permitir seek/skip), descargas paralelas (donde múltiples conexiones descargan diferentes segmentos simultáneamente), y optimización de ancho de banda (solicitando solo las porciones necesarias de archivos grandes). El encabezado Range tiene el formato 'Range: bytes=start-end', por ejemplo 'Range: bytes=0-1023' solicita los primeros 1024 bytes, o 'Range: bytes=1000-' solicita desde el byte 1000 hasta el final. Los errores comunes que causan 416 incluyen: solicitar un rango que comienza más allá del final del archivo (por ejemplo, 'Range: bytes=5000-' cuando el archivo solo tiene 3000 bytes), especificar un rango de inicio mayor que el rango de fin (por ejemplo, 'Range: bytes=1000-500'), usar valores negativos inválidos, o solicitar rangos cuando el recurso ha cambiado de tamaño desde que se obtuvo la información inicial. La respuesta 416 DEBE incluir un encabezado Content-Range que especifique el tamaño actual del recurso en el formato 'Content-Range: bytes */size', donde 'size' es el tamaño total en bytes del recurso completo. Esto permite al cliente entender el tamaño real y reformular su solicitud con un rango válido.",
        "useCases": [
            "Reanudación de descarga con rango que excede el tamaño del archivo",
            "Solicitud de rango inválido (inicio > fin)",
            "Rango que comienza más allá del final del recurso",
            "Archivo cambió de tamaño entre solicitudes y el rango ya no es válido",
            "Streaming de video solicitando segmento más allá de la duración del contenido",
            "Descarga paralela con rango calculado incorrectamente",
            "Cliente con información desactualizada sobre tamaño de archivo",
            "Formato de rango mal formado o no soportado"
        ],
        "examples": [
            {
                "scenario": "Rango de inicio más allá del tamaño del archivo",
                "request": "GET /downloads/video.mp4 HTTP/1.1\nHost: media.example.com\nRange: bytes=500000000-",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */104857600\nContent-Type: application/json\n\n{\n  \"error\": \"range_not_satisfiable\",\n  \"message\": \"The requested range is outside the bounds of the resource\",\n  \"requested_range\": \"bytes=500000000-\",\n  \"requested_start\": 500000000,\n  \"requested_start_human\": \"500 MB\",\n  \"file_size\": 104857600,\n  \"file_size_human\": \"100 MB\",\n  \"issue\": \"Range start (500000000) is beyond the end of file (104857600)\",\n  \"explanation\": \"You requested data starting at byte 500,000,000 but the file is only 104,857,600 bytes (100 MB) in total\",\n  \"valid_range\": \"bytes=0-104857599\",\n  \"suggestions\": [\n    \"Request the entire file: GET /downloads/video.mp4 (no Range header)\",\n    \"Request from the beginning: Range: bytes=0-\",\n    \"Request the last portion: Range: bytes=104000000-104857599\"\n  ],\n  \"note\": \"The file may have been truncated or you may have outdated size information\"\n}",
                "explanation": "El cliente solicitó datos comenzando desde el byte 500,000,000, pero el archivo solo tiene 104,857,600 bytes en total. El rango está completamente fuera de los límites. El encabezado Content-Range indica que el tamaño total es 104,857,600 bytes."
            },
            {
                "scenario": "Rango inválido donde inicio > fin",
                "request": "GET /files/document.pdf HTTP/1.1\nHost: storage.example.com\nRange: bytes=1000-500\nAuthorization: Bearer valid_token",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */2097152\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_range_format\",\n  \"message\": \"The requested range has invalid values\",\n  \"requested_range\": \"bytes=1000-500\",\n  \"range_start\": 1000,\n  \"range_end\": 500,\n  \"file_size\": 2097152,\n  \"file_size_human\": \"2 MB\",\n  \"issue\": \"Range start (1000) is greater than range end (500)\",\n  \"explanation\": \"A valid byte range must have the start position less than or equal to the end position\",\n  \"correct_format\": \"Range: bytes=start-end where start <= end\",\n  \"examples_of_valid_ranges\": [\n    \"Range: bytes=0-1023 (first 1024 bytes)\",\n    \"Range: bytes=500-1000 (bytes 500 through 1000)\",\n    \"Range: bytes=1000- (from byte 1000 to end of file)\",\n    \"Range: bytes=-1024 (last 1024 bytes)\"\n  ],\n  \"did_you_mean\": \"Range: bytes=500-1000\",\n  \"documentation\": \"https://docs.storage.example.com/api/range-requests\"\n}",
                "explanation": "El cliente especificó un rango donde el inicio (1000) es mayor que el fin (500), lo cual es lógicamente inválido. El servidor responde con 416 y explica el formato correcto de rangos, sugiriendo que posiblemente quiso decir bytes=500-1000."
            },
            {
                "scenario": "Reanudación de descarga después de que el archivo fue modificado",
                "request": "GET /downloads/software-v2.zip HTTP/1.1\nHost: cdn.example.com\nRange: bytes=50000000-\nIf-Range: \"etag-old-version-abc123\"",
                "response": "HTTP/1.1 416 Range Not Satisfiable\nContent-Range: bytes */45000000\nETag: \"etag-new-version-xyz789\"\nLast-Modified: Wed, 17 Jan 2024 10:00:00 GMT\nContent-Type: application/json\n\n{\n  \"error\": \"range_not_satisfiable\",\n  \"message\": \"Range request cannot be satisfied because the resource has changed\",\n  \"requested_range\": \"bytes=50000000-\",\n  \"requested_start\": 50000000,\n  \"requested_start_human\": \"50 MB\",\n  \"current_file_size\": 45000000,\n  \"current_file_size_human\": \"45 MB\",\n  \"previous_file_size_estimate\": \"~100 MB or more\",\n  \"issue\": \"The file was updated and is now smaller than your resume point\",\n  \"file_version_changed\": true,\n  \"your_etag\": \"etag-old-version-abc123\",\n  \"current_etag\": \"etag-new-version-xyz789\",\n  \"last_modified\": \"2024-01-17T10:00:00Z\",\n  \"explanation\": \"You were downloading an older version of the file. A new version (v2.1) was released that is smaller.\",\n  \"resolution\": [\n    \"Download the new version from the beginning\",\n    \"The new version may have different content or be more compressed\",\n    \"Previous partial download is incompatible with new version\"\n  ],\n  \"download_new_version\": \"GET /downloads/software-v2.zip (without Range header)\",\n  \"version_info\": {\n    \"old_version\": \"v2.0\",\n    \"new_version\": \"v2.1\",\n    \"changelog\": \"https://example.com/changelog/v2.1\"\n  }\n}",
                "explanation": "El cliente estaba descargando un archivo de ~100MB y había descargado 50MB. El archivo fue actualizado a una nueva versión que solo tiene 45MB. El rango solicitado (desde byte 50,000,000) ahora está más allá del final del archivo actualizado. Debe descargar la nueva versión desde el principio."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7233, Section 4.4",
        "relatedHeaders": [
            "Range",
            "Content-Range",
            "Accept-Ranges",
            "If-Range",
            "ETag"
        ],
        "relatedCodes": [
            206
        ],
        "technicalNotes": "416 es la respuesta cuando un rango NO puede satisfacerse. Cuando un rango SÍ puede satisfacerse, el servidor responde 206 Partial Content. La respuesta 416 DEBE incluir Content-Range con el formato 'bytes */size' donde size es el tamaño total del recurso. El encabezado If-Range puede usarse para hacer requests de rango condicionales: si el recurso cambió, el servidor ignora el Range y envía 200 con el recurso completo en lugar de 416. Formato válido de Range: bytes=start-end (ambos inclusivos), bytes=start- (desde start hasta el final), bytes=-suffix (últimos suffix bytes). Los índices comienzan en 0. Un archivo de 1000 bytes va de 0 a 999. Múltiples rangos son soportados: Range: bytes=0-100,200-300.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754170/416_rsmaxq.png",
                "alt": "Imagen que representa el nombre del código 416 Range Not Satisfiable"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753835/41-removebg-preview_trgi8w.png",
                "alt": "Imagen del código 416 Range Not Satisfiable"
            }
        ]
    },
    {
        "code": 417,
        "status": "Expectation Failed",
        "category": "Client Error",
        "description": "El código 417 Expectation Failed indica que la expectativa especificada en el encabezado Expect de la solicitud no puede ser cumplida por el servidor. El encabezado Expect permite al cliente indicar ciertos comportamientos que espera del servidor antes de enviar el cuerpo completo de la solicitud. El uso más común del encabezado Expect es 'Expect: 100-continue', que le dice al servidor: 'Voy a enviar un cuerpo de solicitud grande, pero primero verifica si puedes manejarlo'. Si el servidor puede procesar la solicitud, responde con '100 Continue' y el cliente entonces envía el cuerpo completo. Sin embargo, si el servidor determina que no puede cumplir con la expectativa (por ejemplo, porque rechazará la solicitud por razones de autenticación, autorización, o límites de tamaño), responde con 417 Expectation Failed en lugar de 100 Continue. Esto ahorra ancho de banda al prevenir que el cliente envíe un payload grande que será rechazado de todos modos. El código 417 es relativamente raro en la práctica web moderna porque: (1) el mecanismo Expect/100-continue no es ampliamente utilizado fuera de ciertos contextos específicos, (2) muchos servidores simplemente ignoran el encabezado Expect y procesan la solicitud normalmente, (3) algunos servidores no implementan completamente el manejo de expectativas. Los escenarios donde 417 es apropiado incluyen: cuando el servidor no soporta el esquema de expectativa solicitado (por ejemplo, expectativas personalizadas más allá de 100-continue), cuando el servidor determina por adelantado que la solicitud fallará incluso antes de recibir el cuerpo (autenticación inválida, permisos insuficientes, límites excedidos), o cuando el servidor está configurado para no aceptar solicitudes con ciertos tipos de expectativas. Es importante notar que 417 es específicamente para fallos relacionados con el encabezado Expect, no para otros tipos de fallos de validación o precondiciones.",
        "useCases": [
            "Servidor rechaza Expect: 100-continue debido a autenticación inválida",
            "Servidor no soporta el esquema de expectativa especificado",
            "Servidor determina que la solicitud fallará antes de recibir el cuerpo",
            "Expectativa personalizada no reconocida o no soportada por el servidor",
            "Servidor configurado para rechazar ciertos tipos de expectativas",
            "Prevención de upload de payload grande que será rechazado por otras razones",
            "Validación temprana que determina que la solicitud no puede proceder"
        ],
        "examples": [
            {
                "scenario": "Expect: 100-continue rechazado por autenticación inválida",
                "request": "POST /api/upload HTTP/1.1\nHost: storage.example.com\nExpect: 100-continue\nContent-Type: application/octet-stream\nContent-Length: 524288000\nAuthorization: Bearer expired_or_invalid_token",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Cannot fulfill the Expect: 100-continue request\",\n  \"expectation\": \"100-continue\",\n  \"reason\": \"Authentication token is invalid or expired\",\n  \"explanation\": \"The server will not accept the request body because authentication failed. Sending 417 to prevent uploading 500MB that would be rejected anyway.\",\n  \"authentication_error\": {\n    \"code\": \"token_expired\",\n    \"message\": \"The authorization token has expired\",\n    \"expired_at\": \"2024-01-16T12:00:00Z\",\n    \"current_time\": \"2024-01-17T15:30:00Z\"\n  },\n  \"next_steps\": [\n    \"Obtain a new authentication token\",\n    \"Retry the upload with valid credentials\"\n  ],\n  \"token_refresh_endpoint\": \"/auth/refresh\",\n  \"bandwidth_saved\": \"500 MB (by not uploading rejected content)\"\n}",
                "explanation": "El cliente envió Expect: 100-continue indicando que enviará 500MB de datos. El servidor verifica primero el token de autenticación y descubre que está expirado. En lugar de responder 100 Continue solo para luego rechazar con 401, responde inmediatamente con 417 ahorrando el envío innecesario de 500MB."
            },
            {
                "scenario": "Expectativa personalizada no soportada",
                "request": "POST /api/data HTTP/1.1\nHost: api.example.com\nExpect: custom-validation, 100-continue\nContent-Type: application/json\nContent-Length: 10485760",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Server cannot fulfill the specified expectations\",\n  \"received_expectations\": [\"custom-validation\", \"100-continue\"],\n  \"unsupported_expectations\": [\"custom-validation\"],\n  \"supported_expectations\": [\"100-continue\"],\n  \"reason\": \"The 'custom-validation' expectation is not recognized or supported by this server\",\n  \"explanation\": \"While 100-continue is supported, custom-validation is not a standard expectation and this server doesn't implement it\",\n  \"recommendation\": \"Remove unsupported expectations and retry with only: Expect: 100-continue\",\n  \"correct_request\": \"POST /api/data HTTP/1.1\\nExpect: 100-continue\\n...\",\n  \"documentation\": \"https://docs.api.example.com/http-expectations\"\n}",
                "explanation": "El cliente especificó múltiples expectativas incluyendo una personalizada ('custom-validation') que el servidor no reconoce o no soporta. El servidor responde con 417 indicando qué expectativa causó el problema y cuáles son soportadas."
            },
            {
                "scenario": "Servidor determina que límite será excedido",
                "request": "POST /api/process HTTP/1.1\nHost: api.example.com\nExpect: 100-continue\nContent-Type: application/json\nContent-Length: 52428800\nAuthorization: Bearer free_tier_user_token",
                "response": "HTTP/1.1 417 Expectation Failed\nContent-Type: application/json\n\n{\n  \"error\": \"expectation_failed\",\n  \"message\": \"Cannot proceed with request due to quota limitations\",\n  \"expectation\": \"100-continue\",\n  \"reason\": \"Request would exceed user quota limits\",\n  \"request_size\": 52428800,\n  \"request_size_human\": \"50 MB\",\n  \"user_plan\": \"free\",\n  \"quota_limit\": 10485760,\n  \"quota_limit_human\": \"10 MB per request\",\n  \"quota_used_today\": 8388608,\n  \"quota_remaining_today\": 2097152,\n  \"quota_remaining_human\": \"2 MB\",\n  \"explanation\": \"Your free plan allows maximum 10 MB per request. This 50 MB request exceeds the limit. Responding with 417 to prevent sending data that would be rejected.\",\n  \"upgrade_options\": [\n    {\n      \"plan\": \"basic\",\n      \"limit\": \"100 MB per request\",\n      \"price\": \"$9.99/month\"\n    },\n    {\n      \"plan\": \"pro\",\n      \"limit\": \"1 GB per request\",\n      \"price\": \"$29.99/month\"\n    }\n  ],\n  \"suggestion\": \"Either reduce request size to under 10 MB or upgrade your plan\"\n}",
                "explanation": "El cliente con plan gratuito intentó enviar 50MB cuando su límite es 10MB. El servidor evalúa esto antes de enviar 100 Continue y responde 417 para evitar que el cliente desperdicie ancho de banda enviando datos que serán rechazados por 413 Payload Too Large."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 7231, Section 6.5.14",
        "relatedHeaders": [
            "Expect"
        ],
        "relatedCodes": [
            100
        ],
        "technicalNotes": "417 es específicamente para fallos relacionados con el encabezado Expect. El caso más común es Expect: 100-continue. Cuando un cliente envía Expect: 100-continue, el servidor tiene tres opciones: (1) responder 100 Continue si puede procesar la solicitud, (2) responder 417 Expectation Failed si no puede cumplir la expectativa, (3) responder directamente con código de error apropiado (401, 403, 413, etc.) si ya sabe que la solicitud fallará. El código 417 es raro en la práctica porque muchos servidores ignoran Expect o no lo implementan completamente. Si el servidor no entiende/soporta el encabezado Expect, puede ignorarlo y procesar normalmente. 417 NO debe usarse para otros tipos de validación o precondiciones - usar códigos apropiados como 400, 412, 428.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754171/417_kh1l57.png",
                "alt": "Imagen que representa el nombre del código 417 Expectation Failed"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753835/42-removebg-preview_zp0aep.png",
                "alt": "Imagen del código 417 Expectation Failed"
            }
        ]
    },
    {
        "code": 418,
        "status": "I'm a teapot",
        "category": "Client Error",
        "description": "El código 418 I'm a teapot es uno de los códigos de estado HTTP más peculiares y únicos en toda la especificación. Fue definido originalmente en 1998 como parte del RFC 2324, que era una broma del April Fools' Day (Día de los Inocentes) llamada 'Hyper Text Coffee Pot Control Protocol' (HTCPCP). El RFC 2324 propuso un protocolo para controlar, monitorear y diagnosticar cafeteras a través de internet. El código 418 se define como la respuesta que debe dar una tetera cuando se le solicita preparar café: 'I'm a teapot' (Soy una tetera). El servidor está diciendo: 'Soy una tetera, no una cafetera, por lo tanto no puedo preparar café'. Aunque comenzó como una broma, el código 418 ha ganado un estatus de culto en la comunidad de desarrolladores y se ha vuelto un símbolo del humor geek en la cultura de internet. A pesar de su origen humorístico, el código 418 está oficialmente reservado en el registro de códigos de estado HTTP de IANA. En 2017, hubo una propuesta para eliminar 418 del registro oficial, pero la comunidad de desarrolladores se opuso fuertemente, argumentando que es parte de la cultura de internet y debe preservarse. Como resultado, 418 permanece oficialmente reservado. En la práctica moderna, algunos desarrolladores usan 418 de manera humorística en sus APIs como easter eggs, respuestas a solicitudes absurdas, o simplemente para agregar un toque de diversión. Sin embargo, NO debe usarse en aplicaciones de producción serias para indicar errores reales, ya que los clientes HTTP estándar no tienen lógica específica para manejarlo y puede causar confusión. El código 418 representa el lado divertido y humano del desarrollo de software, recordándonos que detrás de protocolos y especificaciones técnicas, hay personas con sentido del humor.",
        "useCases": [
            "Easter eggs en APIs como respuesta humorística",
            "Respuestas a solicitudes absurdas o imposibles de manera divertida",
            "Demostración de cultura de internet en proyectos educativos",
            "Indicador humorístico de que una API no hace lo que se solicita",
            "NOTA: NO debe usarse para errores reales en producción"
        ],
        "examples": [
            {
                "scenario": "Easter egg en API divertida",
                "request": "POST /api/brew-coffee HTTP/1.1\nHost: teapot.example.com\nContent-Type: application/json\n\n{\n  \"beverage\": \"coffee\",\n  \"size\": \"large\",\n  \"strength\": \"strong\"\n}",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: application/json\n\n{\n  \"error\": \"im_a_teapot\",\n  \"message\": \"I'm a teapot, not a coffee pot!\",\n  \"explanation\": \"This endpoint is a teapot and cannot brew coffee. Please try the tea endpoint instead.\",\n  \"requested_beverage\": \"coffee\",\n  \"what_i_can_do\": \"brew tea\",\n  \"alternative_endpoint\": \"/api/brew-tea\",\n  \"reference\": \"RFC 2324 - Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)\",\n  \"fun_fact\": \"This is a real HTTP status code from an April Fools' RFC!\",\n  \"teapot_status\": {\n    \"type\": \"ceramic\",\n    \"capacity\": \"1 liter\",\n    \"temperature\": \"hot\",\n    \"currently_brewing\": \"Earl Grey tea\"\n  },\n  \"suggestion\": \"Try: POST /api/brew-tea with beverage: 'earl-grey' or 'green-tea'\",\n  \"ascii_art\": \"\\n    _\\n   ( )\\n    )(_\\n  .-|:|-. \\n (_:===:_)\\n   |: I :|\\n   |: m :|\\n   |: a :|\\n   |:   :|\\n   |:tea|\\n   |: p :|\\n   |: o :|\\n   |: t :|\\n   '-----'\\n\"\n}",
                "explanation": "Una API divertida usa 418 como respuesta humorística cuando alguien intenta pedirle que prepare café. Incluye arte ASCII de una tetera, referencias al RFC original, y sugiere el endpoint correcto para té."
            },
            {
                "scenario": "Respuesta a solicitud imposible o absurda",
                "request": "DELETE /api/internet HTTP/1.1\nHost: silly-api.example.com\nAuthorization: Bearer curious_user_token",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: application/json\n\n{\n  \"error\": \"request_impossible\",\n  \"message\": \"I'm a teapot, and even if I weren't, I couldn't delete the internet\",\n  \"requested_action\": \"DELETE /api/internet\",\n  \"why_teapot\": \"Using HTTP 418 to indicate this request is as absurd as asking a teapot to make coffee\",\n  \"reality_check\": [\n    \"The internet is not a single deletable entity\",\n    \"No API has that kind of power (thankfully)\",\n    \"This endpoint doesn't exist for very good reasons\",\n    \"Please don't try to delete the internet\"\n  ],\n  \"what_you_can_actually_do\": [\n    \"View API documentation: GET /api/docs\",\n    \"Check service status: GET /api/status\",\n    \"Manage your account: GET /api/account\"\n  ],\n  \"philosophical_note\": \"The internet is a network of networks. To 'delete' it would require disconnecting every device worldwide. Also, I'm a teapot.\",\n  \"http_418_history\": \"https://tools.ietf.org/html/rfc2324\"\n}",
                "explanation": "Cuando alguien intenta hacer algo completamente absurdo como 'eliminar el internet', la API responde con 418 de manera humorística, explicando por qué la solicitud es imposible mientras mantiene el espíritu divertido del código."
            },
            {
                "scenario": "Implementación educativa mostrando RFC 2324",
                "request": "BREW /pot-0 HTTP/1.1\nHost: htcpcp.example.com\nContent-Type: application/coffee-pot-command\nAccept-Additions: cream, sugar\n\nstart",
                "response": "HTTP/1.1 418 I'm a teapot\nContent-Type: text/plain\n\nI'm a teapot!\n\nThis device is a teapot, not a coffee pot.\nAccording to RFC 2324 (HTCPCP/1.0), a teapot receiving\na request to brew coffee should respond with 418.\n\nHTCPCP/1.0 was an April Fools' RFC published in 1998.\nIt proposed a protocol for controlling coffee pots over HTTP.\n\nThe 418 status code has since become beloved by developers\nand is now permanently reserved, even though it started as a joke.\n\nFun facts:\n- The BREW method was proposed for making coffee\n- Accept-Additions header was for cream, sugar, etc.\n- There's even a 406 Not Acceptable for when you ask\n  for additions the pot doesn't have\n\nFor more information:\nhttps://tools.ietf.org/html/rfc2324\n\nP.S. I can make excellent tea though! Try:\nBREW /pot-0 HTTP/1.1\nContent-Type: message/teapot",
                "explanation": "Una implementación educativa que enseña sobre el origen humorístico del código 418, implementando el protocolo HTCPCP propuesto en el RFC 2324 y explicando la historia detrás del código de estado más divertido de HTTP."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 2324 (April Fools' RFC), RFC 7168 (update)",
        "relatedHeaders": [
            "Accept-Additions",
            "Content-Type"
        ],
        "technicalNotes": "418 I'm a teapot es oficialmente un código reservado pero NO debe usarse para indicar errores reales en aplicaciones de producción. Origen: RFC 2324 (1998) como parte del protocolo HTCPCP para controlar cafeteras por internet (broma del April Fools'). A pesar de ser una broma, está oficialmente reservado en el registro IANA desde entonces. En 2017 hubo intento de eliminarlo (save418.com movement lo preservó). RFC 7168 (2014) actualizó HTCPCP pero mantuvo 418. Uso moderno: principalmente easter eggs y humor en APIs. Los clientes HTTP estándar no tienen lógica especial para 418. Es un símbolo de la cultura geek/developer y del lado humano de las especificaciones técnicas. NO usar en lugar de códigos apropiados como 400, 404, 501.",
        "images": [
            {
                "imageCover": "https://res.cloudinary.com/dovznesem/image/upload/v1768754171/418_sx9w7l.png",
                "alt": "Imagen que representa el nombre del código 418 I'm a teapot"
            },
            {
                "imageCharacter": "https://res.cloudinary.com/dovznesem/image/upload/v1768753832/43-removebg-preview_a0tody.png",
                "alt": "Imagen del código 418 I 'm a teapot"
            }
        ]
    },
    {
        "code": 419,
        "status": "Authentication Timeout / Page Expired",
        "category": "Client Error",
        "description": "El código 419 NO es un código de estado HTTP estándar oficial definido en ninguna RFC de IETF. Sin embargo, ha sido adoptado y utilizado de manera no estándar por algunos frameworks web, siendo Laravel (un popular framework PHP) el usuario más prominente. En Laravel, el código 419 se utiliza específicamente para indicar que un token CSRF (Cross-Site Request Forgery) ha expirado o es inválido, típicamente mostrando el mensaje 'Page Expired'. Este es un caso interesante de cómo los frameworks web a veces crean sus propios códigos de estado para necesidades específicas, aunque no estén en el estándar oficial HTTP. Cuando Laravel devuelve 419, está diciendo: 'Tu formulario o solicitud incluía un token CSRF que ya expiró, probablemente porque la página estuvo abierta demasiado tiempo antes de enviarla'. Los tokens CSRF son mecanismos de seguridad que previenen ataques donde un sitio malicioso intenta hacer que tu navegador envíe solicitudes no autorizadas a otro sitio donde estás autenticado. Laravel genera un token único por sesión y lo incluye en formularios; cuando el formulario se envía, valida que el token coincida. Si un usuario deja un formulario abierto por mucho tiempo (más allá del tiempo de vida del token, típicamente horas), el token expira, y al intentar enviar el formulario, Laravel responde con 419. Aunque 419 es específico de Laravel, otros frameworks han usado códigos en el rango 419-420 para propósitos similares no estándar. Algunos servidores proxy también han utilizado 419 para indicar timeouts de autenticación. Es importante notar que usar códigos de estado no estándar puede causar problemas de interoperabilidad, ya que clientes HTTP genéricos no tendrán lógica específica para manejarlos. Las mejores prácticas sugieren usar códigos estándar existentes (como 403 Forbidden o 401 Unauthorized con información adicional en el cuerpo) en lugar de inventar códigos nuevos, pero el uso de 419 por Laravel está tan extendido que es ampliamente reconocido en la comunidad PHP.",
        "useCases": [
            "Laravel: Token CSRF expirado en formularios (uso más común)",
            "Algunos frameworks PHP: Sesión expirada durante envío de formulario",
            "Uso no estándar: Timeout de autenticación en algunos servidores",
            "Indicar que una página debe ser recargada antes de reenviar",
            "NOTA: NO es un código HTTP oficial/estándar"
        ],
        "examples": [
            {
                "scenario": "Laravel - Token CSRF expirado en formulario",
                "request": "POST /profile/update HTTP/1.1\nHost: app.example.com\nContent-Type: application/x-www-form-urlencoded\nCookie: laravel_session=eyJpdiI6...\n\n_token=expired_csrf_token_abc123&name=John+Doe&email=john@example.com",
                "response": "HTTP/1.1 419 Page Expired\nContent-Type: text/html; charset=UTF-8\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>419 | Page Expired</title>\n    <style>\n        body { font-family: sans-serif; text-align: center; padding: 50px; }\n        h1 { color: #e74c3c; }\n    </style>\n</head>\n<body>\n    <h1>419</h1>\n    <h2>Page Expired</h2>\n    <p>The page has expired due to inactivity.</p>\n    <p>Please refresh and try again.</p>\n    <button onclick=\"window.location.reload()\">Refresh Page</button>\n    <hr>\n    <p><small>This happened because your CSRF token expired. Laravel generates tokens for security that expire after a period of inactivity.</small></p>\n</body>\n</html>",
                "explanation": "Este es el uso más común de 419: en Laravel, cuando un usuario deja un formulario abierto por mucho tiempo, el token CSRF expira. Al intentar enviar el formulario, Laravel detecta el token expirado y responde con 419, pidiendo al usuario que recargue la página para obtener un nuevo token."
            },
            {
                "scenario": "Laravel API - CSRF token inválido en JSON",
                "request": "POST /api/data HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nX-CSRF-TOKEN: invalid_or_expired_token\nCookie: XSRF-TOKEN=...\n\n{\n  \"action\": \"update\",\n  \"data\": {\n    \"field\": \"value\"\n  }\n}",
                "response": "HTTP/1.1 419 Page Expired\nContent-Type: application/json\n\n{\n  \"message\": \"CSRF token mismatch.\",\n  \"error\": \"TokenMismatchException\",\n  \"error_code\": 419,\n  \"explanation\": \"The CSRF token in your request is invalid or has expired\",\n  \"causes\": [\n    \"The token has expired due to session timeout\",\n    \"The session was cleared or regenerated\",\n    \"The token was not included in the request\",\n    \"The token doesn't match the session token\"\n  ],\n  \"resolution\": [\n    \"Obtain a fresh CSRF token from the server\",\n    \"Include the token in X-CSRF-TOKEN header or _token field\",\n    \"Ensure cookies are enabled for session management\"\n  ],\n  \"get_new_token\": \"GET /sanctum/csrf-cookie\",\n  \"documentation\": \"https://laravel.com/docs/csrf\",\n  \"note\": \"419 is a Laravel-specific status code, not part of official HTTP standards\"\n}",
                "explanation": "En una API Laravel, cuando el token CSRF en el encabezado X-CSRF-TOKEN no coincide o ha expirado, el servidor responde con 419 y proporciona información sobre cómo obtener un nuevo token."
            },
            {
                "scenario": "Alternativa estándar usando 403 Forbidden",
                "request": "POST /profile/update HTTP/1.1\nHost: standard-app.example.com\nContent-Type: application/x-www-form-urlencoded\n\n_token=expired_csrf_token&name=John+Doe",
                "response": "HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"csrf_token_expired\",\n  \"message\": \"The CSRF token has expired\",\n  \"error_type\": \"security\",\n  \"reason\": \"Your session token is no longer valid\",\n  \"token_lifetime\": \"2 hours\",\n  \"token_expired_at\": \"2024-01-17T14:00:00Z\",\n  \"current_time\": \"2024-01-17T16:30:00Z\",\n  \"explanation\": \"For security reasons, form tokens expire after a period of inactivity. This prevents CSRF attacks.\",\n  \"action_required\": \"Refresh the page to get a new token and resubmit the form\",\n  \"best_practice\": \"Instead of non-standard 419, we use standard 403 Forbidden with descriptive error information\",\n  \"note\": \"Using standard HTTP codes ensures better client compatibility\"\n}",
                "explanation": "MEJOR PRÁCTICA: En lugar de usar el código no estándar 419, una aplicación puede usar el código estándar 403 Forbidden con información detallada en el cuerpo sobre el problema específico de CSRF. Esto mantiene compatibilidad con clientes HTTP estándar."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP oficial)",
        "specification": "No oficial - Usado principalmente por Laravel framework",
        "relatedHeaders": [
            "X-CSRF-TOKEN",
            "Cookie",
            "Set-Cookie"
        ],
        "relatedCodes": [
            401,
            403
        ],
        "technicalNotes": "419 NO es un código HTTP estándar oficial. No aparece en ninguna RFC de IETF. Es una extensión no estándar popularizada por Laravel framework para indicar tokens CSRF expirados. Otros frameworks/servidores a veces usan 419 para timeouts de autenticación similares. MEJOR PRÁCTICA: Usar códigos estándar como 403 Forbidden con error específico en el cuerpo en lugar de códigos inventados. Ventajas de códigos estándar: mejor interoperabilidad, clientes HTTP genéricos los entienden, no confunde herramientas de debugging. El uso de 419 por Laravel está tan extendido que es reconocido en la comunidad PHP, pero puede causar confusión fuera de ese ecosistema. Clientes HTTP estándar tratarán 419 como un error genérico 4xx.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 419 Authentication Timeout"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 419 Authentication Timeout"
            }
        ]
    },
    {
        "code": 420,
        "status": "Method Failure / Enhance Your Calm",
        "category": "Client Error",
        "description": "El código 420 NO es un código de estado HTTP oficial estándar, pero ha sido utilizado históricamente por diferentes servicios y frameworks con significados completamente distintos, lo que lo hace particularmente confuso. Existen al menos tres usos diferentes y contradictorios de 420: (1) Twitter (antes de X) utilizó '420 Enhance Your Calm' como respuesta cuando un cliente estaba siendo rate-limited por hacer demasiadas solicitudes. El mensaje humorístico 'Enhance Your Calm' (Mejora tu calma) era la forma de Twitter de decir 'relájate y deja de hacer tantas solicitudes'. (2) Spring Framework (Java) en versiones antiguas utilizó '420 Method Failure' para indicar que un método específico falló durante el procesamiento. (3) En la cultura de internet, 420 es un número asociado con la cultura del cannabis, lo que ha llevado a algunos desarrolladores a usarlo humorísticamente en contextos relacionados. La falta de estandarización del código 420 ilustra perfectamente por qué es importante que los desarrolladores se adhieran a los códigos de estado HTTP oficiales en lugar de inventar los suyos propios. Cada servicio que usa 420 le da un significado diferente, lo que causa confusión para los clientes que intentan manejar las respuestas. En la práctica moderna, el uso de 420 ha disminuido significativamente: Twitter migró a usar el código estándar 429 Too Many Requests para rate limiting, que es el código correcto y oficial para ese propósito. Spring Framework también dejó de usar 420 en favor de códigos más apropiados y estándar. Hoy en día, 420 ocasionalmente aparece como easter egg humorístico en APIs (especialmente el 20 de abril, '4/20' en formato de fecha estadounidense), pero NO debe usarse en aplicaciones de producción serias. Los desarrolladores deben usar códigos estándar como 429 para rate limiting, 500 para fallos de métodos del servidor, o códigos apropiados según el contexto específico.",
        "useCases": [
            "Twitter (deprecado): Rate limiting - 'Enhance Your Calm' (ahora usa 429)",
            "Spring Framework (antiguo): Fallo de método (deprecado)",
            "Easter eggs humorísticos (especialmente 4/20)",
            "Uso en cultura de internet relacionado con cannabis (humorístico)",
            "NOTA: NO es estándar y NO debe usarse en producción"
        ],
        "examples": [
            {
                "scenario": "Twitter legacy - Rate limiting (uso histórico)",
                "request": "GET /1.1/statuses/user_timeline.json?count=200 HTTP/1.1\nHost: api.twitter.com\nAuthorization: Bearer user_access_token\n\n[solicitud número 181 en la última hora, excediendo límite de 180]",
                "response": "HTTP/1.1 420 Enhance Your Calm\nX-Rate-Limit-Limit: 180\nX-Rate-Limit-Remaining: 0\nX-Rate-Limit-Reset: 1705512000\nRetry-After: 3600\nContent-Type: application/json\n\n{\n  \"errors\": [\n    {\n      \"code\": 88,\n      \"message\": \"Rate limit exceeded\"\n    }\n  ],\n  \"status\": 420,\n  \"status_text\": \"Enhance Your Calm\",\n  \"explanation\": \"You have exceeded the rate limit for this endpoint\",\n  \"limit\": 180,\n  \"remaining\": 0,\n  \"reset_time\": \"2024-01-17T20:00:00Z\",\n  \"retry_after_seconds\": 3600,\n  \"humorous_message\": \"Whoa there, partner! Slow down and enhance your calm. You've made too many requests.\",\n  \"note\": \"This is a deprecated Twitter-specific code. Modern APIs should use 429 Too Many Requests instead.\"\n}",
                "explanation": "USO HISTÓRICO: Twitter usaba 420 con el mensaje humorístico 'Enhance Your Calm' para rate limiting. Este código ya NO se usa; Twitter/X migró al estándar 429 Too Many Requests. Se muestra solo con propósitos históricos/educativos."
            },
            {
                "scenario": "Alternativa CORRECTA usando 429 Too Many Requests",
                "request": "GET /api/data HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer user_token",
                "response": "HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1705512000\nRetry-After: 3600\nContent-Type: application/json\n\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"You have exceeded the rate limit\",\n  \"limit\": 100,\n  \"limit_window\": \"1 hour\",\n  \"remaining\": 0,\n  \"reset_at\": \"2024-01-17T20:00:00Z\",\n  \"retry_after_seconds\": 3600,\n  \"current_plan\": \"free\",\n  \"upgrade_info\": {\n    \"basic_plan\": \"500 requests/hour for $9.99/month\",\n    \"pro_plan\": \"5,000 requests/hour for $29.99/month\"\n  },\n  \"best_practice\": \"This uses standard HTTP 429, not non-standard 420\",\n  \"documentation\": \"https://api.example.com/docs/rate-limits\"\n}",
                "explanation": "MEJOR PRÁCTICA: Usar el código estándar 429 Too Many Requests para rate limiting en lugar del no estándar 420. Esto garantiza compatibilidad con todos los clientes HTTP y herramientas."
            },
            {
                "scenario": "Easter egg humorístico (4/20 reference)",
                "request": "GET /api/secret-endpoint HTTP/1.1\nHost: fun-api.example.com\nX-Special-Date: 2024-04-20",
                "response": "HTTP/1.1 420 Enhance Your Calm\nContent-Type: application/json\nX-Easter-Egg: true\n\n{\n  \"status\": 420,\n  \"message\": \"Enhance Your Calm\",\n  \"special_message\": \"Happy 4/20! 🌿\",\n  \"easter_egg\": true,\n  \"fun_facts\": [\n    \"420 is not an official HTTP status code\",\n    \"Twitter used it for rate limiting (now uses 429)\",\n    \"In internet culture, 420 has... other meanings\",\n    \"This is just a fun easter egg, not a real error!\"\n  ],\n  \"actual_response\": {\n    \"status\": 200,\n    \"data\": \"Your actual data here\",\n    \"message\": \"Everything is fine, this was just a playful response\"\n  },\n  \"note\": \"This is purely for entertainment. In production, always use standard HTTP codes.\",\n  \"seriously_though\": \"Don't use 420 in real APIs. Use proper codes like 429, 500, etc.\"\n}",
                "explanation": "Algunos desarrolladores usan 420 como easter egg humorístico, especialmente el 20 de abril (4/20). Aunque divertido, NO debe usarse para errores reales en producción. Este ejemplo es puramente educativo sobre el uso cultural del código."
            }
        ],
        "httpVersion": "N/A (No es estándar HTTP oficial)",
        "specification": "No oficial - Múltiples usos conflictivos no estandarizados",
        "relatedHeaders": [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset",
            "Retry-After"
        ],
        "relatedCodes": [
            429,
            500
        ],
        "technicalNotes": "420 NO es un código HTTP estándar oficial. Múltiples usos conflictivos: (1) Twitter: 'Enhance Your Calm' para rate limiting (DEPRECADO, ahora usa 429), (2) Spring Framework: 'Method Failure' (DEPRECADO), (3) Referencias culturales de internet (4/20). NUNCA usar en producción. Para rate limiting: usa 429 Too Many Requests (estándar oficial desde RFC 6585). Para fallos de método del servidor: usa 500 Internal Server Error o códigos 5xx apropiados. El uso de códigos no estándar causa: problemas de interoperabilidad, confusión en clientes HTTP, dificultades de debugging, incompatibilidad con herramientas de monitoreo. La historia de 420 es un ejemplo perfecto de por qué NO inventar códigos propios. Twitter eventualmente migró a 429 estándar, demostrando que los estándares existen por buenas razones.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 420 Method Failure"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 420 Method Failure"
            }
        ]
    },
    {
        "code": 421,
        "status": "Misdirected Request",
        "category": "Client Error",
        "description": "El código 421 Misdirected Request indica que la solicitud fue dirigida a un servidor que no es capaz de producir una respuesta. Este código fue introducido específicamente para HTTP/2 y está relacionado con la característica de multiplexación de conexiones de HTTP/2, donde múltiples nombres de host pueden compartir la misma conexión TCP. El servidor está diciendo: 'Recibí tu solicitud, pero está dirigida al nombre de host o esquema incorrecto para este servidor, y no puedo procesarla'. Este código es particularmente relevante en escenarios de HTTP/2 donde un cliente puede reutilizar una conexión existente para hacer solicitudes a diferentes hosts que comparten la misma dirección IP (algo común con CDNs, hosting compartido, o cuando múltiples dominios están detrás del mismo servidor). El problema surge cuando el cliente asume incorrectamente que el servidor puede manejar solicitudes para un host específico solo porque comparte la misma conexión o IP. Por ejemplo, imagine que un cliente establece una conexión HTTP/2 con 'www.example.com' (IP: 192.0.2.1). Luego descubre que 'api.example.com' también apunta a 192.0.2.1. El cliente podría intentar reutilizar la conexión existente para hacer solicitudes a 'api.example.com'. Si el servidor en esa conexión no está configurado para manejar 'api.example.com', responderá con 421. Las causas comunes incluyen: certificado TLS/SSL que no incluye el nombre de host solicitado en su Subject Alternative Name (SAN), servidor configurado para solo responder a ciertos nombres de host específicos, proxy o CDN que no puede enrutar la solicitud al backend correcto, o configuración de virtual host que no incluye el dominio solicitado. Cuando un cliente recibe 421, debe reintentar la solicitud en una nueva conexión directamente al host correcto, sin intentar reutilizar la conexión existente. El código 421 es fundamental para la seguridad en HTTP/2, ya que previene que los clientes hagan suposiciones incorrectas sobre qué hosts puede manejar una conexión compartida.",
        "useCases": [
            "HTTP/2: Solicitud a host incorrecto en conexión compartida/multiplexada",
            "Certificado TLS no incluye el dominio solicitado en SAN",
            "Virtual host no configurado para el nombre de host solicitado",
            "CDN o proxy no puede enrutar solicitud al backend apropiado",
            "Cliente intenta reutilizar conexión para host no autorizado",
            "Mismatch entre SNI (Server Name Indication) y Host header",
            "Configuración de servidor que restringe hosts permitidos por conexión"
        ],
        "examples": [
            {
                "scenario": "HTTP/2 - Reutilización incorrecta de conexión para diferente host",
                "request": "GET /api/data HTTP/2\nHost: api.example.com\nUser-Agent: HTTP2-Client/1.0\n\n[Esta solicitud se envió por una conexión HTTP/2 existente que fue establecida originalmente para www.example.com]",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"This server cannot produce a response for the requested host\",\n  \"requested_host\": \"api.example.com\",\n  \"connection_established_for\": \"www.example.com\",\n  \"issue\": \"Connection was established for www.example.com but request is for api.example.com\",\n  \"explanation\": \"While both domains may share the same IP address, this server is not configured to handle requests for api.example.com on this connection\",\n  \"http_version\": \"HTTP/2\",\n  \"reason\": \"The TLS certificate or virtual host configuration does not include api.example.com\",\n  \"action_required\": \"Establish a new connection specifically to api.example.com and retry the request\",\n  \"technical_details\": {\n    \"connection_reuse_attempted\": true,\n    \"tls_sni\": \"www.example.com\",\n    \"requested_authority\": \"api.example.com\",\n    \"certificate_sans\": [\"www.example.com\", \"example.com\"],\n    \"api_example_com_in_certificate\": false\n  },\n  \"recommendation\": \"Do not reuse this connection for api.example.com. Open a new connection.\",\n  \"rfc_reference\": \"RFC 7540, Section 9.1.2\"\n}",
                "explanation": "El cliente intentó reutilizar una conexión HTTP/2 existente (establecida para www.example.com) para hacer una solicitud a api.example.com. Sin embargo, el certificado TLS del servidor no incluye api.example.com en sus Subject Alternative Names, por lo que responde con 421 indicando que esta solicitud está mal dirigida."
            },
            {
                "scenario": "Certificado TLS sin el dominio solicitado",
                "request": ":method: GET\n:scheme: https\n:authority: subdomain.example.com\n:path: /resource\nuser-agent: Mozilla/5.0",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"TLS certificate does not cover the requested hostname\",\n  \"requested_hostname\": \"subdomain.example.com\",\n  \"tls_certificate_info\": {\n    \"common_name\": \"example.com\",\n    \"subject_alternative_names\": [\n      \"example.com\",\n      \"www.example.com\",\n      \"*.apps.example.com\"\n    ],\n    \"subdomain_covered\": false,\n    \"wildcard_match\": false\n  },\n  \"issue\": \"The SSL/TLS certificate presented during connection establishment does not include subdomain.example.com\",\n  \"security_concern\": \"Serving content for a hostname not in the certificate would be a security violation\",\n  \"resolution\": [\n    \"Establish a new HTTPS connection directly to subdomain.example.com\",\n    \"Verify that subdomain.example.com has a valid certificate\",\n    \"Do not attempt to reuse connections established for other domains\"\n  ],\n  \"note\": \"HTTP/2 connection multiplexing is limited to hosts covered by the TLS certificate\",\n  \"correct_hosts_for_this_connection\": [\n    \"example.com\",\n    \"www.example.com\",\n    \"*.apps.example.com\"\n  ]\n}",
                "explanation": "El certificado TLS de la conexión no incluye 'subdomain.example.com' en su lista de nombres alternativos. Por razones de seguridad, el servidor no puede servir contenido para un hostname que no está en el certificado, por lo que responde 421."
            },
            {
                "scenario": "Virtual host no configurado para el dominio solicitado",
                "request": "GET /home HTTP/2\nHost: newdomain.example.com",
                "response": "HTTP/2 421 Misdirected Request\nContent-Type: application/json\n\n{\n  \"error\": \"misdirected_request\",\n  \"message\": \"Server is not configured to handle this hostname\",\n  \"requested_host\": \"newdomain.example.com\",\n  \"server_ip\": \"203.0.113.50\",\n  \"configured_virtual_hosts\": [\n    \"example.com\",\n    \"www.example.com\",\n    \"blog.example.com\",\n    \"shop.example.com\"\n  ],\n  \"issue\": \"This server does not have a virtual host configuration for newdomain.example.com\",\n  \"explanation\": \"While newdomain.example.com may DNS-resolve to this server's IP, the server is not configured to serve content for this domain\",\n  \"possible_causes\": [\n    \"The domain was recently added but server config not updated\",\n    \"DNS was updated but points to wrong server\",\n    \"Virtual host configuration is missing or incomplete\"\n  ],\n  \"action_for_client\": \"Do not retry on this connection. Verify the correct server for newdomain.example.com\",\n  \"action_for_admin\": \"If newdomain.example.com should be served from this server, add virtual host configuration and reload server\",\n  \"dns_info\": \"Verify that newdomain.example.com DNS points to the correct server\"\n}",
                "explanation": "Aunque newdomain.example.com puede resolver a la misma IP que esta conexión, el servidor no tiene una configuración de virtual host para ese dominio. El servidor responde 421 indicando que no puede manejar solicitudes para ese hostname."
            }
        ],
        "httpVersion": "HTTP/2, HTTP/3",
        "specification": "RFC 7540, Section 9.1.2 (HTTP/2)",
        "relatedHeaders": [
            "Host",
            ":authority (HTTP/2 pseudo-header)"
        ],
        "relatedCodes": [
            400,
            404
        ],
        "technicalNotes": "421 fue introducido específicamente para HTTP/2 para manejar problemas de multiplexación de conexiones. En HTTP/2, múltiples requests a diferentes hosts pueden compartir la misma conexión TCP si los hosts comparten la misma IP. Sin embargo, esto está limitado por: (1) el certificado TLS debe cubrir todos los hosts (via SAN), (2) el servidor debe estar configurado para manejar esos hosts. Cuando un cliente recibe 421, DEBE reintentar la solicitud en una nueva conexión, no puede seguir usando la conexión actual para ese host. Esto previene problemas de seguridad donde un servidor podría servir contenido para un host que no está autorizado a manejar. 421 es diferente de 404: 404 significa que el recurso no existe en el host correcto; 421 significa que el host en sí es incorrecto para esta conexión. En HTTP/1.1, 421 es raro porque cada conexión típicamente va a un solo host.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 421 Misdirected Request"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 421 Misdirected Request"
            }
        ]
    },
    {
        "code": 422,
        "status": "Unprocessable Entity",
        "category": "Client Error",
        "description": "El código 422 Unprocessable Entity indica que el servidor entiende el tipo de contenido de la solicitud (el formato es correcto), y la sintaxis de la entidad de la solicitud es correcta, pero fue incapaz de procesar las instrucciones contenidas debido a errores de validación semántica o lógica de negocio. Este código es fundamental para distinguir entre diferentes tipos de errores de validación. La diferencia clave con otros códigos similares es: 400 Bad Request se usa para errores de sintaxis o formato (JSON malformado, parámetros faltantes), 409 Conflict se usa cuando hay un conflicto con el estado actual del recurso (email duplicado, versión incorrecta), mientras que 422 se usa específicamente cuando la sintaxis es correcta pero los datos no tienen sentido semántico o violan reglas de negocio. El servidor está diciendo: 'Entiendo tu solicitud perfectamente en términos de formato, pero los datos que enviaste no son válidos según las reglas de mi lógica de negocio'. El código 422 fue originalmente definido en WebDAV (RFC 4918) pero ha sido ampliamente adoptado por APIs RESTful modernas porque llena un vacío importante: proporciona un código específico para errores de validación semántica. Los ejemplos típicos incluyen: una fecha de nacimiento en el futuro (sintácticamente es una fecha válida, pero semánticamente no tiene sentido), un número de teléfono con formato correcto pero con longitud inválida para el país especificado, un precio negativo donde solo se permiten valores positivos, un enum con valor sintácticamente válido pero que no existe en el sistema, o reglas de negocio complejas como 'la fecha de fin debe ser posterior a la fecha de inicio'. Las respuestas 422 bien diseñadas deben incluir información detallada sobre qué campos específicos fallaron la validación, qué regla fue violada, y cómo corregir el problema. Esto hace que las APIs sean más fáciles de usar y debuggear.",
        "useCases": [
            "Errores de validación semántica (datos bien formados pero inválidos)",
            "Violación de reglas de negocio en los datos enviados",
            "Valores fuera de rango permitido (edad negativa, precio negativo)",
            "Fechas lógicamente inválidas (fecha de nacimiento en el futuro)",
            "Relaciones de datos inconsistentes (fecha fin antes de fecha inicio)",
            "Enums o valores de lista que no existen en el sistema",
            "Campos que no cumplen reglas de formato específicas del negocio",
            "Validaciones que dependen del contexto o estado del sistema"
        ],
        "examples": [
            {
                "scenario": "Validación semántica - Fecha de nacimiento en el futuro",
                "request": "POST /api/users HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"birth_date\": \"2030-05-15\",\n  \"country\": \"US\"\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"The request contains semantically invalid data\",\n  \"errors\": [\n    {\n      \"field\": \"birth_date\",\n      \"value\": \"2030-05-15\",\n      \"error_code\": \"date_in_future\",\n      \"message\": \"Birth date cannot be in the future\",\n      \"current_date\": \"2024-01-17\",\n      \"validation_rule\": \"birth_date must be <= current_date\",\n      \"suggestion\": \"Please provide a valid birth date in the past\"\n    }\n  ],\n  \"note\": \"The JSON syntax is correct and the date format is valid, but the value doesn't make semantic sense\",\n  \"documentation\": \"https://api.example.com/docs/validation-rules\"\n}",
                "explanation": "El JSON está bien formado y la fecha tiene el formato correcto (YYYY-MM-DD), pero semánticamente no tiene sentido tener una fecha de nacimiento en el futuro. Este es un error de validación lógica, no sintáctica, por lo que se usa 422."
            },
            {
                "scenario": "Violación de reglas de negocio - Relaciones de datos inconsistentes",
                "request": "POST /api/events HTTP/1.1\nHost: calendar.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"title\": \"Project Meeting\",\n  \"start_date\": \"2024-02-15T14:00:00Z\",\n  \"end_date\": \"2024-02-15T13:00:00Z\",\n  \"location\": \"Conference Room A\",\n  \"attendees\": [\"user1@example.com\", \"user2@example.com\"]\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Event data violates business rules\",\n  \"errors\": [\n    {\n      \"field\": \"end_date\",\n      \"error_code\": \"invalid_date_range\",\n      \"message\": \"End date must be after start date\",\n      \"start_date\": \"2024-02-15T14:00:00Z\",\n      \"end_date\": \"2024-02-15T13:00:00Z\",\n      \"issue\": \"End date (13:00) is before start date (14:00)\",\n      \"business_rule\": \"end_date > start_date\",\n      \"suggestion\": \"Ensure the end time is later than the start time\"\n    }\n  ],\n  \"fields_validated\": {\n    \"title\": \"valid\",\n    \"start_date\": \"valid format\",\n    \"end_date\": \"valid format, but violates business rule\",\n    \"location\": \"valid\",\n    \"attendees\": \"valid\"\n  },\n  \"note\": \"All fields have correct syntax and format, but the relationship between start_date and end_date is logically invalid\"\n}",
                "explanation": "Ambas fechas tienen formato correcto (ISO 8601), pero la lógica de negocio requiere que end_date sea posterior a start_date. Esta es una validación semántica que requiere 422, no 400 (que sería para formato inválido)."
            },
            {
                "scenario": "Múltiples errores de validación semántica",
                "request": "POST /api/products HTTP/1.1\nHost: shop.example.com\nContent-Type: application/json\n\n{\n  \"name\": \"AB\",\n  \"price\": -25.99,\n  \"stock\": 150,\n  \"category\": \"invalid_category_xyz\",\n  \"discount_percentage\": 105,\n  \"weight\": 0,\n  \"dimensions\": {\n    \"length\": 10,\n    \"width\": -5,\n    \"height\": 8\n  }\n}",
                "response": "HTTP/1.1 422 Unprocessable Entity\nContent-Type: application/json\n\n{\n  \"error\": \"validation_failed\",\n  \"message\": \"Multiple validation errors in product data\",\n  \"total_errors\": 5,\n  \"errors\": [\n    {\n      \"field\": \"name\",\n      \"value\": \"AB\",\n      \"error_code\": \"min_length\",\n      \"message\": \"Product name must be at least 3 characters long\",\n      \"current_length\": 2,\n      \"required_length\": 3\n    },\n    {\n      \"field\": \"price\",\n      \"value\": -25.99,\n      \"error_code\": \"negative_value\",\n      \"message\": \"Price cannot be negative\",\n      \"constraint\": \"price >= 0\"\n    },\n    {\n      \"field\": \"category\",\n      \"value\": \"invalid_category_xyz\",\n      \"error_code\": \"invalid_enum\",\n      \"message\": \"Category is not valid\",\n      \"valid_categories\": [\"electronics\", \"clothing\", \"books\", \"food\", \"toys\"],\n      \"suggestion\": \"Choose from the list of valid categories\"\n    },\n    {\n      \"field\": \"discount_percentage\",\n      \"value\": 105,\n      \"error_code\": \"out_of_range\",\n      \"message\": \"Discount percentage must be between 0 and 100\",\n      \"min\": 0,\n      \"max\": 100\n    },\n    {\n      \"field\": \"dimensions.width\",\n      \"value\": -5,\n      \"error_code\": \"negative_dimension\",\n      \"message\": \"Width cannot be negative\",\n      \"constraint\": \"width > 0\"\n    }\n  ],\n  \"note\": \"All fields are syntactically correct (proper types, valid JSON), but fail semantic/business validation\"\n}",
                "explanation": "El JSON está perfectamente formado y todos los tipos de datos son correctos, pero múltiples campos fallan validaciones de lógica de negocio: nombre muy corto, precio negativo, categoría inexistente, descuento mayor a 100%, dimensión negativa. Todos son errores semánticos, no sintácticos."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), adoptado ampliamente por APIs REST",
        "relatedHeaders": [
            "Content-Type"
        ],
        "relatedCodes": [
            400,
            409
        ],
        "technicalNotes": "422 es para errores de VALIDACIÓN SEMÁNTICA/LÓGICA, no sintáctica. Diferencias clave: 400 Bad Request = sintaxis incorrecta, JSON malformado, tipos incorrectos; 422 Unprocessable Entity = sintaxis correcta, pero datos semánticamente inválidos o violan reglas de negocio; 409 Conflict = datos válidos pero conflicto con estado actual del recurso. Originalmente de WebDAV (RFC 4918) pero ampliamente adoptado por APIs REST modernas. Las mejores prácticas para respuestas 422: incluir array detallado de errores, especificar qué campo falló, explicar qué regla fue violada, proporcionar valores aceptables/rangos, sugerir cómo corregir. 422 hace APIs más usables al distinguir claramente entre errores de sintaxis vs semántica.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 422 Unprocessable Entity"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 422 Unprocessable Entity"
            }
        ]
    },
    {
        "code": 423,
        "status": "Locked",
        "category": "Client Error",
        "description": "El código 423 Locked indica que el recurso al que se está intentando acceder está bloqueado (locked). Este código fue definido originalmente como parte de la extensión WebDAV (Web Distributed Authoring and Versioning) del protocolo HTTP, que permite a los usuarios editar y gestionar archivos en servidores web remotos de forma colaborativa. El concepto de 'locking' es fundamental en sistemas de edición colaborativa para prevenir conflictos cuando múltiples usuarios intentan modificar el mismo recurso simultáneamente. El servidor está diciendo: 'Este recurso está bloqueado actualmente y no puede ser modificado hasta que se libere el bloqueo'. Los bloqueos en WebDAV pueden ser de dos tipos: (1) bloqueos exclusivos (exclusive locks) donde solo el propietario del bloqueo puede modificar el recurso, y (2) bloqueos compartidos (shared locks) donde múltiples usuarios pueden leer pero ninguno puede modificar hasta que todos los bloqueos se liberen. Cuando un recurso está bloqueado, las operaciones que intentan modificarlo (PUT, PATCH, DELETE, MOVE, COPY) fallarán con 423. Sin embargo, las operaciones de solo lectura (GET, HEAD) generalmente siguen siendo permitidas. Los bloqueos típicamente incluyen: un token de bloqueo único que identifica el bloqueo, información sobre quién tiene el bloqueo, un timeout después del cual el bloqueo expira automáticamente si no se renueva, y el alcance del bloqueo (el recurso específico o una colección completa). Aunque 423 se originó en WebDAV, también puede ser útil en APIs REST modernas que implementan mecanismos de bloqueo pesimista para gestionar concurrencia. Por ejemplo, un sistema de gestión de documentos podría bloquear un documento cuando un usuario comienza a editarlo, respondiendo con 423 a otros usuarios que intenten modificarlo simultáneamente. El código 423 es diferente de 409 Conflict: 409 se usa para conflictos de concurrencia optimista (donde detectas el conflicto después de que ocurrió), mientras que 423 se usa para concurrencia pesimista (donde previenes el conflicto bloqueando el recurso por adelantado).",
        "useCases": [
            "WebDAV: Recurso bloqueado durante edición colaborativa de archivos",
            "Documentos bloqueados mientras un usuario los está editando",
            "Recursos administrativos bloqueados durante operaciones de mantenimiento",
            "Archivos en proceso de revisión o aprobación que no pueden modificarse",
            "Registros de base de datos bloqueados para prevenir modificaciones concurrentes",
            "Recursos en workflow que requieren completar pasos antes de modificación",
            "Contenido bloqueado por razones legales o de cumplimiento",
            "Sistemas de checkout/checkin donde el recurso está 'checked out' por otro usuario"
        ],
        "examples": [
            {
                "scenario": "WebDAV - Intento de modificar archivo bloqueado",
                "request": "PUT /documents/quarterly-report.docx HTTP/1.1\nHost: webdav.example.com\nContent-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document\nAuthorization: Bearer user_token_jane\nContent-Length: 524288\n\n[binary document data]",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:error xmlns:D=\"DAV:\">\n  <D:lock-token-submitted>\n    <D:href>/documents/quarterly-report.docx</D:href>\n  </D:lock-token-submitted>\n  <D:resource-locked>\n    <D:message>The resource is locked and cannot be modified</D:message>\n    <D:lock-owner>john.smith@example.com</D:lock-owner>\n    <D:lock-type>exclusive write</D:lock-type>\n    <D:lock-scope>exclusive</D:lock-scope>\n    <D:lock-token>opaquelocktoken:f81d4fae-7dec-11d0-a765-00a0c91e6bf6</D:lock-token>\n    <D:lock-created>2024-01-17T14:30:00Z</D:lock-created>\n    <D:lock-timeout>Second-7200</D:lock-timeout>\n    <D:lock-expires>2024-01-17T16:30:00Z</D:lock-expires>\n  </D:resource-locked>\n</D:error>",
                "explanation": "El usuario Jane intenta modificar un documento, pero está bloqueado exclusivamente por John Smith quien lo está editando. El servidor responde con 423 proporcionando información sobre quién tiene el bloqueo y cuándo expira."
            },
            {
                "scenario": "API REST moderna - Documento en edición",
                "request": "PATCH /api/documents/789 HTTP/1.1\nHost: docs.example.com\nContent-Type: application/json\nAuthorization: Bearer user_b_token\n\n{\n  \"title\": \"Updated Title\",\n  \"content\": \"Updated content...\"\n}",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/json\n\n{\n  \"error\": \"resource_locked\",\n  \"message\": \"This document is currently locked by another user\",\n  \"resource_id\": 789,\n  \"resource_type\": \"document\",\n  \"resource_title\": \"Project Proposal Q1 2024\",\n  \"lock_info\": {\n    \"locked\": true,\n    \"lock_type\": \"exclusive\",\n    \"locked_by\": {\n      \"user_id\": \"user_a_123\",\n      \"name\": \"Alice Johnson\",\n      \"email\": \"alice.johnson@example.com\"\n    },\n    \"locked_at\": \"2024-01-17T15:00:00Z\",\n    \"lock_duration\": \"30 minutes\",\n    \"lock_expires_at\": \"2024-01-17T15:30:00Z\",\n    \"time_remaining\": \"15 minutes\",\n    \"reason\": \"User is actively editing the document\"\n  },\n  \"allowed_operations\": [\n    \"GET /api/documents/789 (view document)\",\n    \"GET /api/documents/789/history (view history)\",\n    \"POST /api/documents/789/comments (add comments)\"\n  ],\n  \"suggestions\": [\n    \"Wait until the lock expires (15 minutes remaining)\",\n    \"Contact alice.johnson@example.com to request they release the lock\",\n    \"Subscribe to lock release notifications: POST /api/documents/789/watch\"\n  ],\n  \"note\": \"The document can still be viewed but cannot be modified while locked\"\n}",
                "explanation": "En una API REST moderna, el usuario B intenta modificar un documento que está siendo editado por el usuario A. El sistema usa bloqueo pesimista (423) en lugar de control de concurrencia optimista (409) para prevenir conflictos antes de que ocurran."
            },
            {
                "scenario": "Recurso bloqueado administrativamente",
                "request": "DELETE /api/products/critical-item-001 HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer regular_user_token",
                "response": "HTTP/1.1 423 Locked\nContent-Type: application/json\n\n{\n  \"error\": \"resource_locked\",\n  \"message\": \"This product is locked and cannot be deleted\",\n  \"resource_id\": \"critical-item-001\",\n  \"resource_name\": \"Legacy System Integration Component\",\n  \"lock_info\": {\n    \"locked\": true,\n    \"lock_type\": \"administrative\",\n    \"locked_by\": \"system_administrator\",\n    \"locked_at\": \"2024-01-10T09:00:00Z\",\n    \"lock_reason\": \"Critical component required for legacy system integration. Deletion would break production systems.\",\n    \"lock_permanent\": true,\n    \"unlock_requires\": \"System administrator approval and impact assessment\"\n  },\n  \"impact_warning\": {\n    \"dependent_systems\": 15,\n    \"active_integrations\": 23,\n    \"estimated_downtime_if_deleted\": \"4-8 hours\",\n    \"affected_users\": \"approximately 5,000\"\n  },\n  \"alternative_actions\": [\n    \"Mark as deprecated instead: PATCH /api/products/critical-item-001/deprecate\",\n    \"Create replacement: POST /api/products (then migrate integrations)\",\n    \"Request administrative unlock: POST /api/admin/unlock-requests\"\n  ],\n  \"contact\": \"For unlock requests, contact: admin-team@example.com\",\n  \"documentation\": \"https://docs.example.com/critical-resources\"\n}",
                "explanation": "Un producto crítico está bloqueado administrativamente para prevenir eliminación accidental que causaría problemas en producción. El bloqueo es permanente y requiere aprobación administrativa para removerse. Se proporcionan alternativas y contexto sobre el impacto."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.3",
        "relatedHeaders": [
            "Lock-Token",
            "If",
            "Timeout"
        ],
        "relatedCodes": [
            409
        ],
        "technicalNotes": "423 es específico de WebDAV pero puede usarse en APIs REST para bloqueo pesimista. Diferencias clave: 423 Locked = recurso activamente bloqueado, prevención proactiva de conflictos (concurrencia pesimista); 409 Conflict = conflicto detectado después de ocurrir (concurrencia optimista). En WebDAV, los bloqueos se crean con LOCK method, se liberan con UNLOCK method. Los bloqueos incluyen: lock token (identificador único), owner (quién tiene el bloqueo), timeout (cuándo expira), scope (exclusive o shared), depth (recurso individual o colección). Las operaciones de lectura (GET) generalmente están permitidas en recursos bloqueados. Los bloqueos pueden ser: temporales (con timeout) o indefinidos. La respuesta 423 debe incluir información sobre el bloqueo para ayudar al usuario a entender cuándo/cómo proceder. En APIs modernas, considerar si bloqueo pesimista (423) o optimista (409 con ETags) es más apropiado.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 423 Locked"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 423 Locked"
            }
        ]
    },
    {
        "code": 424,
        "status": "Failed Dependency",
        "category": "Client Error",
        "description": "El código 424 Failed Dependency indica que la solicitud falló debido a que una solicitud previa ha fallado. Este código fue definido originalmente en la extensión WebDAV (RFC 4918) y se utiliza principalmente en contexto de solicitudes que dependen de otras solicitudes previas para tener éxito. El servidor está diciendo: 'No puedo procesar tu solicitud porque depende de otra operación que falló anteriormente'. Este código es especialmente relevante en operaciones batch o transaccionales donde múltiples acciones están relacionadas y el fallo de una causa que las subsecuentes también fallen. En el contexto WebDAV original, esto ocurre típicamente con el método PROPPATCH (que modifica propiedades de recursos) o en operaciones complejas que involucran múltiples recursos. Por ejemplo, si intentas copiar una estructura completa de directorios pero una de las carpetas intermedias no puede ser creada, las operaciones subsecuentes que dependían de esa carpeta fallarán con 424. El código 424 comunica que el fallo no es culpa de la solicitud actual en sí misma, sino de una dependencia que no se cumplió. Aunque 424 se originó en WebDAV, también puede ser útil en APIs REST modernas que implementan operaciones transaccionales o en cadena. Por ejemplo, en una API que procesa un flujo de trabajo de múltiples pasos, si el paso 2 falla, el paso 3 podría fallar con 424 indicando que no pudo proceder debido a la falla del paso 2. Es importante distinguir 424 de otros códigos similares: 412 Precondition Failed se usa cuando una precondición especificada en headers no se cumple, 422 Unprocessable Entity se usa para errores de validación semántica de la solicitud actual, mientras que 424 se usa específicamente cuando el fallo es debido a una dependencia externa o previa que falló. El código 424 es relativamente raro en APIs web modernas porque muchos sistemas prefieren manejar dependencias de manera diferente, como transacciones all-or-nothing o respuestas parciales con códigos de éxito/error individuales.",
        "useCases": [
            "WebDAV: Operación que depende de otra operación que falló",
            "APIs batch donde una operación falla y causa que dependencias fallen",
            "Workflows de múltiples pasos donde paso anterior falló",
            "Operaciones transaccionales en cadena con dependencias",
            "Creación de recursos jerárquicos donde padre no pudo crearse",
            "Procesamiento de solicitudes compuestas donde componentes dependen entre sí",
            "Operaciones que requieren recursos previos que no se pudieron crear"
        ],
        "examples": [
            {
                "scenario": "WebDAV - Copia de estructura con dependencias fallidas",
                "request": "COPY /source-folder/ HTTP/1.1\nHost: webdav.example.com\nDestination: /backup/source-folder/\nDepth: infinity\nOverwrite: F",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n  <D:response>\n    <D:href>/source-folder/</D:href>\n    <D:status>HTTP/1.1 201 Created</D:status>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/</D:href>\n    <D:status>HTTP/1.1 403 Forbidden</D:status>\n    <D:error>\n      <D:message>Insufficient permissions to create this folder</D:message>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/document.txt</D:href>\n    <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n    <D:error>\n      <D:message>Cannot copy file because parent folder creation failed</D:message>\n      <D:failed-dependency>/source-folder/subfolder1/</D:failed-dependency>\n      <D:dependency-error>403 Forbidden</D:dependency-error>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/subfolder1/image.jpg</D:href>\n    <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n    <D:error>\n      <D:message>Cannot copy file because parent folder creation failed</D:message>\n      <D:failed-dependency>/source-folder/subfolder1/</D:failed-dependency>\n    </D:error>\n  </D:response>\n  <D:response>\n    <D:href>/source-folder/readme.txt</D:href>\n    <D:status>HTTP/1.1 201 Created</D:status>\n  </D:response>\n</D:multistatus>",
                "explanation": "Se intentó copiar una estructura de carpetas completa. La carpeta raíz se creó exitosamente (201), pero subfolder1 falló con 403 por permisos insuficientes. Como resultado, los archivos dentro de subfolder1 (document.txt, image.jpg) no pudieron copiarse y reciben 424 Failed Dependency porque dependen de que la carpeta padre exista, lo cual falló."
            },
            {
                "scenario": "API REST - Workflow de múltiples pasos con dependencia fallida",
                "request": "POST /api/workflows/order-processing HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\nAuthorization: Bearer valid_token\n\n{\n  \"order_id\": \"ORD-12345\",\n  \"steps\": [\n    {\"step\": \"validate_inventory\"},\n    {\"step\": \"reserve_items\"},\n    {\"step\": \"process_payment\"},\n    {\"step\": \"create_shipment\"},\n    {\"step\": \"send_confirmation\"}\n  ]\n}",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/json\n\n{\n  \"workflow_id\": \"WF-67890\",\n  \"order_id\": \"ORD-12345\",\n  \"overall_status\": \"partially_failed\",\n  \"steps_results\": [\n    {\n      \"step\": \"validate_inventory\",\n      \"status\": 200,\n      \"result\": \"success\",\n      \"message\": \"All items available in inventory\",\n      \"timestamp\": \"2024-01-17T16:00:00Z\"\n    },\n    {\n      \"step\": \"reserve_items\",\n      \"status\": 200,\n      \"result\": \"success\",\n      \"message\": \"Items reserved successfully\",\n      \"reservation_id\": \"RES-11111\",\n      \"timestamp\": \"2024-01-17T16:00:01Z\"\n    },\n    {\n      \"step\": \"process_payment\",\n      \"status\": 402,\n      \"result\": \"failed\",\n      \"error\": \"payment_declined\",\n      \"message\": \"Payment method declined by bank\",\n      \"decline_reason\": \"Insufficient funds\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    },\n    {\n      \"step\": \"create_shipment\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"dependency_failed\",\n      \"message\": \"Cannot create shipment because payment processing failed\",\n      \"failed_dependency\": \"process_payment\",\n      \"dependency_error\": \"payment_declined\",\n      \"explanation\": \"Shipment creation requires successful payment\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    },\n    {\n      \"step\": \"send_confirmation\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"dependency_failed\",\n      \"message\": \"Cannot send confirmation because payment failed\",\n      \"failed_dependency\": \"process_payment\",\n      \"explanation\": \"Confirmation can only be sent for successful orders\",\n      \"timestamp\": \"2024-01-17T16:00:02Z\"\n    }\n  ],\n  \"successful_steps\": 2,\n  \"failed_steps\": 1,\n  \"failed_dependency_steps\": 2,\n  \"rollback_actions\": [\n    {\n      \"action\": \"release_reservation\",\n      \"reservation_id\": \"RES-11111\",\n      \"status\": \"completed\",\n      \"message\": \"Items returned to available inventory\"\n    }\n  ],\n  \"next_actions\": [\n    \"Update payment method\",\n    \"Retry workflow with valid payment\"\n  ]\n}",
                "explanation": "Un workflow de procesamiento de orden ejecuta múltiples pasos secuenciales. Los pasos 1 y 2 tienen éxito, pero el paso 3 (process_payment) falla con 402 porque la tarjeta fue declinada. Los pasos 4 y 5 (create_shipment, send_confirmation) no pueden proceder porque dependen de un pago exitoso, por lo que reciben 424 Failed Dependency. El sistema automáticamente revierte las reservaciones exitosas."
            },
            {
                "scenario": "Operación batch con dependencias entre items",
                "request": "POST /api/batch/create-project-structure HTTP/1.1\nHost: pm.example.com\nContent-Type: application/json\n\n{\n  \"project_name\": \"New Website Redesign\",\n  \"operations\": [\n    {\"type\": \"create_project\", \"name\": \"Website Redesign\"},\n    {\"type\": \"create_team\", \"project_ref\": \"@project\", \"name\": \"Design Team\"},\n    {\"type\": \"create_milestone\", \"project_ref\": \"@project\", \"name\": \"Design Phase\"},\n    {\"type\": \"assign_team_to_milestone\", \"team_ref\": \"@team\", \"milestone_ref\": \"@milestone\"}\n  ]\n}",
                "response": "HTTP/1.1 207 Multi-Status\nContent-Type: application/json\n\n{\n  \"batch_id\": \"BATCH-999\",\n  \"operations_result\": [\n    {\n      \"operation\": 1,\n      \"type\": \"create_project\",\n      \"status\": 201,\n      \"result\": \"success\",\n      \"project_id\": \"PROJ-456\",\n      \"message\": \"Project created successfully\"\n    },\n    {\n      \"operation\": 2,\n      \"type\": \"create_team\",\n      \"status\": 409,\n      \"result\": \"failed\",\n      \"error\": \"team_name_conflict\",\n      \"message\": \"A team with name 'Design Team' already exists\",\n      \"existing_team_id\": \"TEAM-123\"\n    },\n    {\n      \"operation\": 3,\n      \"type\": \"create_milestone\",\n      \"status\": 201,\n      \"result\": \"success\",\n      \"milestone_id\": \"MILE-789\",\n      \"message\": \"Milestone created successfully\"\n    },\n    {\n      \"operation\": 4,\n      \"type\": \"assign_team_to_milestone\",\n      \"status\": 424,\n      \"result\": \"failed_dependency\",\n      \"error\": \"team_creation_failed\",\n      \"message\": \"Cannot assign team to milestone because team creation failed\",\n      \"failed_dependency\": \"create_team (operation 2)\",\n      \"dependency_error\": \"team_name_conflict\",\n      \"explanation\": \"This operation requires a newly created team, but team creation failed due to name conflict\"\n    }\n  ],\n  \"summary\": {\n    \"total_operations\": 4,\n    \"successful\": 2,\n    \"failed\": 1,\n    \"failed_dependencies\": 1\n  },\n  \"partial_success\": true,\n  \"created_resources\": [\n    {\"type\": \"project\", \"id\": \"PROJ-456\"},\n    {\"type\": \"milestone\", \"id\": \"MILE-789\"}\n  ],\n  \"resolution\": \"Use existing team TEAM-123 or rename the new team and retry operation 4\"\n}",
                "explanation": "Una operación batch intenta crear una estructura de proyecto completa. La creación de proyecto y milestone tienen éxito, pero la creación de equipo falla porque ya existe un equipo con ese nombre (409). La operación final de asignar el equipo al milestone recibe 424 Failed Dependency porque depende de la creación exitosa del nuevo equipo, que falló."
            }
        ],
        "httpVersion": "HTTP/1.1",
        "specification": "RFC 4918 (WebDAV), Section 11.4",
        "relatedHeaders": [],
        "relatedCodes": [
            207,
            412,
            422
        ],
        "technicalNotes": "424 indica que la solicitud actual falló debido a fallo de DEPENDENCIA PREVIA, no por error en la solicitud misma. Diferencias clave: 412 Precondition Failed = precondición en headers no cumplida; 422 Unprocessable Entity = error de validación en la solicitud actual; 424 Failed Dependency = fallo debido a dependencia externa/previa. Originalmente de WebDAV pero aplicable a APIs REST con operaciones dependientes. Típicamente aparece en respuestas 207 Multi-Status donde algunas operaciones tienen éxito y otras fallan. La respuesta debe indicar claramente QUÉ dependencia falló y POR QUÉ. Útil en: operaciones batch, workflows, transacciones complejas, jerarquías de recursos. Alternativas: algunas APIs prefieren all-or-nothing transactions con rollback completo en lugar de permitir fallos parciales con 424.",
        "images": [
            {
                "imageCover": "",
                "alt": "Imagen que representa el nombre del código 424 Failed Dependency"
            },
            {
                "imageCharacter": "",
                "alt": "Imagen del código 424 Failed Dependency"
            }
        ]
    }
]